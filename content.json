{"meta":{"title":"HuShengBin’s blog","subtitle":"码渣的个人博客","description":"记录码渣的奋斗史","author":"HuShengBin","url":"https://hsb786.github.io"},"pages":[{"title":"tags","date":"2018-04-09T10:16:56.000Z","updated":"2018-04-10T09:27:51.546Z","comments":true,"path":"tags/index.html","permalink":"https://hsb786.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-09T10:17:26.000Z","updated":"2018-04-09T10:17:26.909Z","comments":true,"path":"categories/index.html","permalink":"https://hsb786.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-04-09T10:17:26.000Z","updated":"2018-04-10T09:51:16.376Z","comments":true,"path":"about/index.html","permalink":"https://hsb786.github.io/about/index.html","excerpt":"","text":"码渣一枚，喜欢敲代码，可惜太笨 常年混迹在知乎、豆瓣、网易云。想做个文艺青年，可惜没那个气质 对科技非常感兴趣，可惜穷 联系方式：786398798@qq.com"}],"posts":[{"title":"二进制中1的个数","slug":"T10","date":"2018-04-10T08:11:44.000Z","updated":"2018-04-10T08:28:42.178Z","comments":true,"path":"2018/04/10/T10/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T10/","excerpt":"","text":"题目描述请实现一个函数，输入一个整数，输出该整数二进制表示中1的个数。 1234567891011121314/** * @Description: n&amp;(n-1)，将二进制表示中的最低位的1变为0 * @author: husb * @date: 2018年4月10日 下午3:23:02 */private static int numberOfOne(int n) &#123; int count=0; while(n!=0) &#123; n=n&amp;(n-1); count++; &#125; return count;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"旋转数组的最小数字","slug":"T08","date":"2018-04-10T08:11:33.000Z","updated":"2018-04-10T08:28:32.421Z","comments":true,"path":"2018/04/10/T08/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T08/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。 旋转数组的特点： 旋转之后的数组可以分为两个排序的子数组，且前面的子数组的元素都大于或等于后面子数组的元素。 最小或者最大元素位于两个子数组的分界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 由于旋转数组的特点，前一个数组一定大于后一个数组。数组内部是升序的。 * 所以就可以使用二分查找。 * 定义minIndex为0，highIndex为length-1 * 若中间位大于array[minIndex]，则代表中间位处于前面部分,将minIndex设为midIndex； * 小于则处于后面部分,将highIndex设为midIndex * 最终minIndex位于前一个数组的最后一位，highIndex位于后一个数组的第一位 * 显然最小值就是highIndex所在的值。 * 特殊情况，但minIndex与highIndex上的值相等时，无法判断中间值是在前，还是在后。 * 所以只能用顺序查找 * @author: husb * @date: 2018年4月10日 下午2:56:26 */public static int findMin(int[] array) &#123; int lowIndex = 0; int highIndex = array.length - 1; int midIndex = (lowIndex + highIndex) / 2; // 当代查找数组第一位大于最后一位时，代表是旋转数组 while (array[lowIndex] &gt;= array[highIndex]) &#123; // 临界条件 前面最后一位，后面第一位。 后面第一位就是最小值 if (highIndex - lowIndex == 1) &#123; return array[highIndex]; &#125; // 当左下标的元素等于右下标的元素时，无法判断中间位是位于前面还是后面的。 // 只能用顺序查找 if (array[lowIndex] == array[highIndex]) &#123; return findMinInOrder(array, lowIndex, highIndex); &#125; // 当中间位大于前面第一位时，代表处于前面 if (array[midIndex] &gt; array[lowIndex]) &#123; lowIndex = midIndex; &#125; else &#123; // 否则处于后面 highIndex = midIndex; &#125; // 计算中间位 midIndex = (lowIndex + highIndex) / 2; &#125; //已排好序，返回低位即可 return array[lowIndex];&#125;/** * @Description: 当有重复元素的时候，无法确定中间的元素是前面的还是后面的 * @author: husb * @date: 2018年4月10日 下午2:33:52 */private static int findMinInOrder(int[] array, int lowIndex, int highIndex) &#123; int result = array[lowIndex]; for (int i = lowIndex + 1; i &lt;= highIndex; i++) &#123; if (result &gt; array[i]) &#123; result = array[i]; &#125; &#125; return result;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"用两个队列实现一个栈","slug":"T0701","date":"2018-04-10T08:11:19.000Z","updated":"2018-04-10T08:28:23.590Z","comments":true,"path":"2018/04/10/T0701/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T0701/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142/** * Queue方法: * offer() 添加一个元素，失败则返回false * pool() 移除并返回队列头部元素，无则返回null * peek() 返回头部元素 无则返回null */private static Queue&lt;Object&gt; queue1 = new LinkedList&lt;&gt;();private static Queue&lt;Object&gt; queue2 = new LinkedList&lt;&gt;();private static void push(Object obj) &#123; if (!queue1.isEmpty()) &#123; queue1.offer(obj); &#125; else &#123; queue2.offer(obj); &#125; System.out.println(&quot;入栈:&quot; + obj);&#125;/** * @Description: 将一个队列里的数据都剪切给另一个队列中，只保留最后一位。 * 这样弹出的数据就是栈尾数据 * @author: husb * @date: 2018年4月10日 下午1:55:11 */private static void pop() &#123; if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; System.out.println(&quot;栈里没有数据&quot;); return; &#125; if (queue1.isEmpty()) &#123; while (queue2.size() &gt; 1) &#123; queue1.offer(queue2.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue2.poll()); return; &#125; while (queue1.size() &gt; 1) &#123; queue2.offer(queue1.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue1.poll());&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"用两个栈实现队列","slug":"T07","date":"2018-04-10T08:10:52.000Z","updated":"2018-04-10T08:28:03.136Z","comments":true,"path":"2018/04/10/T07/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T07/","excerpt":"","text":"题目描述用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。 1234567891011121314151617181920212223242526272829private static Stack&lt;Object&gt; stack1 = new Stack&lt;Object&gt;();private static Stack&lt;Object&gt; stack2 = new Stack&lt;Object&gt;();/** * @Description: stack1用来存放压入的元素 * @author: husb * @date: 2018年4月10日 下午1:19:07 */public static void appendTail(Object item) &#123; stack1.push(item);&#125;public static void deleteHead() &#123; //当stack2中有数据，直接弹出 if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); return; &#125; else &#123; //stack2压入stack1弹出的数据,这样stack2就是一个队列 while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); &#125; else &#123; System.out.println(&quot;栈中没有元素&quot;); &#125;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"替换空格","slug":"T04","date":"2018-04-10T08:08:27.000Z","updated":"2018-04-10T08:27:52.072Z","comments":true,"path":"2018/04/10/T04/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T04/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串We%20Are%20Happy。 1234567891011121314151617181920212223242526/** * beginIndex记录比较起始下标，spaceIndex记录空格下标。 * 添加beginIndex到spaceIndex的数据到StringBuilder中。 * beginIndex设为spaceIndex；spaceIndex重新计算 * @author: husb * @date: 2018年4月10日 下午12:26:55 */public static String replaceSpace(String str) &#123; //一开始想到的办法，一个字符一个字符的比， //这样会创建多个string对象,String.valueOf()内部是通过new String()来实现的。 /* * char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); for * (char c : chars) &#123; sb.append(c == &apos; &apos; ? &quot;%20&quot; : String.valueOf(c)); &#125; */ StringBuilder sb = new StringBuilder(); int beginIndex = 0; int spaceIndex = str.indexOf(&quot; &quot;, beginIndex); while (spaceIndex &gt; 0) &#123; sb.append(str.substring(beginIndex, spaceIndex)).append(&quot;%20&quot;); beginIndex = spaceIndex + 1; spaceIndex = str.indexOf(&quot; &quot;, beginIndex); &#125; sb.append(str.substring(beginIndex, str.length())); return sb.toString();&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"二维数组的查找","slug":"T03","date":"2018-04-10T04:01:22.000Z","updated":"2018-04-10T08:27:44.025Z","comments":true,"path":"2018/04/10/T03/","link":"","permalink":"https://hsb786.github.io/2018/04/10/T03/","excerpt":"","text":"题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122/** * @Description: 从左下角开始比，查找的数字大于遍历值右移；查找的数字小于遍历值上移 * @author: husb * @date: 2018年4月10日 上午11:55:27 */public static boolean find(int targer, int[][] array) &#123; int rows = array.length; int columns = array[0].length; int i = rows - 1, j = 0; while (targer != array[i][j]) &#123; if (targer &gt; array[i][j]) &#123; j++; &#125; else &#123; i--; &#125; if (i &lt; 0 || j &lt; 0 || i &gt; rows || j &gt; columns) &#123; return false; &#125; &#125; return true;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"}]},{"title":"threadPool","slug":"threadPool","date":"2018-04-10T02:13:01.000Z","updated":"2018-04-10T02:18:26.963Z","comments":true,"path":"2018/04/10/threadPool/","link":"","permalink":"https://hsb786.github.io/2018/04/10/threadPool/","excerpt":"","text":"Executor框架Exexutor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，可以用来控制线程的启动、执行和关闭，可以简化并发编程的操作。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。Executor框架包括：线程池、Executor、Exexutors、ExecutorService、CompletionService、Future、Callable等。","categories":[],"tags":[]},{"title":"java基础总结","slug":"javaBase","date":"2018-04-09T13:28:54.000Z","updated":"2018-04-09T13:50:00.374Z","comments":true,"path":"2018/04/09/javaBase/","link":"","permalink":"https://hsb786.github.io/2018/04/09/javaBase/","excerpt":"","text":"初始化顺序 父类（静态变量，静态语句块） 子类（静态变量，静态语句块） 父类（实例变量，普通语句块） 父类（构造函数） 子类（实例变量，普通语句块） 子类（构造函数） Object 123456789101112131415161718192021public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; 异常 Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error用来表示JVM无法处理的错误，Exception分为两种： 受检异常（checked exception）：需要try…catch…语句捕获并进行处理，并且可以从一场恢复 非受检异常（unchecked exception）：是程序运行时错误，例如除0会引发Arithmetic Exceptino，此时程序崩溃并且无法恢复","categories":[],"tags":[]},{"title":"需要注意的一些东西","slug":"needFocus","date":"2018-04-09T05:53:41.000Z","updated":"2018-04-09T12:52:57.117Z","comments":true,"path":"2018/04/09/needFocus/","link":"","permalink":"https://hsb786.github.io/2018/04/09/needFocus/","excerpt":"","text":"Streams 引入的原因 声明性方式处理数据集合 透明的进行处理，提高性能 流与集合 集合与流的差异就在于什么时候进行计算 集合是内存中的数据结构，包含数据结构中目前所有的值 流的元素则是按需计算/生存 遍历数据的方式 集合使用Collection接口，需要用户去做迭代，称为外部迭代 流的Streams库使用内部迭代 流的使用 一个数据源（如集合）来执行一个查询 一个中间操作链，形成一条流的流水线 一个终端操作，执行流水线，并能生产结果 流的操作类型 Intermediate : 一个流后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，也就是说，仅仅调用到这类方法，并没有真正开始流的遍历 Terminal ： 一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一根操作。terminal操作的执行，才会真正开始流的变量 happens-before 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系需要注意的是，上面提到的两个操作可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作可见 happends-before规则 程序顺序规则： 单个线程中的每个操作，happens-before于该线程中的任意后续操作 监视器锁规则： 对一个锁的解锁，happens-before于随后对这个锁的加锁 volatile变量规则： 对一个volatile变量的写，happends-before于任意后续对这个volatile变量的读 传递性： 如果A happeens-before B，且 B happeend-before C，那么A happeens-before C join规则： 如果线程A执行操作ThreadB.join()成功返回，那么线程B中的任意操作happeens-before与线程A从ThreadB.join()操作成功返回 fail-fast fail-fast机制是java集合(Collection)中的一种错误机制。当多个线程对同一集合的内容进行操作时，就可能会产生fail-fast事件。 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件 要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常 当使用fail-fast iterator对Collection或对Map进行操作过程中尝试直接修改Collection/Map的内容时，即使是在单线程下运行，java.util.ConcurrentModificationException异常也将抛出 Iterator是工作在一个独立的线程，并且拥有一个mutex锁。Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来对象发生变化时，这个索引表的内容不会同步该表，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照fail-fast原则Iterator会马上抛出ConsurrentModificationException异常。 所以Iterator在工作的时候是不允许被迭代的对象被改变的。但你可以使用Iterator本身的方法remove()来删除对象，Iteraror.remove()方法会在删除当前迭代对象的同时维护索引的一致性。 数据库三大范式 1NF：字段不可再分 2NF：主键依赖，一张表里的数据，必须是跟主键相关的 3NF：任意两个表不能出现重复的非主键字段 设计模式六大原则 单一职责(Single Responsibility Principle)：一个类只负责一个功能领域中的相应职责 开闭(Open-Closed Principle)：对扩展开放，对修改关闭 里氏替换(Liskov Subsitution Principle)：子类能出现在基类出现的地方 依赖倒置(Dependency Inversion Principle)：针对接口编程，而不是针对实现类编程 接口隔离(Interface Segregation Principle)：使用多个专门的接口，而不使用单一的总接口 迪米特(Law of Demeter)：一个类尽可能少的与其它类发生相互作用","categories":[],"tags":[]},{"title":"记录一些容易忘记的东西","slug":"easyForget","date":"2018-04-09T00:42:41.000Z","updated":"2018-04-09T12:52:28.843Z","comments":true,"path":"2018/04/09/easyForget/","link":"","permalink":"https://hsb786.github.io/2018/04/09/easyForget/","excerpt":"","text":"接口不可以实现接口，可以继承多个接口 抽象类可以继承具体类 static不能被重写，重写是运行时动态绑定的 static变量发生在静态解析阶段，此时已经将字段的符号引用转换成了内存引用，将它与对应的类关联在了一起 子类构造方法默认会寻找父类无参构造方法，若没有，编译不通过 抽象方法必须为public否则protected，缺省情况下默认为public java8中接口可以含有default方法和static方法 volatile 禁止指令重排序： 添加内存屏障，保证前面已经完成，后面都没开始 内部类访问外部类 外部类.this.成员XX 重载静态绑定，根据参数的静态类型而不是实际类型作为判断依据的 java的8中基本类型，除了float和double之外，其它6种都实现了常量池 boolean类型不允许进行任何类型的转换处理 java7以后，常量池被放入到堆空间中。导致Intern()函数的功能不同。intern()检查常量池时候存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用 ArrayList 默认容器 10 HashMap 16 newInstance 低效率，只能调用无参构造。将new这个方式分解为两步： 首先调用class的加载方式加载某个类，然后实例化 HashSet底层借用HashMap private static final Object PRESENT=new Object();123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 字符只有在内存中才会形成，其它都是以字节的方式进行的 强引用： Object obj=new Object()，只要引用还在，就不会被回收软引用： 内存不够才会被回收弱引用： 下一次垃圾收集器工作时会被回收。虚引用： 随时可能被回收，目的是能在这个对象被回收时收到一个系统通知 内加载器： JVM动态加载所需的类。 委托、可见、单一。交给父加载器；父加载器加载的类子加载器都能看到；一个类只能被一个加载一次 每个对象有两个队列： 就绪队列、阻塞队列 ReentrantLock结合Condition可以有选择性地进行通知，在调度上更加灵活 指令重排序： 编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段 null可以强制转换为任何java类类型其返回值还是null，可以调用static方法","categories":[],"tags":[]},{"title":"区别","slug":"distinguish","date":"2018-04-08T23:48:41.000Z","updated":"2018-04-09T12:52:24.567Z","comments":true,"path":"2018/04/09/distinguish/","link":"","permalink":"https://hsb786.github.io/2018/04/09/distinguish/","excerpt":"","text":"sleep和wait区别 sleep是Thread类的static方法； wait是Object类的方法 sleep()睡眠时保持对象锁； wait释放锁 sleep可以放在任何地方； wait()必须放在synchronized block中，否则会在runtime是扔出IllegalMonitorStateExcetion异常 synchronized和volatile区别 volatile是线程同步的轻量级实现，性能比synchronized好 volatile只能修饰变量； synchronized可修饰方法和代码块 volatile能保证数据可见性，不保证原子性； synchronized可以保证原子性，也可以间接保证可见性。synchronized会将私有内存和公共内存中的数据进行同步 volatile解决的是变量在多个线程间的可见性； synchronized解决的是多个线程访问资源的同步性 内部类 在类中定义一个类(私有内部类，静态内部类)在方法中定义一个类(局部内部类，匿名内部类) 私有内部类编译器做的手脚 在内部类中创建了包可见构造器，从而使外部类获得了创建权限 在外部类中创建了访问私有变量的静态方法，从而使内部类获得了范围权限 静态内部类只能访问其外部类的静态成员 局部内部类没有修饰符，局部内部类只能范围该方法中的局部变量，并且这些局部变量一定要是final修饰的产量或者隐含是final的(java8) 匿名内部类不能抽象；仅能被使用一次；不能存在静态成员变量和方法只有静态内部类可以访问静态成员变量 Session和Cookie的区别 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 客户端传JSESSIONID，服务端就可以通过这个ID，来将存储到服务端的数据取出 Servlet和Filter的区别 Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对响应的数据进行后处理。 强、软、弱、虚引用 强引用 Object obj=new Object()，只要引用还在，就不会被回收软引用内存不够才会被回收弱引用下一次垃圾收集器工作时会被回收。虚引用随时可能被回收，目的是能在这个对象被回收时收到一个系统通知。垃圾回收期是一个优先级较低的线程，并不一定能迅速发现弱引用对象 HashMap和Hashtable的区别 先吐槽一下Hashtable的命名，为啥t要小写 Hashtable是线程安全的； HashMap不是 Hashtable不允许有null的KV； HashMap运行 Hashtable继承Dictionary类； HashMap继承AbstractMap HashMap有一个子类LinkedHashMap，对这个类对象进行迭代时，它的顺序是有序的。可以轻易的将LinkedHashMap转换成HashMap； Hashtable不好实现 join和sleep的区别 join底层调用wait方法，执行到wait释放锁sleep在睡眠时不释放锁 JDK动态代理和CGLIB代理的区别 JDK动态动态代理是利用反射机制生存一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类 CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。 重载和重写的区别 重载： 方法有同样的名称，但是参数列表不同 重写：在java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法 区别 重载 重写 编译期概念，遵循“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法 运行期概念，遵循“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法 方法签名必须不同 方法签名必须一样 返回类型可以不同 返回类型必须相同 无限制 更好的访问，不能抛出更广泛的异常（遵循里式替换原则） 组合与继承的区别和联系 在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；) 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法） 继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。） 组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。 优缺点对比 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 如何选择 继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。&lt;&lt;java编程思想&gt;&gt; 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。&lt;&gt; Compareable和Comparator Comparable：一个实现了Comparable接口的类，可以让其自身的对象和其它对象进行比较。也就是说，同一个类的对象之间要想比较，对应的类就要实现Compareable接口，并实现compareTo()方法。 Comparator：不改变原有的类。通过定义一个类实现Comparator接口，重写compare()方法。 Comparator通常用于排序。Java中的Collectinos和Arrays都包括排序的sort方法，该方法可以接受一个Comparator的实例(比较器)来进行排序；new TreeSet&lt;&gt;(new Comparator())","categories":[],"tags":[]},{"title":"DispatchServlet","slug":"DispatchServlet","date":"2018-04-08T13:38:41.000Z","updated":"2018-04-09T12:21:51.757Z","comments":true,"path":"2018/04/08/DispatchServlet/","link":"","permalink":"https://hsb786.github.io/2018/04/08/DispatchServlet/","excerpt":"","text":"DispatcherServlet是什么它是Spring MVC的核心。每个由Spring MVC处理的请求都要经过DispatcherServlet。一般而言，它是前端控制器模式的实现，为应用提供一个统一入口。DispatcherServlet是连接Java与Spring的桥梁，处理所有传入的请求。并且与其他声明在web.xml中的Servlet一样，也是通过一个URL pattern将每个请求映射到DispatcherServlet。 DispatcherServlet负责将请求委派给Spring MVC中其他的组建处理，比如注有@Controller或@RestController的Controller类，HandlerMappers（处理映射），View Resolvers(视图解析器)等等。 尽管，请求映射是由 @ResquestMapping 注解完成的，但实际上是由 DispatcherServlet 将请求委派给相应的 Controller 来处理的。 DispatcherServlet如何处理请求正如上面所说，DispatcherServlet 被用来处理所有传入的请求，并将它们路由到不同的 Controller 来进行进一步处理。它决定了由哪个 Controller 处理请求。 DispatcherServlet 使用处理器映射来将传入的请求路由到处理器。默认情况下，使用 BeanNameUrlHandlerMapping 和 由 @RequestMapping 注解驱动的DefaultAnnotationHandlerMapping。 为了找到正确的方法来处理请求，它会扫描所有声明了 @Controller 注解的类，并且通过 @RequestMapping 注解找到负责处理该请求的方法。@RequestMapping 注解可以通过路径来映射请求(比如: @RequestMapping(“path”)), 也可以通过 HTTP 方法(比如: @RequestMapping(“path”, method=RequestMethod.GET)), 也可以通过请求参数(比如: @RequestMapping(“path””, method=RequestMethod.POST, params=”param1”)),还可以通过 HTTP 请求头(比如: @RequestMapping(“path”, header=”content-type=text/*”))。我们也可以在类级别声明 @RequestMapping 注解来过滤传入的请求。 在请求处理之后，Controller 会将逻辑视图的名字和 model 返回给 DispatcherServlet。之后利用视图解析器定位到真正的 View 以便渲染结果。我们可以指定使用的视图解析器，默认情况下，DispatcherServlet 使用 InternalResourceViewResolver来将逻辑视图的名字转换成真正的视图，比如 JSP。 选定视图之后，DispatcherServlet 会将数据模型与视图相结合，并将结果返回给客户端。并不是任何时候都需要视图，比如一个 RESTful 的 web 服务就不需要，它们的处理方法会利用 @ResponseBody 注解直接将请求结果返回给客户端。可以看REST with Spring course了解更多关于如何使用 Spring MVC 开发和测试 RESTful 服务的知识。","categories":[],"tags":[]},{"title":"hash","slug":"hash","date":"2018-04-08T13:23:41.000Z","updated":"2018-04-09T12:52:40.306Z","comments":true,"path":"2018/04/08/hash/","link":"","permalink":"https://hsb786.github.io/2018/04/08/hash/","excerpt":"","text":"哈希 Hash，一般翻译成“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值 特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同 两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞","categories":[],"tags":[]},{"title":"事务","slug":"sqlTransaction","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:26.778Z","comments":true,"path":"2018/04/08/sqlTransaction/","link":"","permalink":"https://hsb786.github.io/2018/04/08/sqlTransaction/","excerpt":"","text":"事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。在计算机术语中，事务通常就是指数据库事务。 概念 一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包括有以下两个目的 为数据库提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离的方法，以防止彼此的操作互相干扰。 当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。 但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。 特性 并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 脏读：又称无效数据的读出。指一个事务对数据进行了修改，还没有提交到数据库中，另外一个事务访问并使用了该数据。由于这个数据还没有提交，所以另外一个事务读到的这个数据是脏数据。 不可重复读：一个事务范围内对两个相同的查询却返回了不同数据。这是因为其它事务修改的提交而引起的。 幻读：指当事务不是独立执行时发生的一种现象。例如第一个事务涉及到表中全部数据行的修改，另一个事务添加了一行新数据，那么执行第一个事务后，发现表中还有没有被修改的数据行。 隔离级别 未提交读(Read uncommitted)：一个事务可以读取另一个事务未提交的数据 提交读(Read committed)：在一个事务修改数据过程中，其它事务不能读该数据 数据库锁情况 事务对当前读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。 可重复读(Repeatable reads)：解决不可重复读的问题 数据库锁情况 事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放 事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放 序列化(Serializable)：最高的隔离级别 数据库锁情况 事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放 事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放 隔离级别越高，同时在并发现上也越低 锁的分类 按锁级别划分： 共享锁(Share Lock) 又称读锁，是读取操作创建的锁。其它用户可以并发读取数据，但任何事务都不能对数据进行修改，直到已释放所有共享锁 如果事务T对数据A加上共享锁后，则其它事务只能对A再加共享锁，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据 用法 select … LOCK IN SHARE MODE， 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其它线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据 排他锁(eXclusive Lock) 又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。获取排他锁的事务既能读数据，又能修改数据 用法 select … FOR UPDATE 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞 按锁的粒度划分 行级锁 对当前操作的行进行加锁。加锁粒度最小，但加锁的开销最大。行级锁分为共享锁和排他锁 特点 开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁 特点 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 Innodb中的行锁与表锁 InnoDB行锁是通过给索引上的索引项加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 行级锁与死锁 在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。 当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。 常见的三种解决死锁的方法 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率 按使用方式划分 悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 在数据库中，悲观锁的流程如下： 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。","categories":[],"tags":[]},{"title":"SpringMVC","slug":"SpringMVC","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:23.535Z","comments":true,"path":"2018/04/08/SpringMVC/","link":"","permalink":"https://hsb786.github.io/2018/04/08/SpringMVC/","excerpt":"","text":"##SpringMVC工作流程 SpringMVC是一种基于Servelt的技术，它提供了控制器DispatchServlet和相关组件，这些SpringMVC的组件一起协调工作，完成对web请求的相应。 客户端发出一个HTTP请求，Web服务器接收到这个请求。服务器检查HTTP请求的路径，如果匹配DispatchServelt的请求映射路径(web.xml中指定)，则Web容器将该请求转交给对应的DispatchServlet处理 DispatchServlet接收到这个请求后，将根据请求的信息以及HandlerMapping配置找到处理请求的处理器（Handler）。HandlerMapping可以简单理解为统一资源标识符URL域与处理器Handler之间的关系。 找到对应的处理器之后，通过HandlerAdapter对Handler进行封装，再以同一的适配器接口调用Handler。因为为了更加灵活的编码和AOP增强功能，SpringMVC会给处理器加入拦截器，这样就可以在处理器执行前后加入执行前后加入自己的代码，于是就构成了一个处理器的执行链，所以SpringMVC提供了处理器适配器HandlerAdapter，帮助我们运行相应的处理器以及我们添加进去的拦截器。 处理器完成了请求的业务逻辑之后将返回一个ModelAndView对象给DIspatcherServlet，这里ModelAndView包含了视图的逻辑名和模型数据信息。 得到了ModelAndView之后，DispatchServlet借助ViewResolver视图解析器将逻辑试图转换为真实视图。 通过ViewResolver视图解析器得到了真实视图后，DispatServlet使用这个真实视图对象对ModelAndView中的模型数据进行渲染。 最终DispatchServlet将渲染过后的视图对象返回给请求的客户端，客户端得到的响应可能是一个普通的HTML页面，也可能是一个JSON串，甚至是一张图片等等不同的视图模型。","categories":[],"tags":[]},{"title":"Spring整理","slug":"spring","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:18.798Z","comments":true,"path":"2018/04/08/spring/","link":"","permalink":"https://hsb786.github.io/2018/04/08/spring/","excerpt":"","text":"Spring结构Spring框架的核心组件只有三个：Bean，Context，Core Spring是面向Bean编程，自然Bean组件就是Spring对Java对象Object的封装，在Spring容器中管理的就是被Bean封装了的Java对象。Bean组件解决了Bean的定义，Bean的创建以及Bean的解析。 Context组件就是我们常说的IOC容器，也就是Spring容器。Context组件可以发现每个Bean之间的关系，为它们建立好Bean之间的依赖关系，为Bean提供生存环境。 Core组件，它是Context组件与Bean组件的工具包，可以把Core组件理解为Util工具包 ##Spring容器 Spring容器有时候也称为IOC容器。IOC: Inverse of Control，控制反转。控制：控制就是调用类对某一个接口具体实现类的选择控制权反转：选择控制权交给第三方决定，由Spring容器来统一配置管理Bean。 为了更好理解IOC，大家经常使用依赖注入来代替控制反转这个概念，即让调用类对某一接口的实现类的依赖关系由第三方容器注入，以移除调用类对某一接口实现类的依赖。那么IOC容器的工作就是通过配置文件和注解来描述类和类之间的依赖关系。利用反射机制完成类的初始化和依赖注入。 ##BeanFactory和ApplicationContext BeanFactory是Spring框架核心接口，提供了IOC的配置机制，是Spring的基础设施，面向Spring本身 ApplicationContext是建立在BeanFactory之上，提供了更多的面向应用的功能，是Spring给开发者提高了IOC容器接口","categories":[],"tags":[]},{"title":"值传递和引用传递","slug":"passByValue","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:01.695Z","comments":true,"path":"2018/04/08/passByValue/","link":"","permalink":"https://hsb786.github.io/2018/04/08/passByValue/","excerpt":"","text":"值传递 指在调用函数时将实际参数复制一份传递到函数中，那么在函数中对参数所进行的修改，将不会影响到实际参数。 引用传递 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 求值策略 求值时间 求值方式 根本区别 值传递 调用前 值的结果（原值的副本） 会创建副本 引用传递 调用前 原值（原始对象，无副本） 不创建副本 值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份到形参 java只有值传递，不存在引用传递 java在传递引用类型数据时，把实际参数的内存地址复制了一份，传递给了形参","categories":[],"tags":[]},{"title":"防止重复发送 Ajax 请求的解决方案","slug":"preventDupAjax","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:08.971Z","comments":true,"path":"2018/04/08/preventDupAjax/","link":"","permalink":"https://hsb786.github.io/2018/04/08/preventDupAjax/","excerpt":"","text":"连续点击多个按钮，可能导致先请求的数据后显示出来。 解决方案 1. 将ajsx请求的async设置为false 2. 利用jquery ajaxPrefilter中断请求12345678910111213141516171819var pendingRequests = &#123;&#125;;$.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if ($.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;;&#125;); 核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清楚，这就保证了在任一时刻只能有一个同样的请求发送 局限性：仅对jquery的ajax有作用","categories":[],"tags":[]},{"title":"一些小技巧","slug":"skills","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-09T12:53:13.420Z","comments":true,"path":"2018/04/08/skills/","link":"","permalink":"https://hsb786.github.io/2018/04/08/skills/","excerpt":"","text":"位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快 X % 2^n = X &amp; (2^n-1) 判段一个数组是否包含某个值12Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(arr)); return set.contains(targetValue); 效率慢，要将数组压入Collection类型中，首先要将数组元素便利一遍，然后再使用集合类做其它操作。 可以使用Apache Commons类库中提供的ArrayUtils类的contains方法contains内部调用indexOf方法","categories":[],"tags":[]},{"title":"Java虚拟机是如何执行线程同步的","slug":"performsSyn","date":"2018-04-08T09:48:41.000Z","updated":"2018-04-09T12:53:05.276Z","comments":true,"path":"2018/04/08/performsSyn/","link":"","permalink":"https://hsb786.github.io/2018/04/08/performsSyn/","excerpt":"","text":"线程和共享数据 在JVM中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其它线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。 在JVM中，堆内存是所有线程共享的。对象在堆中。 还有一部分数据保存JVM中的方法区中，比如类的静态变量。方法去和栈类似，其中只包含基本类型和对象引用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。 对象和类的锁 JMM中有两块区域可以被所有线程共享 堆，存放着所有对象方法区，存放着静态变量 那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果 为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。但线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其它申请锁的线程。 类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个java.lang.Class对象，当你锁住一个类的时候，其实锁住的是其对应的Class对象 监视器（Monitors） 锁其实是通过监视器实现的，监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。 每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，它是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。 当线程离开代码块时，无论如何离开，都会释放所关联对象的锁 多次加锁 同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁喉，该计数器自增变为1，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其它线程便可以获得锁。 同步 在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。","categories":[],"tags":[]},{"title":"lombok","slug":"lombok","date":"2018-04-08T08:23:41.000Z","updated":"2018-04-09T12:52:45.148Z","comments":true,"path":"2018/04/08/lombok/","link":"","permalink":"https://hsb786.github.io/2018/04/08/lombok/","excerpt":"","text":"通过使用@Data注解自动帮你生成getters,setters,toString(),equals(),hashCode()方法 @AllArgsConstructor 全参构造函数 @NoArgsConstructor 无参构造函数","categories":[],"tags":[]},{"title":"NaN","slug":"NaN","date":"2018-04-08T08:07:41.000Z","updated":"2018-04-09T12:52:52.999Z","comments":true,"path":"2018/04/08/NaN/","link":"","permalink":"https://hsb786.github.io/2018/04/08/NaN/","excerpt":"","text":"NaN表示未定义或不可表示的指 A constant holding a Not-a-Number (NaN) value of type public static final double NaN = 0.0d /0.0; Java中的Double和Float都有isNaN。判断一个数是不是NaN，通过v!=v的方式。 NaN是唯一与自己不相等的指，NaN与任何值都不相等。","categories":[],"tags":[]},{"title":"VSCode快捷键","slug":"VSCodeQuickKey","date":"2018-04-08T07:58:41.000Z","updated":"2018-04-09T12:23:11.149Z","comments":true,"path":"2018/04/08/VSCodeQuickKey/","link":"","permalink":"https://hsb786.github.io/2018/04/08/VSCodeQuickKey/","excerpt":"","text":"ctrl B 侧边栏显/隐ctrl shift E 资源管理器ctrl tab 文件切换F1或ctrl shift p 命令窗口","categories":[],"tags":[]},{"title":"git命令","slug":"gitCommand","date":"2018-04-08T07:42:41.000Z","updated":"2018-04-09T12:23:19.690Z","comments":true,"path":"2018/04/08/gitCommand/","link":"","permalink":"https://hsb786.github.io/2018/04/08/gitCommand/","excerpt":"","text":"git命令","categories":[],"tags":[]},{"title":"markdown","slug":"markdown","date":"2018-04-08T04:31:41.000Z","updated":"2018-04-09T12:16:49.290Z","comments":true,"path":"2018/04/08/markdown/","link":"","permalink":"https://hsb786.github.io/2018/04/08/markdown/","excerpt":"","text":"Markdown结合VSCode来使用斜体删除线 分割 baidu 引用 演示列表 列表还可以有层级 第一章1.1节有序列表 wfe fwef 表格 header1 header 2 row 1 col 1 哈哈 换行 row 2 col 1 哈哈 我的邮箱：&#x37;&#56;&#54;&#51;&#x39;&#x38;&#55;&#x39;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109; 1代码块","categories":[],"tags":[]}]}