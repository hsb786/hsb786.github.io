{"meta":{"title":"HuShengBin’s blog","subtitle":"码渣的个人博客","description":"记录码渣的奋斗史","author":"HuShengBin","url":"https://hsb786.github.io"},"pages":[{"title":"关于我","date":"2018-04-09T10:17:26.000Z","updated":"2018-04-15T05:30:22.117Z","comments":true,"path":"about/index.html","permalink":"https://hsb786.github.io/about/index.html","excerpt":"","text":"1995 天枰座，身高不高 码渣一枚，喜欢敲代码，可惜太笨 常年混迹在知乎、豆瓣、网易云，想做个文艺青年，可惜没那个气质 对科技非常感兴趣，可惜穷 联系方式：786398798@qq.com"},{"title":"categories","date":"2018-04-09T10:17:26.000Z","updated":"2018-04-09T10:17:26.909Z","comments":true,"path":"categories/index.html","permalink":"https://hsb786.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-09T10:16:56.000Z","updated":"2018-04-10T09:27:51.546Z","comments":true,"path":"tags/index.html","permalink":"https://hsb786.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"javap","slug":"javap","date":"2018-04-15T11:11:13.000Z","updated":"2018-04-15T11:48:20.538Z","comments":true,"path":"2018/04/15/javap/","link":"","permalink":"https://hsb786.github.io/2018/04/15/javap/","excerpt":"javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件","text":"javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件 1234567891011public class T01 &#123; private volatile int n; public void add() &#123; n++; &#125; private void sub() &#123; n--; &#125;&#125; javap T01 输出T01的public域及方法 javap -c T01 列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用 javap -p T01 输出所有类和成员 javap -v T01 输出栈大小，方法参数的个数 语法12345678910-help 帮助-l 输出行和变量的表-public 只输出public方法和域-protected 只输出public和protected类和成员-package 只输出包，public和protected类和成员，这是默认的-p -private 输出所有类和成员-s 输出内部类型签名-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，-verbose 输出栈大小，方法参数的个数-constants 输出静态final常量 编译版本 major version java版本 46 2 47 3 48 4 49 5 50 6 51 7 52 8","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-04-14T08:14:06.000Z","updated":"2018-04-14T11:25:27.473Z","comments":true,"path":"2018/04/14/Proxy/","link":"","permalink":"https://hsb786.github.io/2018/04/14/Proxy/","excerpt":"JDK动态代理通过java.lang.reflect.Proxy类以及java.lang.reflect.InvocationHandler接口来实现动态代理 InvocationHandlerInvocationHandler接口的唯一方法： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy: 代理类实例 method: 方法 args: 方法入参","text":"JDK动态代理通过java.lang.reflect.Proxy类以及java.lang.reflect.InvocationHandler接口来实现动态代理 InvocationHandlerInvocationHandler接口的唯一方法： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy: 代理类实例 method: 方法 args: 方法入参 Proxypublic static Object newProxyInstance Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) loader： ClassLoader，定义由哪个ClassLoader对象类对生成的代理对象进行加载 interfaces：该实现类的所有接口 h：调用处理程序，表示当这个动态代理对象在调用方法时，会关联到哪一个InvocationHandler对象上 123public interface Hello &#123; void say(String name);&#125; 定义被代理的接口 12345678public class HelloImpl implements Hello &#123; @Override public void say(String name) &#123; System.out.println(&quot;Hello &quot; + name); &#125;&#125; 接口的实现类 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。 * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。 * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。 */public class DynamicProxy implements InvocationHandler &#123; //目标对象，被代理接口的实现类 private Object target; public DynamicProxy(Object target) &#123; this.target = target; &#125; /** * @param proxy 代理类实例 * @param method 方法 * @param args 方法入参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; /** * @Description: 获取代理对象 */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; private void before() &#123; System.out.println(&quot;Before&quot;); &#125; private void after() &#123; System.out.println(&quot;After&quot;); &#125;&#125; 执行程序12345678910111213public class ClientProxy &#123; public static void main(String[] args) &#123; Hello hello = new HelloImpl(); DynamicProxy dynamicProxy = new DynamicProxy(hello); Hello helloProxy = dynamicProxy.getProxy(); helloProxy.say(&quot;hh&quot;); &#125;&#125;//output: Before Hello hh After 用DynamicProxy类去包装HelloImpl实例，然后再调用Proxy类的工厂方法newProxyInstance()去动态地创建一个Hello接口的代理类，调用这个代理类的say()方法。 被代理方法的调用都是通过InvocationHadler的invoke来实现的。 Proxy.newProxyInstance这个方法的第二个参数，我们给这个代理对象提供了一组什么接口，那么这个代理对象就会实现了这组接口，这个时候我们可以将这个代理对象强制转化为这组接口中的任意一个。 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 动态代理，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，代理类也要变。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有用武之地了！ 总结 通过实现InvocationHandler接口来自定义自己的InvocationHandler；在实现的过程中，通过传入目标对象（被代理的对象）来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。 通过Proxy.newProxyInstance来动态创建代理类 通过代理对象调用目标方法，实际上是通过InvocationHandler实现类的invoke()方法调用 能否代理没有接口的类? CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。 CGLIB动态代理Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。 1234567891011121314151617181920212223public class CGLibProxy implements MethodInterceptor &#123; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123; return (T) Enhancer.create(cls, this); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); Object result = proxy.invokeSuper(obj, args); after(); return result; &#125; private void before() &#123; System.out.println(&quot;Before&quot;); &#125; private void after() &#123; System.out.println(&quot;After&quot;); &#125;&#125; 需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。 与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧： 123CGLibProxy cgLibProxy = new CGLibProxy();HelloImpl helloProxy2 = cgLibProxy.getProxy(HelloImpl.class);helloProxy2.say(&quot;cg&quot;); 与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象 JDK动态代理和CGLIB代理生成的区别 JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。 CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。 在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。 参考 Proxy 那点事儿 动态代理 java的动态代理机制详解","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"ThreadLocal","slug":"ThreadLocal","date":"2018-04-14T07:06:57.000Z","updated":"2018-04-14T07:55:17.544Z","comments":true,"path":"2018/04/14/ThreadLocal/","link":"","permalink":"https://hsb786.github.io/2018/04/14/ThreadLocal/","excerpt":"早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。","text":"早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。 ThreadLocal常用方法： public void set(T value)：将值放入线程局部变量中 public T get()：从线程局部变量中获取值 public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收） protected T initialValue()：返回线程局部变量中的初始值（默认为 null） 为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。 ThreadLocal简单实现1234567891011121314151617181920212223242526public class MyThreadLocal&lt;T&gt; &#123; private Map&lt;Thread, T&gt; container = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;()); public void set(T value) &#123; container.put(Thread.currentThread(), value); &#125; public T get() &#123; Thread thread = Thread.currentThread(); T value = container.get(thread); if (value == null &amp;&amp; !container.containsKey(thread)) &#123; value = initialValue(); container.put(thread, value); &#125; return value; &#125; public void remove() &#123; container.remove(Thread.currentThread()); &#125; protected T initialValue() &#123; return null; &#125;&#125; ThreadLocal 具体有哪些使用案例呢？通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。(每个线程应该拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接) 注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！ 参考 ThreadLocal 那点事儿","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"IOC-实现原理（转载）","slug":"IOC-实现原理（转载）","date":"2018-04-14T05:22:40.000Z","updated":"2018-04-14T07:54:10.280Z","comments":true,"path":"2018/04/14/IOC-实现原理（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/14/IOC-实现原理（转载）/","excerpt":"本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部 IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。","text":"本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部 IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。从实例出发，先看看以下 Action 代码。 123456789101112131415161718@Beanpublic class ProductAction extends BaseAction &#123; @Inject private ProductService productService; @Request(&quot;GET:/product/&#123;id&#125;&quot;) public Result getProductById(long productId) &#123; if (productId == 0) &#123; return new Result(ERROR_PARAM); &#125; Product product = productService.getProduct(productId); if (product != null) &#123; return new Result(OK, product); &#125; else &#123; return new Result(ERROR_DATA); &#125; &#125;&#125; 以上使用了两个自定义注解：@Bean 与 @Inject。在 ProductAction 类上标注了 @Bean 注解，表示该类会交给“容器”处理，以便加入依赖注入框架。 在 produceService 字段上标注了 @Inject 注解，表示该字段将会被注入进来，而无需 new ProductServiceImpl()，实际上 new 这件事情不是我们做的，而是框架做的，也就是说控制权正好反过来了，所以“依赖注入（DI）”也称作“控制反转（IoC）”。 那么，应该如何实现依赖注入框架呢？首先还是看看下面的 BeanHelper 类吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BeanHelper &#123; private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); static &#123; try &#123; // 获取并遍历所有的 Bean（带有 @Bean 注解的类） List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class); for (Class&lt;?&gt; beanClass : beanClassList) &#123; // 创建 Bean 实例 Object beanInstance = beanClass.newInstance(); // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例） beanMap.put(beanClass, beanInstance); &#125; // 遍历 Bean Map for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123; // 获取 Bean 类与 Bean 实例 Class&lt;?&gt; beanClass = beanEntry.getKey(); Object beanInstance = beanEntry.getValue(); // 获取 Bean 类中所有的字段（不包括父类中的方法） Field[] beanFields = beanClass.getDeclaredFields(); if (ArrayUtil.isNotEmpty(beanFields)) &#123; // 遍历所有的 Bean 字段 for (Field beanField : beanFields) &#123; // 判断当前 Bean 字段是否带有 @Inject 注解 if (beanField.isAnnotationPresent(Inject.class)) &#123; // 获取 Bean 字段对应的接口 Class&lt;?&gt; interfaceClass = beanField.getType(); // 获取该接口所有的实现类 List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass); if (CollectionUtil.isNotEmpty(implementClassList)) &#123; // 获取第一个实现类 Class&lt;?&gt; implementClass = implementClassList.get(0); // 从 Bean Map 中获取该实现类对应的实现类实例 Object implementInstance = beanMap.get(implementClass); // 设置该 Bean 字段的值 beanField.setAccessible(true); // 必须使该字段可访问 beanField.set(beanInstance, implementInstance); &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123; return beanMap; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123; return (T) beanMap.get(cls); &#125;&#125; 其实很简单，依赖注入其实分为两个步骤：1. 通过反射创建实例；2. 获取需要注入的接口实现类并将其赋值给该接口。以上代码中的两个 for 循环就是干这两件事情的。 依赖注入框架实现完毕！ 大家上面看到的 BeanHelper 类，其实兼任了两种职责：1.初始化所有的 Bean 类；2.实现依赖注入。 这违法了设计模式中的“单一责任原则”，所有有必要将其重构一下，现在的 BeanHelper 类更加苗条了，只是负责初始化 Bean 类而已。代码如下： 1234567891011121314151617181920212223242526272829public class BeanHelper &#123; // Bean 类 =&gt; Bean 实例 private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); static &#123; try &#123; // 获取并遍历所有的 Bean（带有 @Bean 注解的类） List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class); for (Class&lt;?&gt; beanClass : beanClassList) &#123; // 创建 Bean 实例 Object beanInstance = beanClass.newInstance(); // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例） beanMap.put(beanClass, beanInstance); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123; return beanMap; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123; return (T) beanMap.get(cls); &#125;&#125; 那么，依赖注入功能放哪里呢？我搞了一个 IOCHelper，用这个类来实现 IOC 功能。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class IOCHelper &#123; static &#123; try &#123; // 获取并遍历所有的 Bean 类 Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123; // 获取 Bean 类与 Bean 实例 Class&lt;?&gt; beanClass = beanEntry.getKey(); Object beanInstance = beanEntry.getValue(); // 获取 Bean 类中所有的字段（不包括父类中的方法） Field[] beanFields = beanClass.getDeclaredFields(); if (ArrayUtil.isNotEmpty(beanFields)) &#123; // 遍历所有的 Bean 字段 for (Field beanField : beanFields) &#123; // 判断当前 Bean 字段是否带有 @Inject 注解 if (beanField.isAnnotationPresent(Inject.class)) &#123; // 获取 Bean 字段对应的接口 Class&lt;?&gt; interfaceClass = beanField.getType(); // 判断接口上是否标注了 @Impl 注解 Class&lt;?&gt; implementClass = null; if (interfaceClass.isAnnotationPresent(Impl.class)) &#123; // 获取强制指定的实现类 implementClass = interfaceClass.getAnnotation(Impl.class).value(); &#125; else &#123; // 获取该接口所有的实现类 List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass); if (CollectionUtil.isNotEmpty(implementClassList)) &#123; // 获取第一个实现类 implementClass = implementClassList.get(0); &#125; &#125; // 若存在实现类，则执行以下代码 if (implementClass != null) &#123; // 从 Bean Map 中获取该实现类对应的实现类实例 Object implementInstance = beanMap.get(implementClass); // 设置该 Bean 字段的值 if (implementInstance != null) &#123; beanField.setAccessible(true); // 取消类型安全检测（可提高反射性能） beanField.set(beanInstance, implementInstance); // beanInstance 是普通实例，或 CGLib 动态代理实例（不能使 JDK 动态代理实例） &#125; &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可见，IOCHelper 是依赖于 BeanHelper 的。这样分离，还有一个好处，就是方便实现 ServiceHelper 与 AOPHelper。也就是说，首先通过 BeanHelper 初始化所有的 Bean 类，然后依次初始化 ServiceHelper、IOCHelper、AOPHelper，这个顺序不能搞错。因为在 ServcieHelper 中，对 Servcie 实现类进行了动态代理，所有保证了 IOC 注入进来的是代理类，而并非目标类。 参考 IOC 实现原理 1000行代码读懂Spring（一）- 实现一个基本的IoC容器","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"Servlet（转载）","slug":"Servlet（转载）","date":"2018-04-14T04:35:27.000Z","updated":"2018-04-14T05:14:16.072Z","comments":true,"path":"2018/04/14/Servlet（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/14/Servlet（转载）/","excerpt":"Servlet概述Servlet是在Java中创建web应用程序的J2ee 服务端技术。javax.servlet 和 javax.servlet.http包中提供了编写servlet的接口和类。 所有的servlet都要实现javax.servlet.Servlet接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的GenericServlet类。HttpServlet类中提供了用于处理http请求的doGet()和 doPost()等方法。","text":"Servlet概述Servlet是在Java中创建web应用程序的J2ee 服务端技术。javax.servlet 和 javax.servlet.http包中提供了编写servlet的接口和类。 所有的servlet都要实现javax.servlet.Servlet接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的GenericServlet类。HttpServlet类中提供了用于处理http请求的doGet()和 doPost()等方法。多数情况下，web应用程序都使用http协议，所以，我们多数时候都通过继承HttpServlet类来实现自己的Servlet。 Servlet API的层次结构javax.servlet.Servlet是Servlet Api的最上层接口。还有一些其他的接口和类是我们在使用servlet的时候需要关注的。在Servlet 3.0规范中，建议使用的注解我们也需要了解。 Servlet 接口javax.servlet.Servlet 是Servlet Api的最上层接口，Servlet接口定义了一系列servlet的生命周期方法（init、service、destory等）。所有的Servlet类都需要继承这个接口。该接口中定义了以下方法： public abstract void init(ServletConfig paramServletConfig) throws ServletException – 该方法由servlet容器调用，用于初始化servlet以及servlet配置参数。在init()方法执行之前，servlet是无法处理用户请求的。在servlet生命周期中该方法只会被调用一次，他会使servlet类不同区别于普通的java对象。我们可以扩展该方法来初始化资源，如数据库连接、socket连接等。 public abstract ServletConfig getServletConfig() – 该方法返回一个servlet配置对象，其中包含servlet中所有初始化参数和启动配置。我们可以用这个方法来获取servlet的初始化参数，这些参数一般被定义在web.xml或servlet 3的注解中。后面会介绍ServletConfig接口。 public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException – 该方法负责处理客户端请求。当servlet容器收到客户端请求时，它会创建一个新线程并执行service()方法，并把request 和 response作为参数传递给该方法。servlet通常运行在多线程环境中，所以开发人员应该使用同步来保证访问共享资源的线程安全性问题。 public abstract String getServletInfo() – 这个方法返回包含servlet信息的字符串，比如它的作者、版本和版权。返回的字符串应该是纯文本，不能有标记符号。 public abstract void destroy() – 这个方法在整个servlet生命周期中只会被调用一次来关闭所有资源。有点像Java中的finalize方法。 ServletConfig 接口javax.servlet.ServletConfig用于给servlet传递配置信息（译者注：描述Servlet本身的相关配置信息）。每个servlet都有属于它自己的ServletConfig对象，该对象由servlet容器负责实例化。可以在web.xml中提供初始化参数，当然在servlet3.0中可以使用注解。我们可以使用getServletConfig()方法来获取ServletConfig的对象。 ServletConfig接口中主要方法： public abstract ServletContext getServletContext() – 该方法返回servlet的ServletContext对象。在下一节中我们将介绍ServletContext接口。 public abstract Enumeration getInitParameterNames() – 该方法返回servlet中所有初始化参数的名字的枚举。如果没有初始化参数定义，该方法将返回空枚举。 public abstract String getInitParameter(String paramString) – 这种方法可以通过名字来获取特定的初始化参数值。如果参数的名称不存在，则返回null。 ServletContext 接口javax.servlet.ServletContext接口用于描述应用程序的相关信息。ServletContext是一个独立的对象，可用于web应用程序中所有的servlet。当我们想要一些初始化的参数可用于web应用程序中多个或全部servlet时，我们可以使用ServletContext对象并且在web.xml中使用&lt; context-param&gt;标签定义参数。我们可以通过ServletConfig 中的 getServletContext()方法得到ServletContext对象。 ServletContext接口中的主要方法： public abstract ServletContext getContext(String uripath) – 这个方法返回指定的uripath的ServletContext对象，如果uripath不可用或不可见则返回null。 public abstract URL getResource(String path) throws MalformedURLException – 返回的一个代表某个资源的URL对象。资源可以是本地文件系统、远程文件系统、数据库，甚至是不知道如何获取资源的具体细节的远程网络站点。 public abstract InputStream getResourceAsStream(String path) – 这个方法返回给定的资源路径的一个输入流对象。如果没有找到返回null。 public abstract RequestDispatcher getRequestDispatcher(String urlpath) – 这个方法一般被用于获得对于另外一个servlet的引用。获取到RequestDispatcher对象之后，就可以通过他把一个请求转发出去(forward或者include)。 public abstract void log(String msg) – 该方法用于把指定的消息字符串写入servlet日志文件中。 public abstract Object getAttribute(String name) – 按照指定的name返回对象属性。可以使用public abstract Enumeration getAttributeNames()活的所有对象属性的枚举。 public abstract void setAttribute(String paramString, Object paramObject) – 该方法用于在应用的范围内设置属性。该属性可以被可以访问当前ServletContext的所有servle获取到。可以使用public abstract void removeAttribute(String paramString)删除一个属性。 String getInitParameter(String name) – 该方法用于返回在web.xml中定义的初始化参数的值。如果指定的name在web.xml中并没有匹配到，则返回null。可以使用Enumeration getInitParameterNames()得到所有初始化参数的名称的枚举。 boolean setInitParameter(String paramString1, String paramString2) – 可以使用该方法设置应用中的初始化参数。 ServletRequest 接口ServletRequest接口是用来向servlet提供客户端请求信息。每一个客户端请求到达Servlet容器的时候，他都会创建一个ServletRequest对象，并将其传递对应的servlet的service()方法。 ServletRequest接口中的主要方法： Object getAttribute(String name) – 返回指定的参数名对应的属性值。如果对应的参数不存在则返回null。我们可以使用getAttributeNames()方法来获取请求中的所有属性名称的枚举。接口中同样提供了设置值和删除值的方法。 String getParameter(String name) – 以字符串的形式返回请求参数值。我们可以使用getParameterNames()方法来获取请求参数名称的枚举。 String getServerName() – 返回服务器的主机名 int getServerPort() – 返回服务器监听的端口号。 ServletRequest的子接口HttpServletRequest中还包含了一些和session、cookies等相关的方法。 译者注：该接口中提供了getAttribute和getParameter两个方法，都是用于获取参数（属性）值的，那么这两个方法有什么区别呢？或者说Attribute和Parameter的区别是什么呢？ 答： 来源不同 参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的； 属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的. 操作不同 参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取； 属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute() 数据类型不同 参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。 属性（attribute）的值可以是任意一个Object类型。 ServletResponse 接口servlet使用ServletResponse向客户端发送响应。和每ServletRequest类似，一个客户端请求到达Servlet容器的时候，他都会创建一个ServletResponse对象，并将其传递对应的servlet的service()方法。最终，该response对象用于给客户端生成html响应。 ServletResponse接口中的主要方法： void addCookie(Cookie cookie) – 向响应中添加cookie void addHeader(String name, String value)– 设置响应头 String encodeURL(java.lang.String url) – 通过重写Url的方式支持session，在Url中增加sessionId，如果不需要重写，直接返回该url String getHeader(String name) – 返回指定的头信息。 void sendRedirect(String location)–重定向到指定的地址 void setStatus(int sc) – 设置响应的状态码 RequestDispatcher 接口RequestDispatcher 接口用于把一个请求转发给同一个servlet上下文中的其他的资源（Html、jsp、servlet）来处理。也可以用它来把另一个资源的内容包含到响应中。此接口用于同一个servlet上下文中的servlet相互沟通。 RequestDispatcher 接口的主要方法： void forward(ServletRequest request, ServletResponse response) – 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。 void include(ServletRequest request, ServletResponse response) – 把另一个资源的内容包含到当前响应中。 译者注：forward和include的区别： 如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。 用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。 在servlet中可以使用getRequestDispatcher(String path)来获取一个RequestDispatcher。路径必须以/开头，并且是针对于当前context的根路径的相对地址。 GenericServlet 类GenericServlet是一个实现类Servlet, ServletConfig 和 Serializable 的抽象类。他提供了Servlet生命周期中的主要方法以及ServletConfig中的方法的默认实现。当我们定义自己的servlet的时候，只要继承了该方法，我们只需要重写我们关注的方法就可以了，其他的不关注的方法都可以使用其默认实现。该类中定义的大部分方法都是让用户更放方便的使用Servlet和ServletConfig接口中定义的常用方法。 GenericServlet 类中有一个重要的方法——无参数的init方法。如果我们必须在处理请求之前初始化一些资源，那么可以重写该方法。 HTTPServlet 类HTTPServlet 类是GenericServlet类的子类，主要为基于HTTP创建的web应用程序提供了一些支持。其中定义了一些可重写HTTP方法。 doGet(), 用于处理get请求 doPost(), 用于处理post请求 doPut(), 用于处理put请求 doDelete(), 用于处理delete请求 Servlets属性（Attributes）Servlet属性用于servlet之间的沟通，可以在web应用程序中设置、获取甚至删除属性值。servlet属性有三种范围：request、session、application ServletRequest， HttpSession 和 ServletContext接口为request、session和application范围提供了get/set/remove的方法。 Servlet 3中的注解在servlet 3之前，所以的servlet映射和初始化参数都是定义在web.xml文件中的，随着应用中的servlet数量增多，这种方式就很难维护。 servlet 3中使用支持使用java注解来定义servlet、filter、listener以及初始化参数。 servlet 3 中主要的注解： WebServlet – 可以在servlet类中使用该注解来定义初始化参数、loadOnStartup的值、description信息和url匹配模式(pattern)等。该注解的属性中 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存。该注释声明的类必须继承HttpServlet。 WebInitParam – 该注解用于给servlet 或者 filter定义初始化参数（包括name,value和description）。可以在 WebFilter 或者 WebServlet中使用该注解。 WebFilter – 该注解用于声明一个servlet过滤器。使用该注解声明的类必须实现javax.servlet.Filter接口。 WebListener – 该注解用于声明一个事件监听器。 参考 [译]Java Servlet初级知识","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"【译】如何重置一个ArrayList--clear vs removeAll （转载）","slug":"译-如何重置一个ArrayList-clear-vs-removeAll","date":"2018-04-13T07:55:17.000Z","updated":"2018-04-13T08:01:13.361Z","comments":true,"path":"2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/","link":"","permalink":"https://hsb786.github.io/2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/","excerpt":"很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置clear或removeAll。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现java.lang.OutOfMemoryError: Java Heap Space。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。","text":"很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置clear或removeAll。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现java.lang.OutOfMemoryError: Java Heap Space。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。 Clear() vs RemoveAll(Collection c)为了更好的比较这两个方法，阅读他们源码是很重要的。可以在java.utils.ArrayList类中找到clear()方法，不过为了方便我将它引入到了这里。下面的代码来自JDK 1.7.0_40版本。如果你想要学习更多的有关性能监控和调优的知识，我强烈建议阅读Scott Oaks写的Java Performance the Definitive Guide,它包含了java 7和一点java 8。下面是clear()的代码片段: 12345678910/** * Removes all of the elements from this list.The list will * be empty after this call returns. */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 大家可以看出，clear()在循环遍历ArrayList，并且将每一个元素都置为null，使它们在没有被外部引用的情况下可以被垃圾回收。相似的，我们可以在java.util.AbstractCollection类中查看removeAll(Collention c)的代码，下面是代码片段: 12345678910111213public boolean removeAll(Collection&lt;?&gt; c) &#123; //判断对象是否为null Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified; &#125; 这个方法会检查迭代器顺序返回的每个元素是否包含在特定的集合中。如果存在，调用迭代器的remove方法将它从集合中移除。因为会用到contains方法，removeAll的复杂度是O(n^2)。所以在想要重置一个大的ArrayList时，这种方法是绝对不可取的。下面我们比较一下两者在重置一个包含100K个元素时的性能差异。 删除一个包含100k个元素的列表中的所有元素 我本来想在例子中尝试重置一个包含10M个元素的列表，不过在超过半个小时等待removeAll()结束后，我决定将元素的数量降为100K。在这种情况下，两个方法的差距也是很明显的。removeAll()比clear()多花费了10000倍的时间。事实上，在API中clear()和removeAll(Collection c)这两个方法的目的是不同的。clear()方法是为了通过删除所有元素而重置列表，而removeAll(Collection c)是为了从集合中删除某些存在于另一个提供的集合中的元素，并不是为了从集合中移除所有元素。所以如果你的目的是删除所有元素，用clear(),如果你的目的是删除某些存在于另一集合的元素，那么选择removeAll(Collection c)方法。 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList; /** * Java Program to remove all elements from list in Java and comparing * performance of clearn() and removeAll() method. * * @author Javin Paul */ public class ArrayListResetTest &#123; private static final int SIZE = 100_000; public static void main(String args[]) &#123; // Two ArrayList for clear and removeAll ArrayList numbers = new ArrayList(SIZE); ArrayList integers = new ArrayList(SIZE); // Initialize ArrayList with 10M integers for (int i = 0; i &amp;lt; SIZE; i++) &#123; numbers.add(new Integer(i)); integers.add(new Integer(i)); &#125; // Empty ArrayList using clear method long startTime = System.nanoTime(); numbers.clear(); long elapsed = System.nanoTime() - startTime; System.out.println(&quot;Time taken by clear to empty ArrayList of 1M elements (ns): &quot; + elapsed); // Reset ArrayList using removeAll method startTime = System.nanoTime(); integers.removeAll(integers); long time = System.nanoTime() - startTime; System.out.println(&quot;Time taken by removeAll to reset ArrayList of 1M elements (ns): &quot; + time); &#125; &#125; Output: Time taken by clear to empty ArrayList of 100000 elements (ns): 889619 Time taken by removeAll to reset ArrayList of 100000 elements (ns): 36633112126 由于程序使用了两个arrayList存储Integers，所以在运行时要确保有足够的内存，尤其是你想比较在列表存有1M个元素时，两种方法的性能差异。另外，由于使用了在数字中加入下划线的特性，所以需要java7来运行。如果没有JDK7，也可以移除SIZE常量中的下划线。 参考 【译】如何重置一个ArrayList–clear vs removeAll","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"【译】以生产者消费者为例阐述如何使用wait，notify和notifyAll （转载）","slug":"译-以生产者消费者为例阐述如何使用wait，notify和notifyAll","date":"2018-04-13T07:34:36.000Z","updated":"2018-04-13T07:49:23.236Z","comments":true,"path":"2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/","link":"","permalink":"https://hsb786.github.io/2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/","excerpt":"在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:Producer(生产者)和Consumer(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。","text":"在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:Producer(生产者)和Consumer(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。 在代码中展示如何使用wait和notify尽管wait和notify是相当基础的概念，并且他们定义在Object类中，但要想在代码中使用他们并非易事。你可以在面试中让面试者通过手写代码解决Producer者和Consumer者问题来验证，我相信大多数人都会犯在错误的地方同步，没有在正确的对象上调用wait之类的错。讲真，这些常常会困惑许多程序员。第一个困惑点来自怎样调用wait方法，因为wait方法并不是定义在Thread类中，所以不能简单的Thread.wait()。而许多Java开发者习惯于Thread.sleep(),所以常常错误的想用同样的方式调用wait。实际上，wait()方法需要在一个被两个线程共享的对象上调用，例如在Producer者和消费Consumer的问题中，两个线程共享对象是一个队列。第二个困惑点来自wait方法应该在同步块还是同步方法中调用？如果使用同步块，那么哪个对象应该放到同步块中？这个对象和你想要获得锁的对象应该是同一个。在我们的例子中，这个对象就是两个线程共享的队列。 在循环中使用wait和notify，而不是If代码块中在你已经了解需要在一个共享的对象上调用wait方法后，接下来就是学会避免许多java开发者犯的错—在If代码块中调用wait而不是while循环中。因为需要在一定的条件下调用wait，比如Producer线程要在队列满了的情况下调用wait，所以第一反应都是使用If语句。但是，在If代码块中调用wait会产生bug，因为线程存在一定的可能在等待条件没有改变的情况下假唤醒(spurious wake up)。所以如果没有使用循环在线程唤醒后检查等待条件，可能会造成尝试在已经满了的队列中插入元素或者在空了的队列中取元素。这就是为什么我们要在while循环中调用wait而不是if。 Java中使用wait(),notify(),notifyAll()的例子下面是在Java中使用wait(),notify(),notifyAll()的例子。在这个程序中，有两个线程(PRODUCTOR和CONSUMER)，用继承了Thread类的Producer和Consumer类实现。Prodcuer和Consumer的业务逻辑写在他们各自的run()方法中。并且实现一个LinkedList，当做共享队列。Producer在一个死循环中不断在队列中插入随机数，直到队列满了。我们会检查while(queue.size == maxSize),需要注意的是在检查之前需要给队列加上同步锁以保证在检查时没有另一个线程修改队列。如果队列满了，PRODUCER线程就会休眠，直到CONSUMER消费了队列中的元素并且调用notify()方法通知PRODUCER线程。wait和notify都是在共享的对象(我们的例子中是队列)上调用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.LinkedList;import java.util.Queue;import java.util.Random;/** * Simple Java program to demonstrate How to use wait, notify and notifyAll() * method in Java by solving producer consumer problem. * * @author Javin Paul */public class MultipleThread &#123; public static void main(String args[]) &#123; System.out.println(&quot;How to use wait and notify method in Java&quot;); System.out.println(&quot;Solving Producer Consumper Problem&quot;); Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;(); int maxSize = 10; Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;); Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;); producer.start(); consumer.start(); &#125;&#125;/** * Producer Thread will keep producing values for Consumer * to consumer. It will use wait() method when Queue is full * and use notify() method to send notification to Consumer * Thread. * @author WINDOWS 8 * */class Producer extends Thread &#123; private Queue&lt;Integer&gt; queue; private int maxSize; public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name) &#123; super(name); this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.size() == maxSize) &#123; try &#123; System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;); queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; Random random = new Random(); int i = random.nextInt(); System.out.println(&quot;Producing value : &quot; + i); queue.add(i); queue.notifyAll(); &#125; &#125; &#125;&#125;/** * Consumer Thread will consumer values form shared queue. * It will also use wait() method to wait if queue is * empty. It will also use notify method to send * notification to producer thread after consuming values * from queue. * @author WINDOWS 8 **/class Consumer extends Thread &#123; private Queue&lt;Integer&gt; queue; private int maxSize; public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123; super(name); this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.isEmpty()) &#123; System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;); try &#123; queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(&quot;Consuming value : &quot; + queue.remove()); queue.notifyAll(); &#125; &#125; &#125;&#125;Output How to use wait and notify method in Java Solving Producer Consumper Problem Queue is empty,Consumer thread is waiting for producer thread to put something in queue Producing value : -1692411980 Producing value : 285310787 Producing value : -1045894970 Producing value : 2140997307 Producing value : 1379699468 Producing value : 912077154 Producing value : -1635438928 Producing value : -500696499 Producing value : -1985700664 Producing value : 961945684 Queue is full, Producer thread waiting for consumer to take something from queue Consuming value : -1692411980 Consuming value : 285310787 Consuming value : -1045894970 Consuming value : 2140997307 Consuming value : 1379699468 Consuming value : 912077154 Consuming value : -1635438928 Consuming value : -500696499 Consuming value : -1985700664 Consuming value : 961945684 Queue is empty,Consumer thread is waiting for producer thread to put something in queue 使用wait，notify，notifyAll需要注意的 在Java中可以使用wait，notify，notifyAll完成多线程(不仅仅是两个线程)的内部通信。 在同步方法或同步块中使用wait，notify，notifyAll，否则JVM会抛出IllegalMonitorStateException 在循环中调用wait，notify。 在线程共享的对象上调用wait 偏向选择notifyAll，而不是notify","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"【译】Java8中的扩展(default/extension)方法 （转载）","slug":"Java-8中的扩展-Default-Defender-Extension-方法","date":"2018-04-13T07:14:18.000Z","updated":"2018-04-13T07:24:37.104Z","comments":true,"path":"2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/","link":"","permalink":"https://hsb786.github.io/2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/","excerpt":"Java 8允许开发者使用default和static两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。","text":"Java 8允许开发者使用default和static两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。 Default方法的例子Java 8让我们可以通过default关键字为接口添加非抽象的方法。这一特性也被称作Extension(扩展)方法。下面是第一个例子： 12345678interface Multiplication&#123; int multiply(int a, int b); default int square(int a)&#123; return multiply(a, a); &#125; &#125; 除了抽象方法multiply()之外，接口Multiplication还包含一个default方法square()。任何实现Multiplication接口的类只需实现抽象方法multiply，default方法square()可以直接使用。 12345678Multiplication product = new Multiplication()&#123; @Override public int multiply(int x, int y)&#123; return x*y; &#125;&#125;; int square = product.square(2); int multiplication = product.multiply(2, 3); product是个匿名类。这段代码有点啰嗦了，用了6行实现一个简单地乘法的功能。我们可以利用lambda表达式来简化一下代码，lambda表达式也是Java 8中新引入的。因为我们的接口只包含一个抽象方法，而且lambda表达式也是SAM(Single Abstract method单一抽象方法)类型的。我们可以用lambda表达式来替代匿名类将代码简化成下面的样子。123Multiplication lambda = (x, y) -&gt; x*y; int product = lambda.multiply(3, 4); int square = lambda.square(4); 以上就是在接口中使用default方法的例子。现在，你可以毫无顾虑的在旧的接口中扩展新的方法，只要这些方法是default或static的就不用担心会破坏接口的实现类。 123456789101112131415161718192021222324252627282930313233343536373839404142/**Java Program to demonstrate use of default method in Java 8. * You can define non-abstract method by using default keyword, and more * than one default method is permitted, which allows you to ship default skeletal * implementation on interface itself. * @author Javin Paul */ public class Java8DefaultMethodDemo&#123; public static void main(String args[]) &#123; // Implementing interface using Anonymous class Multiplication product = new Multiplication()&#123; @Override public int multiply(int x, int y)&#123; return x*y; &#125; &#125;; int squareOfTwo = product.square(2); int cubeOfTwo = product.cube(2); System.out.println(&quot;Square of Two : &quot; + squareOfTwo); System.out.println(&quot;Cube of Two : &quot; + cubeOfTwo); // Since Multiplication has only one abstract method, it can // also be implemented using lambda expression in Java 8 Multiplication lambda = (x, y) -&gt; x*y; int squareOfThree = lambda.square(3); int cubeOfThree = lambda.cube(3); System.out.println(&quot;Square of Three : &quot; + squareOfThree); System.out.println(&quot;Cube of Three : &quot; + cubeOfThree); &#125; &#125; interface Multiplication&#123; int multiply(int a, int b); default int square(int a)&#123; return multiply(a, a); &#125; default int cube(int a)&#123; return multiply(multiply(a, a), a); &#125; &#125; Output : Square of Two : 4 Cube of Two : 8 Square of Three : 9 Cube of Three : 27 这是个很好的关于如何使用default方法在接口中方便的添加方法的例子。也展示了如何避免一个额外的帮助类，比如Collections类。它仅仅提供了一些用于Collection的工具方法，而现在我们可以直接在Collection中定义这些方法。在上面的例子中，我们有一个包含一个抽象方法multiply(a,b)的接口Multiplication，接口还包括两个依赖于multiply(a,b)方法的非抽象方法square(a)和cube(b)。接口的实现类只需要实现multiply(a,b)方法，就可以直接使用square(a)和cube(b)方法了。 default方法的关键点 在Java8中你可以在接口中添加default方法 default方法的出现使得接口和抽象类的不同变得模糊。所以，当在面试中被问到这个问题，别忘了提一下，以前只能通过抽象类实现的事情，现在也可以通过default方法实现了。 default并不是一个新的关键字，在JDK1.1中就是保留关键字 接口中default方法的数量没有限制 如果接口C继承了接口A和B，如果A和B中拥有一样的default方法，编译器在编译过程中会报错。为了避免歧义，这在Java 8中是不允许的。所以当default方法有冲突时，是不可以多继承的 在JDK1.8中有许多关于default方法的例子，比如forEach方法。也可以查看java.util.Map中新添的putIfAbsent方法，在JDK1.8之前，我们只能ConcurrentMap来使用它。 以上就是default方法。不得不说，这是一个巨大的突破，使我们可以更好更方便的使用接口。了解CurrentMap的putIfAbsent方法可以帮助我们更好的记住default方法。在JDK1.7中，putIfAbsent方法并不存在于Map接口中，所以为了使用putIfAbsent方法，必须将Map接口指向的ConcurrentMap对象强制转换成ConcurrentMap。但Java 8引入扩展方法之后，Map接口中也有了putIfAbsent方法。 参考 【译】Java8中的扩展(default/extension)方法","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"【译】如何在java中使用ConcurrentHashMap（转载）","slug":"【译】如何在java中使用ConcurrentHashMap","date":"2018-04-13T06:41:41.000Z","updated":"2018-04-13T07:26:36.082Z","comments":true,"path":"2018/04/13/【译】如何在java中使用ConcurrentHashMap/","link":"","permalink":"https://hsb786.github.io/2018/04/13/【译】如何在java中使用ConcurrentHashMap/","excerpt":"ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。","text":"ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。 Java中ConcurrentHashMap的实现CHM引入了分割，并提供了HashTable支持的所有的功能。在CHM中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。 另一个重要点是在迭代遍历CHM时，keySet返回的iterator是弱一致和fail-safe的，可能不会返回某些最近的改变，并且在遍历过程中，如果已经遍历的数组上的内容变化了，不会抛出ConcurrentModificationExceptoin的异常。 CHM默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，CHM还使用了ReentrantLock来对segments加锁。 Java中ConcurrentHashMap putifAbsent方法的例子很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码 1234567synchronized(map)&#123; if (map.get(key) == null)&#123; return map.put(key, value); &#125; else&#123; return map.get(key); &#125;&#125; 上面这段代码在HashMap和HashTable中是好用的，但在CHM中是有出错的风险的。这是因为CHM在put操作时并没有对整个Map加锁，所以一个线程正在put(k,v)的时候，另一个线程调用get(k)会得到null，这就会造成一个线程put的值会被另一个线程put的值所覆盖。当然，你可以将代码封装到synchronized代码块中，这样虽然线程安全了，但会使你的代码变成了单线程。CHM提供的putIfAbsent(key,value)方法原子性的实现了同样的功能，同时避免了上面的线程竞争的风险。 什么时候使用ConcurrentHashMapCHM适用于读者数量超过写者时，当写者数量大于等于读者时，CHM的性能是低于Hashtable和synchronized Map的。这是因为当锁住了整个Map时，读操作要等待对同一部分执行写操作的线程结束。CHM适用于做cache,在程序启动时初始化，之后可以被多个请求线程访问。正如Javadoc说明的那样，CHM是HashTable一个很好的替代，但要记住，CHM的比HashTable的同步性稍弱。 总结现在我们知道了什么是ConcurrentHashMap和什么时候该用ConcurrentHashMap，下面我们来复习一下CHM的一些关键点。 CHM允许并发的读和线程安全的更新操作 在执行写操作时，CHM只锁住部分的Map 并发的更新是通过内部根据并发级别将Map分割成小部分实现的 高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争 CHM的所有操作都是线程安全 CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常 CHM不允许null的键值 可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map 参考 【译】如何在java中使用ConcurrentHashMap","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"jvm-GC（转载）","slug":"jvm-GC","date":"2018-04-13T06:10:31.000Z","updated":"2018-04-13T12:08:44.969Z","comments":true,"path":"2018/04/13/jvm-GC/","link":"","permalink":"https://hsb786.github.io/2018/04/13/jvm-GC/","excerpt":"关键字约定 Young generation –&gt;新生代 Tenured / Old Generation –&gt;老年代 Perm Area –&gt;永久代 重要的东东 在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。 GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。 GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。 在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。 在从内存回收一个对象之前会调用对象的finalize()方法。 作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。 System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。 如果堆没有内存创建新的对象了，会抛出OutOfMemoryError。","text":"关键字约定 Young generation –&gt;新生代 Tenured / Old Generation –&gt;老年代 Perm Area –&gt;永久代 重要的东东 在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。 GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。 GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。 在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。 在从内存回收一个对象之前会调用对象的finalize()方法。 作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。 System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。 如果堆没有内存创建新的对象了，会抛出OutOfMemoryError。 GC针对什么对象？ 了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。 堆内存是如何划分的？Java中对象都在堆上创建。为了GC，堆内存分为三个部分，也可以说三代，分别称为新生代，老年代和永久代。其中新生代又进一步分为Eden区，Survivor 1区和Survivor 2区(如下图)。新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代。 永久代有一些特殊，它用来存储类的元信息。对于GC是否发生在永久代有许多不同的看法，在我看来这取决于采用的JVM。大家可以通过创建大量的字符串来观察是发生了GC还是抛出了OutOfMemoryError。 GC算法 标记清除算法 分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。 复制算法 把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。 标记整理算法 标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理。优点是不会造成内存碎片。 Java中垃圾回收器的类型Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。 Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。 ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。 Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。 Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。 CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。 与GC有关的JVM参数在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过-XX:NewRatio来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小 Full GC和并发垃圾回收并发垃圾回收器的内存回收过程是与用户线程一起并发执行的。通常情况下，并发垃圾回收器可以在用户线程运行的情况下完成大部分的回收工作，所以应用停顿时间很短。 但由于并发垃圾回收时用户线程还在运行，所以会有新的垃圾不断产生。作为担保，如果在老年代内存都被占用之前，如果并发垃圾回收器还没结束工作，那么应用会暂停，在所有用户线程停止的情况下完成回收。这种情况称作Full GC，这意味着需要调整有关并发回收的参数了。 由于Full GC很影响应用的性能，要尽量避免或减少。特别是如果对于高容量低延迟的电商系统，要尽量避免在交易时间段发生Full GC。 总结 为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。 新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。 永久代是否执行GC，取决于采用的JVM。 Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。 发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。 JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。 Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。 以上就是关于Java中GC的一些内容。通过这篇博客，我们可以知道堆内存是如何划分的；一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；当垃圾收集器意识到需要进行GC时会触发Minor GC或Major GC，是自动的，无法强制执行。 参考 【译】Java中的垃圾回收机制","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/tags/JVM/"}]},{"title":"【译】Executor, ExecutorService 和 Executors 间的不同 （转载）","slug":"difference-between-executor-executorService","date":"2018-04-13T05:21:41.000Z","updated":"2018-04-13T12:02:30.723Z","comments":true,"path":"2018/04/13/difference-between-executor-executorService/","link":"","permalink":"https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/","excerpt":"java.util.concurrent.Executor, java.util.concurrent.ExecutorService, java.util.concurrent. Executors 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。","text":"java.util.concurrent.Executor, java.util.concurrent.ExecutorService, java.util.concurrent. Executors 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：FixedThreadPool(包含固定数目的线程)，CachedThreadPool(可根据需要创建新的线程)等等。 ExecutorExecutor, ExecutorService, 和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。 123public interface Executor &#123; void execute(Runnable command);&#125; 不同于 java.lang.Thread 类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 difference between Thread and Executor 来了解 Thread 和 Executor 间更多的不同。 ExecutorServiceExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用 shutDown 方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。 Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get() 方法获得执行结果。需要注意的是，Future.get() 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。 通过 ExecutorService.submit() 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 cancel() 方法用来取消执行 pending 中的任务。 ExecutorService 部分代码如下： 123456public interface ExecutorService extends Executor &#123; void shutdown(); &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;&#125; ExecutorsExecutors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。 Executors 部分代码： 123456789public class Executors &#123; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;&#125; 下面详细看一下三者的区别： Executor vs ExecutorService vs Executors正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解： Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口 Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。 Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。 Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。 Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。 总结下表列出了 Executor 和 ExecutorService 的区别： Executor ExecutorService Executor 是 Java 线程池的核心接口，用来并发执行提交的任务 ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法 提供execute()方法用来提交任务 提供submit()方法用来提交任务 execute()方法无返回值 submit()方法返回Future对象，可用来获取任务执行结果 不能取消任务 可以通过Future.cancel()取消pending中的任务 没有提供和关闭线程池有关的方法 提供了关闭线程池的方法 参考 【译】Executor, ExecutorService 和 Executors 间的不同","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"vscode-database","slug":"vscode-database","date":"2018-04-13T03:55:59.000Z","updated":"2018-04-13T04:23:59.089Z","comments":true,"path":"2018/04/13/vscode-database/","link":"","permalink":"https://hsb786.github.io/2018/04/13/vscode-database/","excerpt":"最近发现了一个很好用的vscode插件, vscode-database 迷上了vscode","text":"最近发现了一个很好用的vscode插件, vscode-database 迷上了vscode 快捷键 命令 语义 ctrl q querySQL ctrl shift e Run selected text as SQL query","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"触发器","slug":"触发器","date":"2018-04-13T03:43:11.000Z","updated":"2018-04-13T04:38:27.314Z","comments":true,"path":"2018/04/13/触发器/","link":"","permalink":"https://hsb786.github.io/2018/04/13/触发器/","excerpt":"对某一个表的某种操作，触发某种条件，从而执行的一段程序 new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。 old：旧数据，数据库里原先有的数据","text":"对某一个表的某种操作，触发某种条件，从而执行的一段程序 new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。 old：旧数据，数据库里原先有的数据 说明：在把userjob(用户岗位关联表)中的success(审批状态)更新为true时，自动在成绩表中出入数据；否则说明没有审批没有通过，把成绩表中对应的数据删除1234CREATE TRIGGER `insertScore` AFTER UPDATE ON `userjob` FOR EACH ROW if new.success=true theninsert into score(id) values(new.id);else delete from score where id=new.id;end if 说明：在删除userjob(用户岗位关联表)的数据时，自动删除成绩表对应中的数据123CREATE TRIGGER `deleteScore` BEFORE DELETE ON `userjob` FOR EACH ROW if old.success=true thendelete from score where id=old.id;end if","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"sql","slug":"sql","date":"2018-04-12T12:56:19.000Z","updated":"2018-04-12T13:27:14.338Z","comments":true,"path":"2018/04/12/sql/","link":"","permalink":"https://hsb786.github.io/2018/04/12/sql/","excerpt":"索引索引（Index）是帮助MySQL高效获取数据的数据结构 排好序的快速查找数据结构 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。","text":"索引索引（Index）是帮助MySQL高效获取数据的数据结构 排好序的快速查找数据结构 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。 优势 提高数据检索效率，降低数据库的IO成本 通过索引对数据进行排序，降低数据排序的成本，降低了消耗 劣势 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引列也是要占空间的 虽然索引列大大提高了查询速度，同时会降低更新表的速度。因为更新表时，还要保存一下索引文件每次更新添加了索引列的字段 哪些情况需要创建索引 主键自动建立唯一索引 （不需要自己建） 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外键关系建立索引 （自动建立） 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度 查询中统计或者分组的字段 哪些情况不需要创建索引 表记录太小 经常增删改的表 某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"Java虚拟机","slug":"Java虚拟机","date":"2018-04-12T12:01:50.000Z","updated":"2018-04-14T12:37:13.002Z","comments":true,"path":"2018/04/12/Java虚拟机/","link":"","permalink":"https://hsb786.github.io/2018/04/12/Java虚拟机/","excerpt":"内存区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。","text":"内存区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。 JVM(Java Virtual Machine)JVM并不是专为Java所实现的。实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。 JVM通过执行Java bytecode可以使java代码在不改变的情况下运行在各种硬件之上，因此实现Java平台无关性 JVM = 类加载器 Class Loader + 执行引擎 Execution Engine + 运行时数据区域 Runtime Data Area 首先Java源代码文件被Java编译器编译为字节码文件，然后JVM中的类加载器加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM中的运行时数据区（内存）会用来存储程序执行期间需要用到的数据和相关信息。 Class LoaderClassLoader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它并不负责这个类文件能否执行，而这个是执行引擎负责的。 Execution Engine执行字节码，或者执行本地方法 Runtime DataArea指JVM在运行期间，其对JVM内存空间的划分和分配。 程序计数器（Program Counter Register）一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。 当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。 Java虚拟机栈（Java Virtual Machine Stacks）该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 在Java虚拟机规范中，对这个区域规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。 和JVM栈一样，也会抛出StackOverflowError和OutOfMemoryError异常 Java堆（Java Heap）Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。 根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area）方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。 由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，但java7已经把常量池转移到堆里面了。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 参考 【深入Java虚拟机】之一：Java内存区域与内存溢出 读书笔记-深入理解Java虚拟机1","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"java8新特性（转载）","slug":"java8新特性（转载）","date":"2018-04-12T07:56:55.000Z","updated":"2018-04-13T04:39:49.093Z","comments":true,"path":"2018/04/12/java8新特性（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/12/java8新特性（转载）/","excerpt":"Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。","text":"Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。 Default Methods for InterfacesJava 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子： 1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; 在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt.Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。 123456789Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 那么这个新特征有啥用呢？ 我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类，那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法，那么我们需要去重写每个实现了这个接口的类，而这大大增加了我们的实现需求的负担。 正是为了解决Java接口中只能定义抽象方法的问题。Java8新增加了默认方法的特性。默认方法可以被继承接口重写成抽象方法或者重新定义成默认方法。除了默认方法，接口里还可以声明静态方法，并且可以实现。例子如下：123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; Conflict因为一个类可以实现多个接口，所以当一个类实现了多个接口，而这些接口中存在两个或两个以上方法签名相同的默认方法时就会产生冲突，java8定义如下三条原则来解决冲突： 类或父类中显式声明的方法，其优先级高于所有的默认方法； 如果1规则失效，则选择与当前类距离最近的具有具体实现的默认方法； 如果2规则也失效，则需要显式指定接口。 Lambda ExpressionsLambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式，它提供了轻量级的语法 重点留意这四个关键词：匿名、函数、传递、简洁 Lambda的三个部分： 参数列表 箭头 Lambda 主体 Lambda的基本语法大概就是下面这样子的了： (parameters) -&gt; expression (parameters) -&gt; { statements; } 1234567Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;);或者是Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));亦或是Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Lexiacal Scope访问局部变量可以直接在Lambda表达式中访问外层的局部变量，但是和匿名对象不同的是，Lambda表达式的局部变量可以不用声明为final，不过局部变量必须不可被后面的代码修改（即隐性的具有final的语义）。 eg：下面代码无法编译1234int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; String.valueOf(param + num); num = 5; 在Lambda表达式中试图修改局部变量是不允许的！ 在 Lambda 表达式当中被引用的变量的值不可以被更改。 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 和局部变量不同的是，Lambda内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。 不能访问接口的默认方法Lambda表达式中是无法访问到默认方法的。 补充：Lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，在这里增加一个例子以说明这个特性： 12345int sum = 0;list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over valuesList&lt;Integer&gt; aList = new List&lt;&gt;();list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables 匿名内部类的简写？Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件 Lambda表达式中的this既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。 Functional Interfaces任意只包含一个抽象方法的接口，我们都可以用来做成Lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。 12345678@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125; Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted); // 123 注意，如果你不写@FunctionalInterface 标注，程序也是正确的。 下面是Java SE 7中已经存在的函数式接口： java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.beans.PropertyChangeListener 除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如： Predicate——接收T对象并返回boolean Consumer——接收T对象，不返回值 Function&lt;T, R&gt;——接收T对象，返回R对象 Supplier——提供T对象（例如工厂），不接收值 UnaryOperator——接收T对象，返回T对象 BinaryOperator——接收两个T对象，返回T对象 除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。 Method and Constructor ReferencesLambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。 方法引用和Lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。 方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。方法引用有很多种，它们的语法如下： 静态方法引用：ClassName::methodName 实际上的实例方法引用：instanceReference::methodName 超类上的实例方法引用：super::methodName 类型上的实例方法引用：ClassName::methodName 构造方法引用：Class::new 数组构造方法引用：TypeName[]::new 对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。 结合Lambda可以使我们的代码更加简洁： 1234List&lt;String&gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;);strings.stream().map(String::toUpperCase).forEach(System.out::println);List&lt;Character&gt; chars = Arrays.asList(&apos;a&apos;, &apos;b&apos;); System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;))); OptionalNullPointException可以说是所有Java程序员都遇到过的一个异常，虽然Java从设计之初就力图让程序员脱离指针的苦海，但是指针确实是实际存在的，而java设计者也只能是让指针在Java语言中变得更加简单、易用，而不能完全的将其剔除，所以才有了我们日常所见到的关键字null。 空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。当异常真的发生的时候，处理策略也很简单，在存在异常的地方添加一个if语句判定即可，但是这样的应对策略会让我们的程序出现越来越多的null判定，我们知道一个良好的程序设计，应该让代码中尽量少出现null关键字，而Java8所提供的Optional类则在减少NullPointException的同时，也提升了代码的美观度。但首先我们需要明确的是，它并 不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现，从而避免NullPointException。 java.util.Optional 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。 创建 Optional 对象,三个静态工厂方法： Optional.empty：创建空的 Optional 对象 Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE Optianal.ofNullable：创建 Optional 对象，允许传空值 Optional API： isPresent(): 变量存在返回true get(): 返回封装的变量值，或者抛出 NoSuchElementException orElse(T other): 提供默认值 orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版 orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型 ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法 filter(Predicate&lt;? super T&gt; predicate): 过滤 map(Function&lt;? super T, ? extends U&gt; mapper): 转换 flatMap(Function&lt;? super T, Optional&lt;U>>mapper): 转换成Optional 值得注意的是：Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题 Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法，没有考虑将它作为类的字段使用… 另外，在Java9中对Optional添加了三个新的方法： public Optional or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)or 方法的作用是，如果一个 Optional 包含值，则返回自己；否则返回由参数 supplier 获得的 Optional public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run() public Stream stream()stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream；否则返回一个空的 Stream（Stream.empty()） 举个例子，在 Java8，我们会写下面的代码： 12345678// 此处 getUserById 返回的是 Optional&lt;User&gt;public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123; return userIds.stream() .map(this::getUserById) // 获得 Stream&lt;Optional&lt;User&gt;&gt; .filter(Optional::isPresent)// 去掉不包含值的 Optional .map(Optional::get) .collect(Collectors.toList());&#125; 而有了 Optional.stream()，我们就可以将其简化为： 123456public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123; return userIds.stream() .map(this::getUserById) // 获得 Stream&lt;Optional&lt;User&gt;&gt; .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流 .collect(Collectors.toList());&#125; Streams 流是什么12345Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;).stream() .filter(s -&gt; s.startsWith(&quot;c&quot;)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); 流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。 引入的原因： 声明性方式处理数据集合 透明地并行处理，提高性能 流 的定义：从支持数据处理操作的源生成的元素序列 两个重要特点 流水线 内部迭代 流与集合： 集合与流的差异就在于什么时候进行计算 集合是内存中的数据结构，包含数据结构中目前所有的值 流的元素则是按需计算/生成 另一个关键区别在于遍历数据的方式 集合使用 Collection 接口，需要用户去做迭代，称为外部迭代 流的 Streams 库使用内部迭代 流的使用 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果。 流的流水线背后的理念类似于构建器模式。常见的中间操作有filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。 流的操作类型分为两种： Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 流的使用构建流 由值创建流：Stream.of、Stream.empty、IntStream.range 由集合创建流：Collection.stream、Collection.parallelStream 由数组创建流：Arrays.stream(数组变量) 由文件生成流：Files.lines、Files.walk 由BufferedReader创建流：java.io.BufferedReader.lines 由函数生成流：创建无限流， 迭代： Stream.iterate（接受一个种子值，和一个UnaryOperator） 生成：Stream.generate（接收一个Supplier接口） 使用流Intermediate（中间操作）： 筛选 谓词筛选：filter 筛选互异的元素：distinct 忽略头几个元素：skip 截短至指定长度：limit 排序：sorted 偷瞄（输出）：peek 平行化：parallel 串行化：sequential 映射 对流中每个元素应用函数：map 流的扁平化：flatMap 转为原始流：mapToInt、mapToInt、mapToInt 从原始流转为普通流：boxed 数值范围 range:[起始值，结束值) rangeClosed:[起始值，结束值] Terminal（终结操作） 查找和匹配 检查谓词是否至少匹配一个元素：anyMatch 检查谓词是否匹配所有元素：allMatch/noneMatch 查找元素：findAny 查找第一个元素：findFirst 归约（折叠）：reduce(初值，结合操作) 元素求和：count、sum 最大值和最小值：min、 max 遍历 forEach、 forEachOrdered anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。 映射到数值流：mapToInt,mapToDouble,mapToLong 转换回流对象：boxed 默认值：OptionalInt,OptionalDouble,OptionalLong 用流收集数据对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。 Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能： 将流元素归约和汇总为一个值 元素分组 元素分区 归约和汇总(Collectors 类中的工厂方法)： 统计个数：Collectors.counting 查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy 汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数 连接字符串：joining 广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。 collect vs. reduce，两者都是 Stream 接口的方法，区别在于： 语意问题 reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约； collect 方法设计就是要改变容器，从而累积要输出的结果 实际问题 以错误的语义使用 reduce 会导致归约过程不能并行工作 分组和分区 分组：Collectors.groupingBy 多级分组 按子数组收集数据: maxBy 把收集器的结果转换为另一种结果 collectingAndThen 与 groupingBy 联合使用的其他收集器例子：summingInt,mapping 分区：Collectors.partitioningBy是分组的特殊情况，由一个谓词作为分类函数(分区函数)，返回一个Map，只有两个Boolean类型的key。 Ex1:使用collect()生成Collection前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成： 123456// 将Stream转换成List或SetStream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。 123// 使用toCollection()指定规约容器的类型ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4) 上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。 Ex2:使用collect()生成Map前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map： 使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。 使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。 使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。 情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。 1234// 使用toMap()统计学生GPAMap&lt;Student, Double&gt; studentToGPA = students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key student -&gt; computeGPA(student)));// 如何生成value 情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。 123// Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream() .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); 情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组： 123// Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); 以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。 1234// 使用下游收集器统计每个部门的人数Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));// 下游收集器 上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到： 12345// 按照部门对员工分布组，并只保留员工的名字Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.mapping(Employee::getName,// 下游收集器 Collectors.toList())));// 更下游的收集器 Notice And Optimization 流不可被复用 一般先filter、limit、skip操作后再进行sorted、peek、map等操作以达到short-circuiting 目的 Stream操作分类 方法 中间操作(Intermediate operations) 无状态(Stateless) unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek() 有状态(Stateful) distinct() sorted() sorted() limit() skip() 结束操作(Terminal operations) 非短路操作 forEach() forEachOrdered() toArray() reduce() collect() max() min() count() 短路操作(short-circuiting) anyMatch() allMatch() noneMatch() findFirst() findAny() Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。 Java8 对字符串连接的改进有时候，我们会有一种需求就是将若干个字符串用某个链接符衔接起来，例如有一个 List，将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式。 以前我们的一般做法就是使用StringBuilder： 1234567891011121314151617181920212223public static String formatList(List&lt;String&gt; list, String delimiter) &#123; StringBuilder result = new StringBuilder(); for (String str : list) &#123; result.append(str).append(delimiter); &#125; // 删除末尾多余的 delimiter result.delete(result.length() - delimiter.length(), result.length()); return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringBuilder：&quot;); String format = formatList(list, &quot;,&quot;); System.out.println(format);&#125;//运行结果使用 StringBuilder：a,b,c,d,e,f,g JDK1.8 时，添加了一个新的用于字符串连接的类，专门用于这种需要 分隔符 的场合，它就是 StringJoiner。StringJoiner 在构造时可以指定一个分隔符（delimiter），然后每连接一个元素它便会加上一个 delimiter，使用 StringJoiner 改写 formatList： 123456789101112131415public static String formatList(List&lt;String&gt; list, String delimiter) &#123; StringJoiner result = new StringJoiner(delimiter); for (String str : list) &#123; result.add(str); &#125; return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringJoiner：&quot;); String format = formatList(list, &quot;,&quot;); System.out.println(format);&#125; 或者使用String.join: 123public static String formatList(List&lt;String&gt; list, String delimiter) &#123; return String.join(delimiter, list);&#125; String.join 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 List 格式化为 { 元素1, 元素2, 元素3, … 元素N } 呢？（此时前缀为 “{ “，后缀为 “ }”） 1234567891011121314151617public static String formatList( List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123; StringJoiner result = new StringJoiner(delimiter, prefix, suffix); for (String str : list) &#123; result.add(str); &#125; return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringJoiner，带前缀和后缀：&quot;); String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;); System.out.println(format);&#125; 事实上，Java8 对于字符串集合的连接操作提供了一个专门的流式 API，即 Collectors.joining 函数 无参的 joining() 方法，即不存在连接符（底层实现为 StringBuilder）； joining(CharSequence delimiter) 方法，即分隔符为 delimiter（底层实现为 StringJoiner）； joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法，即分隔符为 delimiter，前缀为 prefix，后缀为 suffix（底层实现为 StringJoiner）。 那怎么使用呢？ 我们直接使用三个参数的 Collectors.joining 方法改写 formatList： 12345678910111213public static String formatList( List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123; return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 Collectors.joining：&quot;); String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;); System.out.println(format);&#125; Java8 中 Map 接口的新方法假如现在我们存在这样的需求：给定一个 List，统计每个元素出现的所有位置。 比如，给定 list：[“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “f”, “f”, “g”] ，那么应该返回：123456a : [0]b : [1, 2]c : [3, 4, 5]d : [6, 7, 8]f : [9, 10]g : [11] 很明显，我们很适合使用 Map 来完成这件事情： 12345678910111213141516171819202122232425public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); List&lt;Integer&gt; positions = positionsMap.get(str); if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt; positions = new ArrayList&lt;&gt;(1); positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap &#125; positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中 &#125; return positionsMap;&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 Java8 之前的 API：&quot;); Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list); System.out.println(elementPositions);&#125; 运行结果 12使用 Java8 之前的 API：&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125; computeIfAbsent1234567891011121314151617public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i); &#125; return positionsMap;&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 computeIfAbsent：&quot;); Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list); System.out.println(elementPositions);&#125; 当 forEach 需要索引1234567public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i); &#125; return positionsMap;&#125; 但是方法里面的for循环似乎让这个方法不太优雅了，Java8中Iterable提供的foreach并不带索引的： 我们可以自己写一个： 1234567891011public static &lt;E&gt; void forEach( Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123; Objects.requireNonNull(elements); Objects.requireNonNull(action); int index = 0; for (E element : elements) &#123; action.accept(index++, element); &#125; &#125;&#125; 然后改造getElementPositions方法： 123456789public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); Iterables.forEach(list, (index, str) -&gt; &#123; positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index); &#125;); return positionsMap;&#125; 参考 Java8 Noob Tutorial","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"合并两个排序的链表","slug":"合并两个排序的链表","date":"2018-04-12T07:29:59.000Z","updated":"2018-04-12T07:53:55.820Z","comments":true,"path":"2018/04/12/合并两个排序的链表/","link":"","permalink":"https://hsb786.github.io/2018/04/12/合并两个排序的链表/","excerpt":"输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。","text":"输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static ListNode merge(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; if (list1.data &lt; list2.data) &#123; list1.next = merge(list1.next, list2); return list1; &#125; else &#123; list2.next = merge(list1, list2.next); return list2; &#125;&#125;public static ListNode mergeSortedList(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; ListNode mergeHead = null; ListNode current = null; if (list1.data &lt;= list2.data) &#123; mergeHead = current = list1; list1 = list1.next; &#125; else &#123; mergeHead = current = list2; list2 = list2.next; &#125; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.data &lt;= list2.data) &#123; current.next = list1; current = current.next; list1 = list1.next; &#125; else &#123; current.next = list2; current = current.next; list2 = list2.next; &#125; &#125; if (list1 == null) &#123; current.next = list2; &#125; else &#123; current.next = list1; &#125; return mergeHead;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2018-04-12T05:39:35.000Z","updated":"2018-04-14T05:13:08.342Z","comments":true,"path":"2018/04/12/MyBatis/","link":"","permalink":"https://hsb786.github.io/2018/04/12/MyBatis/","excerpt":"MyBatis简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。","text":"MyBatis简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。 MyBatis组件MyBatis的核心组件分为4个部分： SqlSessionFactoryBuilder(构造器)：它会根据mybatis的配置文件(Configuration配置类)来生成SqlSessionFactory，这里采用的是分步构建的Builder模式 SqlSessionFactory(工厂)：用于生成SqlSession，可以被认为是数据库连接池 SqlSession(会话)：既可以直接发送SQL执行并返回结果，也可以获取映射器Mapper接口(动态代理的类)执行SQL得到返回结果，相当于数据库连接(Connection对象) Mapper(映射器)：由一个Java接口和XML文件构成：接口用于给出方法的入参以及返回值，XML给出SQL语句和映射规则。映射器的主要作用就是将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中 注意，无论是映射器还是SqlSession都可以发送SQL到数据库执行，但是为了保证代码的可读性与可维护性，推荐使用Mapper接口编程来完成该操作。 作用域（Scope）和生命周期SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 映射器实例（Mapper Instances）映射器是一个你创建来绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125; 如何使用MyBatis首先，在MyBatis中有两种XML配置文件，一种是基础配置文件，它只有一个，用于配置一些MyBatis的上下文参数和运行环境；另一种是映射器的XML映射文件，它可以配置映射关系，SQL等等。简单来说，在使用MyBatis的时候，先给出MyBatis的配置文件用于生成SqlSession，然后再给出映射器Mapper的接口与相应的映射XML文件，最后就可以生成Mapper接口的动态代理类来发送SQL获取结果了。 映射器映射器是mybatis最核心的组件，它由一个接口加上xml文件组成。在映射器中可以配置参数，各类的SQL语句，缓存，级联等内容，并且可以通过映射规则映射到指定的POJO上。映射器的接口与映射xml文件配置使用，可以有效的消除jdbc底层代码。 映射器的映射xml文件有以下几个元素： cache – 给定命名空间的缓存配置 cache-ref – 其他命名空间缓存配置的引用 resultMap – 描述如何从数据库结果集中来加载对象，它将提供映射规则 sql – 可被其他语句引用的可重用语句块，可以定义一部分SQL，然后在其他地方引用 insert – 映射插入语句，执行后返回一个整数，代表插入的条数 update – 映射更新语句，执行后返回一个整数，代表更新的条数 delete – 映射删除语句，执行后返回一个整数，代表删除的条数 select – 映射查询语句，返回查询结果 select元素映射器中的select元素代表SQL的select语句，用于查询。select元素中有以下常用的属性： id:在Mapper的命名空间中唯一的标识符。Mapper的命名空间与select元素的id将唯一定位对应的映射器接口的某个方法。 parameterType：将会传入这条语句的参数类的完全限定名或别名，可以选择Java Bean，Map等参数类型传递给SQL。这个属性是可选的，mybatis可以通过TypeHandler推断出具体传入语句的参数。 resultType：从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。 resultMap：映射集的引用，用于结果集的映射，完成结果的映射功能。注意resultType和resultMap不能同时使用。 flushCache：将其设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache：将其设置为true，将会导致本条语句的结果被二级缓存，默认值：对select元素为true。 123&lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.spring.test.pojo.Person&quot;&gt; SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;&lt;/select&gt; 1public Person getPerson(@Param(&quot;id&quot;) int id); mybatis提供的自动映射功能，只要SQL的列名与POJO的属性名保持一致，同时在mybatis的配置文件中settings元素的autoMappingBehavior是开启的(默认是开启)即可完成自动映射。如果列名与属性名不一致的话，还可以通过SQL的别名机制来处理。比如说，假如原来列名为person_name，属性名为personName，那么在SQL中就可以这么写：select person_name as personName … 这样同样可以完成自动映射。 这里特别说明关于select元素返回一个对象或者对象集合的问题： 返回数据类型由DAO中的接口和映射xml文件共同决定。另外，不论是返回单一对象还是对象列表，映射xml中的配置都是一样的，都是resultType=“ . .”类型或resultMap=”resultMap-ref”*。 每一次mybatis从数据库中select数据之后，都会检查数据条数和DAO中定义的返回值是否匹配。 若返回一条数据，DAO中定义的返回值是一个对象或对象的List列表，则可以正常匹配，将查询的数据按照DAO中定义的返回值存放。 若返回多条数据，DAO中定义的返回值是一个对象，则无法将多条数据映射为一个对象，此时mybatis报错。 resultMap元素通过resultType加上mybatis的自动映射可以应对大多数的结果集的映射需求，但是这种方法无法定义更多的属性，比如typeHandler，级联等。为了支持更加复杂的映射，mybatis提供了resultMap属性来完成SQL到Java Bean的映射关系定义。接下来，用resulyMap改写之前使用自动映射的select元素。 123456789&lt;resultMap id = &quot;Map&quot; type = &quot;mybatis.spring.test.pojo.Person&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt; &lt;result property=&quot;tel&quot; column=&quot;tel&quot;&gt;&lt;/resultMap&gt; &lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultMap=&quot;Map&quot;&gt; SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125; &lt;/select&gt; 子元素id代表主键，result代表属性，id和result元素的property属性代表POJO的属性名称，column代表SQL的列名，这样就将POJO的属性和SQL的列名进行一一对应了。 一个完整的resultMap元素的构成有哪些？ constructor：类在实例化时,用来注入结果到构造方法中 id：表示哪个列是主键 result：注入到JavaBean属性的普通结果，配置POJO到SQL列名的映射关系 association：一个复杂的类型关联;许多结果将包成这种类型 collection：复杂类型的集 discriminator：使用结果值来决定使用哪个结果映射 constructor元素用于配置构造方法，一个POJO可能不存在没有参数的构造方法，就要使用construtor元素来配置了。 id元素，result元素主要来定义POJO与SQL列名的映射规则，它们有如下属性： property:映射规则中的POJO的属性名，可以用导航式字段，例如需要访问Person类的Address属性的id，就可以写成Address . id column：对应的SQL的列名 javaType：Java类型 jdbcType：数据库类型 typeHandler：类型处理器，允许使用自定义的类型处理器 其中association，collection和discriminator这些元素是与结果映射的级联相关的。Mybatis支持级联映射，简单来说，假如我们select一个person类，person类有一个属性为address，address也是一个POJO，也就是说需要再进行一次select才能查询到address类的信息。这里需要说明的是，级联不是必须的，级联可以便捷的获取关联数据，但是如果级联太多的话会影响执行效率，也就是著名的N+1问题(如果有N个关联关系完成了级联，那么只要再加入一个关联关系，就变成了N+1个，所有的级联SQL都会被执行，显然不是所有数据是我们感兴趣的，造成了资源的浪费与性能的浪费)。为了应对级联中的N+1问题，mybatis支持延迟加载，在select的时候并不是一次性取出所有的SQL结果来映射，对于那些不常用的级联数据等到需要的时候再取出。在mybatis的全局配置文件中可以设定延迟加载属性，同时在级联元素association和collection中的fetchType属性也可以定义延迟加载。 insert,update,delete相比于select来说，insert,update,delete就很简单了，它们执行的结果返回的是整数，用以标识该SQL语句影响了数据库的记录行数，不需要进行结果集的映射。除此之外，insert元素是支持主键回填的，在inser语句中有一个属性useGeneratedKeys，用来控制是否使用数据库生成的主键来回填到POJO，默认值为false。当打开了主键回填之后，还要配置keyProperty或者keyColumn，告诉mybatis把生成的主键放入哪个属性中。至于在实际中用不用得到数据库生成的主键，我也不能完全肯定，这里只要知道mybatis是支持主键回填的即可，使用起来也很容易。 sql元素这个元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中 12345678&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 动态SQLmybatis提供了对SQL语句动态的组装能力，大量的判断都可以在mybatis的映射xml里面配置，大大减少了代码量，提供了灵活性。 ifif元素使用的场景适用于在SQL语句的where子句中动态地选择某几个判断条件作为SQL语句的一部分进行拼接。 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 如果传入的参数title不是null，那么就将 AND title like #{title} 这子句拼接在where之后，这样就可以有条件地包含where子句的一部分。 choose(when,otherwise)if元素是单条件的，choose元素就是多条件的选择类似java里的switch语句，原理一样，还是接着上面的例子来举例： 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 上述参考文档中的例子otherwise元素写的是 AND featured = 1 是为了解决前面的所有case都不满足的情况，我建议写成 AND 1 = 1 更好理解。该动态SQL语句的功能：如果参数提供了“title”就按“title”查找，提供了“author”就按“author”查找，若两者都没有提供，就返回所有符合默认条件的查询结果集。 trim(where,set)前面的例子中的where子句总会有一个默认的查询条件也就是例子中的 state = ‘ACTIVE’ ，如果state也设置成动态的呢？可以通过where,set元素来达到这个需求。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 同样如果是update子句，那么也就相应的set元素，如下： 12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 如果where,set都无法满足动态拼接SQL的需求，我们可以使用trim来自定义如何拼接SQL子句，where和set只是mybatis定义好的拼接SQL的方法而已，但这也已经可以满足大多数需求了。 foreach动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。还是参考文档里买的例子： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach元素允许指定一个集合，声明可以用在元素体内的集合项和索引变量，也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。我们可以将任何可迭代对象（如列表、集合等）和任何的字典或者数组对象传递给foreach作为集合参数。当使用可迭代对象或者数组时，index是当前迭代的次数，item的值是本次迭代获取的元素。当使用字典（或者Map.Entry对象的集合）时，index是键，item是值。 #{}和${}#{}表示一个占位符号，用来传入参数，sql在解析的时候会加上” “,当成字符串来解析，可以防止sql注入 ${}表示一个拼接符号, 传入数据直接显示在生成的sql中，这样就会导致sql注入 MyBatis缓存MyBatis提供一级缓存和二级缓存 如果缓存中有数据就不用从数据库中获取，减少了和数据之间的交互次数，大大提高系统的性能。 一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)，用于存储缓存数据。不同的sqlSession之间的缓存区域(HashMap)是互不影响的。 二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个SqlSession可以公用二级缓存，二级缓存是跨sqlSession的。 一级缓存的工作原理 二级缓存的工作原理 参考 MyBatis官方文档 MyBatis入门 MyBatis进阶 Mybatis学习总结（九）——查询缓存","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://hsb786.github.io/tags/MyBatis/"}]},{"title":"HashMap","slug":"HashMap","date":"2018-04-12T03:29:30.000Z","updated":"2018-04-13T12:43:52.141Z","comments":true,"path":"2018/04/12/HashMap/","link":"","permalink":"https://hsb786.github.io/2018/04/12/HashMap/","excerpt":"HashMap内部存储结构 HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。","text":"HashMap内部存储结构 HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。 123456789101112131415161718192021222324252627public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; transient Node&lt;K,V&gt;[] table; transient int size; transient int modCount; static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; ..... &#125; .....&#125; table，一个存放节点(Node[])的数组，是Hashmap的基础设施，所有的节点都存放于此。 size，Hashmap存放的键值对的数目，并不等于table数组的长度，因为可能存在链表和红黑树结构。 modCount，Hashmap的修改次数，是实现fail-fast机制的关键 DEFAULT_INITIAL_CAPACITY，表示默认HashMap数组初始大小为16，并且为了后续的rehash操作的方便，Hashmap的数组大小始终为2的整数次幂，即使你输入一个不是2的整数次幂的值，也会变成最小的大于该值的2的整数次幂。 MAXIMUM_CAPACITY，表示Hashmap数组的最大容量，初始值为2^30。 DEFAULT_LOAD_FACTOR，表示负载因子，当Hashmap的实际容量超过了(设定容量乘负载因子)，就触发rehash操作，默认值为0.75。 TREEIFY_THRESHOLD，jkd1.8新增的，如果Hashmap数组元素的链表长度超过这个值，就使用红黑树结构代替链表提高查询效率，默认值为8。 数组内的元素的数据结构继承了Map.Entry，用于存放键值对，另外还包含了hash值和next节点，其中hash值可用于存取节点时来寻址的作用，next节点是实现Hashmap的数组+链表(红黑树)结构的关键。 在继续看Hashmap的内部方法之前，做个大致的总结： Hashmap是用于存放键值对的容器，内部实现是基于数组的，数组中存放的是键值对Node节点，一个Node节点保存了一个键值对信息，同时还保存了next节点，可以形成链表结构(在发生hash冲突的时候)。如果链表长度太长，超过了阀值(默认为8)，那么就自动升级为红黑树结构(高效的平衡查找树)，这样一来，数组元素的节点就成为了红黑树的根节点了。 需要注意的是，在java8中如果hash值相同的key数量大于指定值（默认是8）时使用平衡树来代替链表，这会将get()方法的性能从O(n)提高到O(logn)。 HashMap的自动扩容机制 HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶都有62500个元素，这时get()，put()，remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小*loadFactor(加载因子)后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16*0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置。 没扩容前，获取EntryE需要遍历5个元素，扩容之后只需要2次。 put() 对key的hashCode()做hash，然后计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长（大于等于TREEIFY_THRESHOLD），就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性)； 如果bucket满了(超过load factor*current capacity)，就要resize。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 如果put()方法添加的键值对的键已经存在于Hashmap中，那么就用新的键值的值替代旧值。再看源码put()调用了hash()方法以及putVal()方法 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当输入的key为null时，hash值为0，也就是说Hashmap的key是可以为null的。对比HashTable，HashTable的key直接进行了hashCode，如果key为null时，会抛出异常，所以HashTable的key不可以是null。具体如何得到key的hash值呢？首先调用key自身的hashcode()得到一个hash值h(32位int类型)，然后将h与h右移16位之后的数进行异或，得到最终的hash值。至于为什么这么做，这是前人总结出来的算法可以使得hash值分布更加均匀,尽量减少冲突 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 通过注释，我们可以知道入参都代表了什么： hash：表示key的hash值 key：待存储的key值 value：待存储的value值 onlyIfAbsent：是否需要替换相同的value值。如果为true，表示不替换已经存在的value evict：如果为false，表示数组是新增模式(暂时不知道啥意思,只在方法的最后出现,但不影响其他逻辑) 首先判断当前HashMap的数组是否为空，如果为空，就调用resize()方法初始化一个长度为16的数组，并且获取到数组的长度n，代码如下： 12if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; 然后，根据数组的长度n-1的值与入参key的hash值按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。但是，如果取到了数据，也就是这个hash值对应数组的位置上面已经有了键值对存在。那么，就判断这个Node,也就是p的hash值是否与传入的hash相等，然后接着判断key是否相等。如果判断通过，表示要传入的key-val键值对就是tab[i]位置上面的键值对，直接替换即可，不用管后面是链表还是红黑树。如果不是的话，就将这个新的键值对插入链表或者红黑树种即可。插入键值对分两种情况：如果数组元素是链表时，就将节点新增到列表尾部。如果链表的长度大于等于红黑树化的阀值-1，就将链表转成红黑树。如果数组元素是红黑树的话，就插入键值到对应的Node。 注意，java8开始用的是尾插法12345678910111213141516171819202122232425262728293031if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125;&#125; 最后，将修改次数加一，同时判断当前的键值对数量是否即将超过阀值，如果即将超过，需要进行resize操作。12345++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; get() bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry; 若为树，则在数中通过key.equals(k)查找，O(logn); 若为链表，则在链表中通过key.equals(k)查找，O(n)。 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 根据入参的key对象计算出key的hash值，调用getNode()方法，再来看看getNode()方法。12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 通过key的hash值与key对象，来查找key对应的键值对的值，如果查找失败则返回null。如何查找的呢？首先，通过key的hash值计算出对应数组的索引，如果索引到的第一个Node节点的key和hash值与入参相等，直接返回该Node。否则，循环遍历下一个节点(可能是链表也有可能是红黑树)。 resize() 在resize的时候，数组容量还是要保持为2的整数次幂，所以扩容的时候容量会翻倍(原容量乘以2)，那么在resize的时候原来的元素在新数组中要不就维持原索引，要不就从原位置再移动2次幂， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //记录原数组的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量。如果true，将阈值设置为Integer的最大值，同时数组容量不变 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) //定义一个新的容量的数组，同时完成对新数组的赋值 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 为什么线程不安全 如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(根据hash值计算的bucket一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。 扩容时需要rehash，可能会造成死循环(java8已修复) 如何线程安全的使用HashMap Hashtable123456public synchronized V get(Object key) &#123; .....&#125;public synchronized V put(K key, V value) &#123; ......&#125; 效率低，一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以。 ConcurrentHashMap （效率高）JUC包中的一个类。ConcurrentHashMap 不仅线程安全而且效率高，因为它包含一个 segment 数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的锁分段技术。 SynchronizedMap调用synchronizedMap()方法后返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的 1234567891011121314151617181920212223242526272829303132333435363738394041// synchronizedMap方法public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123; return new SynchronizedMap&lt;&gt;(m); &#125;// SynchronizedMap类private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map&lt;K,V&gt; m) &#123; this.m = Objects.requireNonNull(m); mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; // 省略其他方法 &#125; 从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。 总结 HashMap在处理冲突时使用链表存储相同索引的元素。 从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。 当从链表切换到平衡树时，HashMap迭代的顺序将会改变。不过这并不会造成什么问题，因为HashMap并没有对迭代的顺序提供任何保证。 从Java 1中就存在的Hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。 除了Hashtable之外，WeakHashMap和IdentityHashMap也不会在频繁冲突的情况下使用平衡树。 使用HashMap之所以会产生冲突是因为使用了键对象的hashCode()方法，而equals()和hashCode()方法不保证不同对象的hashCode是不同的。需要记住的是，相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。 在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。 参考 Java 8中HashMap和LinkedHashMap如何解决冲突 如何线程安全的使用 HashMap 看看HashMap源码","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"String与StringBuffer","slug":"String与StringBuffer","date":"2018-04-11T06:17:41.000Z","updated":"2018-04-13T12:13:33.151Z","comments":true,"path":"2018/04/11/String与StringBuffer/","link":"","permalink":"https://hsb786.github.io/2018/04/11/String与StringBuffer/","excerpt":"String不可变，StringBuffer可变，why ?","text":"String不可变，StringBuffer可变，why ? 看源码 String1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 可以看出String底层是用char数组实现的，由于被final修饰所以引用不能改变。 为什么要这样设计 只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。 如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。 因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。 StringBuffer 12345678910111213141516171819202122232425262728293031323334353637383940414243 public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; /** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache; @Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; //AbstractStringBuilder中的方法 public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; &#125; //String中的方法 public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); &#125; StringBuffer中append中的实现 调用super.append(str)， super类为AbstractStringBuilder AbstractStringBuilder.append(str)中通过调用String类的getChars()方法 String.getChars()，调用System.arraycopy()完成数组的复制 12345678 * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied.public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 本地方法的实现。 src原数组，srcPoc原数组起始位；dest目标数组，destPos目标数组起始位,length复制个数 1234int[] int1= &#123;1,2,3,4&#125;;int[] int2= &#123;10,11,12,13,14,15,16,17&#125;;System.arraycopy(int1, 0, int2, 0, 3);System.out.println(Arrays.toString(int2)); //out [1, 2, 3, 13, 14, 15, 16, 17] 参考 如何理解 String 类型值的不可变？","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"工具网站","slug":"工具网站","date":"2018-04-11T04:22:11.000Z","updated":"2018-04-13T05:39:01.256Z","comments":true,"path":"2018/04/11/工具网站/","link":"","permalink":"https://hsb786.github.io/2018/04/11/工具网站/","excerpt":"","text":"图标 画图 在线编码转换 HTTP状态码 Sql转Class","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"EasyUI","slug":"EasyUI","date":"2018-04-11T03:28:06.000Z","updated":"2018-04-13T03:36:44.401Z","comments":true,"path":"2018/04/11/EasyUI/","link":"","permalink":"https://hsb786.github.io/2018/04/11/EasyUI/","excerpt":"","text":"当请求远程数据时，发送的额外参数。 在datagrid构造中加入queryParams参数12345678dataGrid = $(&apos;#dg&apos;).datagrid(&#123; url : &apos;$&#123;pageContext.request.contextPath&#125;/companys/datagrid&apos;, method : &apos;GET&apos;, ......................... queryParams : &#123; //传入当前日期查询 startTime : getNowFormatDate() &#125;, 重新加载行，保持在当前页1$(&apos;#dg&apos;).datagrid(&apos;reload&apos;); 加载并显示第一页的行,通过传递一些从参数进行查询，该方法被调用来从服务器加载新数据。 1234$(&quot;#dg&quot;).datagrid(&apos;load&apos;, &#123; &quot;job.name&quot; : $(&quot;#jobname&quot;).val(), &quot;user.realname&quot; : $(&quot;#realname&quot;).val() &#125;);","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"KingEditor","slug":"KingEditor","date":"2018-04-11T03:22:23.000Z","updated":"2018-04-13T03:27:29.695Z","comments":true,"path":"2018/04/11/KingEditor/","link":"","permalink":"https://hsb786.github.io/2018/04/11/KingEditor/","excerpt":"","text":"官方文档示例 初始化；属于异步加载123KindEditor.ready(function(K) &#123; window.editor = K.create(&apos;#editor_id&apos;); &#125;); 同步加载；直接调用KindEditor创建，而不是等KindEditor.ready后再创建1234567891011about = KindEditor.create(&apos;textarea[id=&quot;about&quot;]&apos;, &#123; items : [ &apos;cut&apos;, &apos;copy&apos;, &apos;paste&apos;, &apos;justifyleft&apos;, &apos;justifycenter&apos;, &apos;justifyright&apos;, &apos;justifyfull&apos;, &apos;insertorderedlist&apos;, &apos;insertunorderedlist&apos;, &apos;indent&apos;, &apos;outdent&apos;, &apos;subscript&apos;, &apos;superscript&apos;, &apos;clearhtml&apos;, &apos;quickformat&apos;, &apos;selectall&apos;, &apos;|&apos;, &apos;fullscreen&apos;, &apos;/&apos;, &apos;formatblock&apos;, &apos;fontname&apos;, &apos;fontsize&apos;, &apos;|&apos;, &apos;forecolor&apos;, &apos;hilitecolor&apos;, &apos;bold&apos;, &apos;italic&apos;, &apos;underline&apos;, &apos;strikethrough&apos;, &apos;lineheight&apos;, &apos;removeformat&apos;, &apos;|&apos;, &apos;table&apos;, &apos;hr&apos;, &apos;emoticons&apos;, &apos;pagebreak&apos; ] &#125;);","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2018-04-10T12:27:44.000Z","updated":"2018-04-11T04:16:31.866Z","comments":true,"path":"2018/04/10/HTTP状态码/","link":"","permalink":"https://hsb786.github.io/2018/04/10/HTTP状态码/","excerpt":"HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。","text":"HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 status 含义 100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 在最新版的规范中，306状态码已经不再被使用。 307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 该状态码是为了将来可能的需求而预留的。 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 客户端应当切换到TLS/1.0。（RFC 2817） 449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 获取资源所需要的策略并没有没满足。（RFC 2774）","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"反转链表","slug":"反转链表","date":"2018-04-10T12:14:31.000Z","updated":"2018-04-12T05:27:41.953Z","comments":true,"path":"2018/04/10/反转链表/","link":"","permalink":"https://hsb786.github.io/2018/04/10/反转链表/","excerpt":"定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。","text":"定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。 1234567891011121314151617181920212223242526272829303132333435363738 /** * 维护两个节点，一个指向当前节点，一个指向下一个节点 * 缺点，需要new 对象，占用内存 * @author: husb * @date: 2018年4月10日 下午7:44:22 */private static ListNode reverseList(ListNode head) &#123; ListNode result = new ListNode(head.data); ListNode t; while (head.next != null) &#123; t = result; result = new ListNode(head.next.data); result.next = t; head = head.next; &#125; return result;&#125;/** * @Description: 需要维护三个节点，当前，前一个，下一个 * @author: husb * @date: 2018年4月10日 下午7:57:58 */private static ListNode reverseList2(ListNode head) &#123; ListNode result = null; ListNode t = head; ListNode preNode = null; while (t != null) &#123; ListNode nextNode = t.next; if (nextNode == null) &#123; result = t; &#125; t.next = preNode; preNode = t; t = nextNode; &#125; return result;&#125; 或者直接用Stack","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"Spring","slug":"Spring","date":"2018-04-10T09:58:41.000Z","updated":"2018-04-15T10:45:05.730Z","comments":true,"path":"2018/04/10/Spring/","link":"","permalink":"https://hsb786.github.io/2018/04/10/Spring/","excerpt":"Spring结构Spring框架的核心组件只有三个：Bean，Context，Core","text":"Spring结构Spring框架的核心组件只有三个：Bean，Context，Core Spring是面向Bean编程，自然Bean组件就是Spring对Java对象Object的封装，在Spring容器中管理的就是被Bean封装了的Java对象。 Context组件就是我们常说的IOC容器，也就是Spring容器。Context组件可以发现每个Bean之间的关系，为它们建立好Bean之间的依赖关系，为Bean提供生存环境。 Core组件，它是Context组件与Bean组件的工具包，可以把Core组件理解为Util工具包 总结来说，Bean组件解决Bean的定义，Bean的创建以及Bean的解析，例如在Spring配置文件中定义的节点，Spring会解析得到对应的BeanDefinition对象。Context组件提供了这些Bean的生存环境，保存各个Bean的状态。实际上Context组件结合Bean组件，Core组件共同建立了一个Bean的容器，就是我们接下来要介绍的IOC容器。 Spring容器Spring容器有时候也称为IOC容器。IOC: Inverse of Control，控制反转。控制：控制就是调用类对某一个接口具体实现类的选择控制权反转：选择控制权交给第三方决定，由Spring容器来统一配置管理Bean。 为了更好理解IOC，大家经常使用依赖注入来代替控制反转这个概念，即让调用类对某一接口的实现类的依赖关系由第三方容器注入，以移除调用类对某一接口实现类的依赖。那么IOC容器的工作就是通过配置文件和注解来描述类和类之间的依赖关系。利用反射机制完成类的初始化和依赖注入。 BeanFactory和ApplicationContextBeanFactory是Spring框架核心接口，提供了IOC的配置机制，是Spring的基础设施，面向Spring本身 ApplicationContext是建立在BeanFactory之上，提供了更多的面向应用的功能，是Spring给开发者提高了IOC容器接口 Bean的生命周期 如果在配置文件中声明了工厂后处理器接口BeanFactoryPostProcessor的实现类，那么在Spring容器装载配置文件之后，初始化Bean实例之前将调用这些BeanFactoryPostProcessor对配置信息进行加工处理。也就是说工厂后处理器是容器级别的，仅在容器初始化的时候调用一次，对配置文件进行加工 当我们通过getBean(String beanName)方法向容器请求某个Bean实例的时候，如果容器注册了InstantiationAwareBeanPostProcessor接口的实现类，那么在实例化Bean之前，将调用该接口的postProcessBeforeInstantiation()方法 实例化Bean 如果容器注册了InstantiationAwareBeanPostProcessor接口的实现类，那么在实例化Bean之后，将调用该接口的postProcessAfterInstantiation()方法 如果Bean配置了属性信息，那么容器在将属性值配置到Bean中之前，将调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()方法 为Bean设置属性值 如果Bean实现了BeanNameAware接口，那么就调用该接口的setBeanName()方法，将配置文件中该Bean对应的名称设置到Bean中 如果Bean实现了BeanFactoryAware接口，那么就调用该接口的setBeanFactory()方法，将BeanFactory容器实例设置到Bean中 如果Bean实现了ApplicationContextAware接口，那么就调用该接口的setApplicationContext()方法，将ApplicationContext容器实例设置到Bean中 如果BeanFactory装配了BeanPostProcessor接口的实现类，那么就调用该后处理器的postProcessBeforeInitialization(Object bean , String beanName)方法对Bean进行加工。其中，入参bean是当前正在处理的Bean，而beanName是当前Bean的配置名。开发者可以通过改方法对Bean进行特殊的改造，例如Spring提供的AOP功能就利用BeanPostPrecessor来实现 如果Bean实现了InitializingBean接口，那么就调用该接口的afterPropertiesSet()方法 如果在中通过init-method属性定义了初始化方法，那么就执行这个方法 这是工厂后处理器BeanPostProcessor接口定义的第二个方法，第一个方法在第10步执行了，该接口的postProcessAfterInitialization(Object bean , String beanName)方法给容器提供了再次对Bean进行加工的机会 如果在中配置的Bean的作用范围是scope=“prototype”，那么就直接将该Bean实例返回给调用者，这些Bean实例不再由Spring容器管理。如果scope=“singleton”，那么就缓存该Bean实例，再返回给调用者，同时Spring容器将继续管理缓存池中的Bean实例 对于scope=“singleton”(默认情况)的Bean，当容器关闭的时候，如果Bean实现了DisposableBean接口，那么就调用该接口的destroy()方法 对于scope=“singleton”(默认情况)的Bean，如果通过destroy-method属性配置的销毁方法，那么就调用该方法 上述16步描述了ApplicationContext管理的Bean的生命周期，其中的每一步都调用了相关的方法，主要有以下几类： Bean自身的方法：Bean的构造函数，Bean的Setter方法，以及init-method和destroy-method方法 Bean级生命周期接口方法：这些方法是Spring容器规定的，由Bean实现的方法，例如BeanNameAware接口，BeanFactoryAware接口，ApplicationContextAware接口，InitializingBean接口，DisposableBean接口 容器级生命周期接口方法：这些方法是容器来配置实现类的，无需Bean来实现，在流程图中用黑点标识的方法。由于是容器级别的后处理器，这些方法对容器中所有的Bean都起作用。 在ApplicationContext中，只需要在配置文件中通过定义工厂后处理器和Bean后处理器，容器就会按照预定的机制运行。以上就是Spring容器中管理的Bean的生命周期，并不是每一步都在实际中用到，但是这些生命周期体现了Spring容器对Bean的管理理念，提供给开发者足够的空间来自己控制Bean。 FactoryBean如果某些Bean的实例化过程比较复杂，如果按照XML或者注解来配置的话需要大量的配置信息，并且灵活性也受限制。Spring为了解决这一情况，提供了FactoryBean，我们可以通过实现该工厂接口来定制实例化Bean的逻辑。FactoryBean接口定义了3个方法： T getObject():返回由FactoryBean创建的Bean的实例。 boolean isSingleton():由FactoryBean创建的Bean是Singleton还是prototype Class&lt;?&gt; getObjectType():返回FactoryBean创建的Bean的类型 当配置文件中的类型是FactoryBean时，容器通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean.getObject()方法所返回的对象。Spring提供了FactoryBean接口给我们提供了自定义实例化Bean的方法，在某些复杂的情况下很有用处。 Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例 Spring IoC和AOPIoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 参考 Spring容器——面向Bean编程 面试总结","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"旋转数组的最小数字","slug":"旋转数组的最小数字","date":"2018-04-10T08:11:33.000Z","updated":"2018-04-12T05:27:51.508Z","comments":true,"path":"2018/04/10/旋转数组的最小数字/","link":"","permalink":"https://hsb786.github.io/2018/04/10/旋转数组的最小数字/","excerpt":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。","text":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。旋转数组的特点： 旋转之后的数组可以分为两个排序的子数组，且前面的子数组的元素都大于或等于后面子数组的元素。 最小或者最大元素位于两个子数组的分界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 由于旋转数组的特点，前一个数组一定大于后一个数组。数组内部是升序的。 * 所以就可以使用二分查找。 * 定义minIndex为0，highIndex为length-1 * 若中间位大于array[minIndex]，则代表中间位处于前面部分,将minIndex设为midIndex； * 小于则处于后面部分,将highIndex设为midIndex * 最终minIndex位于前一个数组的最后一位，highIndex位于后一个数组的第一位 * 显然最小值就是highIndex所在的值。 * 特殊情况，但minIndex与highIndex上的值相等时，无法判断中间值是在前，还是在后。 * 所以只能用顺序查找 * @author: husb * @date: 2018年4月10日 下午2:56:26 */public static int findMin(int[] array) &#123; int lowIndex = 0; int highIndex = array.length - 1; int midIndex = (lowIndex + highIndex) / 2; // 当代查找数组第一位大于最后一位时，代表是旋转数组 while (array[lowIndex] &gt;= array[highIndex]) &#123; // 临界条件 前面最后一位，后面第一位。 后面第一位就是最小值 if (highIndex - lowIndex == 1) &#123; return array[highIndex]; &#125; // 当左下标的元素等于右下标的元素时，无法判断中间位是位于前面还是后面的。 // 只能用顺序查找 if (array[lowIndex] == array[highIndex]) &#123; return findMinInOrder(array, lowIndex, highIndex); &#125; // 当中间位大于前面第一位时，代表处于前面 if (array[midIndex] &gt; array[lowIndex]) &#123; lowIndex = midIndex; &#125; else &#123; // 否则处于后面 highIndex = midIndex; &#125; // 计算中间位 midIndex = (lowIndex + highIndex) / 2; &#125; //已排好序，返回低位即可 return array[lowIndex];&#125;/** * @Description: 当有重复元素的时候，无法确定中间的元素是前面的还是后面的 * @author: husb * @date: 2018年4月10日 下午2:33:52 */private static int findMinInOrder(int[] array, int lowIndex, int highIndex) &#123; int result = array[lowIndex]; for (int i = lowIndex + 1; i &lt;= highIndex; i++) &#123; if (result &gt; array[i]) &#123; result = array[i]; &#125; &#125; return result;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"用两个队列实现一个栈","slug":"用两个队列实现一个栈","date":"2018-04-10T08:11:19.000Z","updated":"2018-04-12T05:28:03.670Z","comments":true,"path":"2018/04/10/用两个队列实现一个栈/","link":"","permalink":"https://hsb786.github.io/2018/04/10/用两个队列实现一个栈/","excerpt":"用两个队列实现一个栈","text":"用两个队列实现一个栈123456789101112131415161718192021222324252627282930313233343536373839404142/** * Queue方法: * offer() 添加一个元素，失败则返回false * pool() 移除并返回队列头部元素，无则返回null * peek() 返回头部元素 无则返回null */private static Queue&lt;Object&gt; queue1 = new LinkedList&lt;&gt;();private static Queue&lt;Object&gt; queue2 = new LinkedList&lt;&gt;();private static void push(Object obj) &#123; if (!queue1.isEmpty()) &#123; queue1.offer(obj); &#125; else &#123; queue2.offer(obj); &#125; System.out.println(&quot;入栈:&quot; + obj);&#125;/** * 将一个队列里的数据都剪切给另一个队列中，只保留最后一位。 * 这样弹出的数据就是栈尾数据 * @author: husb * @date: 2018年4月10日 下午1:55:11 */private static void pop() &#123; if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; System.out.println(&quot;栈里没有数据&quot;); return; &#125; if (queue1.isEmpty()) &#123; while (queue2.size() &gt; 1) &#123; queue1.offer(queue2.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue2.poll()); return; &#125; while (queue1.size() &gt; 1) &#123; queue2.offer(queue1.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue1.poll());&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"用两个栈实现队列","slug":"用两个栈实现队列","date":"2018-04-10T08:10:52.000Z","updated":"2018-04-12T05:27:59.328Z","comments":true,"path":"2018/04/10/用两个栈实现队列/","link":"","permalink":"https://hsb786.github.io/2018/04/10/用两个栈实现队列/","excerpt":"用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。","text":"用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。1234567891011121314151617181920212223242526272829private static Stack&lt;Object&gt; stack1 = new Stack&lt;Object&gt;();private static Stack&lt;Object&gt; stack2 = new Stack&lt;Object&gt;();/** * stack1用来存放压入的元素 * @author: husb * @date: 2018年4月10日 下午1:19:07 */public static void appendTail(Object item) &#123; stack1.push(item);&#125;public static void deleteHead() &#123; //当stack2中有数据，直接弹出 if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); return; &#125; else &#123; //stack2压入stack1弹出的数据,这样stack2就是一个队列 while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); &#125; else &#123; System.out.println(&quot;栈中没有元素&quot;); &#125;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"二维数组的查找","slug":"二维数组的查找","date":"2018-04-10T04:01:22.000Z","updated":"2018-04-12T05:26:43.517Z","comments":true,"path":"2018/04/10/二维数组的查找/","link":"","permalink":"https://hsb786.github.io/2018/04/10/二维数组的查找/","excerpt":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。","text":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122/** * 从左下角开始比，查找的数字大于遍历值右移；查找的数字小于遍历值上移 * @author: husb * @date: 2018年4月10日 上午11:55:27 */public static boolean find(int targer, int[][] array) &#123; int rows = array.length; int columns = array[0].length; int i = rows - 1, j = 0; while (targer != array[i][j]) &#123; if (targer &gt; array[i][j]) &#123; j++; &#125; else &#123; i--; &#125; if (i &lt; 0 || j &lt; 0 || i &gt; rows || j &gt; columns) &#123; return false; &#125; &#125; return true;&#125;","categories":[],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://hsb786.github.io/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"线程池","slug":"线程池","date":"2018-04-10T02:13:01.000Z","updated":"2018-04-15T12:12:25.244Z","comments":true,"path":"2018/04/10/线程池/","link":"","permalink":"https://hsb786.github.io/2018/04/10/线程池/","excerpt":"Executor框架Exexutor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，可以用来控制线程的启动、执行和关闭，可以简化并发编程的操作。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。Executor框架包括：线程池、Executor、Exexutors、ExecutorService、CompletionService、Future、Callable等。","text":"Executor框架Exexutor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，可以用来控制线程的启动、执行和关闭，可以简化并发编程的操作。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。Executor框架包括：线程池、Executor、Exexutors、ExecutorService、CompletionService、Future、Callable等。 关于Callable和FutureCallable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 Future提供了三种功能： 判断任务是否完成 能够中断任务 能够获取执行结果 Future对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后再需要时检查Future是否已经有了结果，如果任务已经执行完成，就可以通过Future.get()方法获得执行结果。需要注意的是，Future.get()方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。 FutureTask123456789public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTask既可以做为Runnable被线程执行，又可以作为Future得到Callable的返回值 ThreadPoolExecutor 参数 说明 corePoolSize 线程池中核心线程数量 maximumPoolSize 线程池中最大线程数量 keepAliveTime 非核心线程存活时间 unit keepAliveTime的时间单位 workQueue 存放任务的队列 threadFactory 用来生产线程的工厂 handler 当线程池中不能再放入任务时执行的handler 任务提交给线程池之后的处理策略： 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出来执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过KeepAliveTime，线程也会被终止 默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 任务缓存队列及排队策略workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue，通常可以取下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小 LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 锁优化 减少锁持有时间 可以使用同步代码块来代替同步方法。这样既可以减少锁持有的时间。 减少锁粒度 要在并发场景中使用Map的时候，记得使用ConcurrentHashMap来代替HashTable和HashMap。 锁分离 普通锁（如syncronized）会导致读阻塞写、写也会阻塞读，同时读读与写写之间也会进行阻塞，可以想办法将读操作和写操作分离开。 锁粗化 有些情况下我们希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。 锁消除 锁消除是Java虚拟机在JIT编译是，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。 参考 Java并发编程：线程池的使用 Java多线程之Callable接口及线程池 人人都能掌握的Java服务端性能优化方案 java锁优化的方法与思路-减少锁持有时间、减小锁粒度、锁分离、锁粗化、锁消除","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"java基础总结","slug":"java基础总结","date":"2018-04-09T13:28:54.000Z","updated":"2018-04-15T06:43:40.471Z","comments":true,"path":"2018/04/09/java基础总结/","link":"","permalink":"https://hsb786.github.io/2018/04/09/java基础总结/","excerpt":"初始化顺序 父类（静态变量，静态语句块） 子类（静态变量，静态语句块） 父类（实例变量，普通语句块） 父类（构造函数） 子类（实例变量，普通语句块） 子类（构造函数）","text":"初始化顺序 父类（静态变量，静态语句块） 子类（静态变量，静态语句块） 父类（实例变量，普通语句块） 父类（构造函数） 子类（实例变量，普通语句块） 子类（构造函数） Object123456789101112131415161718192021public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; 异常Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error用来表示JVM无法处理的错误，Exception分为两种： 受检异常（checked exception）：需要try…catch…语句捕获并进行处理，并且可以从一场恢复 非受检异常（unchecked exception）：是程序运行时错误，例如除0会引发Arithmetic Exceptino，此时程序崩溃并且无法恢复 创建对象的方式 直接new 反射 使用Class类的newInstance 只能调用无参构造函数 使用Constructor的newInstance 可以调用有参构造函数 clone 不会调用任何构造函数 反序列化 不会调用任何构造函数 动态获取类的方式 类名.class 对象名.getClass Class.forName(“类名”) 泛型将集合中的元素限定为一个特定的类型 java集合有一个缺点是当把一个对象放入集合里面之后，集合就会”忘记”这个对象的数据类型，当再次取出该对象的时候，该对象的编译类型就变成了Object类型(该对象的运行时类型没变)。 造成的问题： 集合对元素类型没有任何限制，这样会引发一些问题。例如，想创建一个保存Dog对象的集合，但是程序也可以轻易的把Cat对象保存进去，所以会引发异常。 由于把对象保存到集合里面时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此取出集合元素之后通常还需要进行强制类型转换。这种强制类型转换即增加了编程的复杂度，也可能引发类型转换ClassCastException异常。 在Java7以前，如果使用带有泛型的接口，类定义常量，那么调用构造器创建对象时构造器的后面也必须带泛型，这显得有些多余了。 从java7开始，java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号(&lt;&gt;)即可，Java可以推断括号里面应该是什么泛型信息。即上面两条语句可以改写成为如下的形式： 12List&lt;String&gt; strList=new ArrayList&lt;String&gt;();Map&lt;String,Integer&gt; scores=new HashMap&lt;String,Integer&gt;(); - 术语 ArrayList&lt;E> 泛型类型 ArrayList 原始类型 E 参数类型 &lt;&gt; 读作”typeof” ArrayList&lt;Intege\\r&gt; 参数化的类型 Integer 实际类型参数 “?” 通配符？表示任意类型，使用？通配符可以引用各种参数化的类型 限定通配符的上边界ArrayList&lt;? extends Number&gt; collection=new ArrayList(); 限定通配符的下边界ArrayList&lt;? super Integer&gt; collection=new ArrayList(); “擦除”泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。 多态存在的三个条件 有继承关系 子类重写父类方法 父类引用指向子类对象 以下三种类型的方法不能被重写： static方法。被static修饰的方法是属于类的，而不是属于实例的 final方法。被final修饰的方法是无法被子类重写 private方法。被private修饰的方法对子类不可见， 多态的分类 编译时多态，即方法的重载 运行时多态，即方法的重写 throw和throwsthrow: 表示抛出一个类的实例。throw关键字可以写在任何地方，并不强制必须写在catch块中，运行到throw所在的行，打印异常并立即退出当前方法。 throws: 用于方法声明，指明可能发生的异常。 ArrayListtransient Object[] elementData; 扩容1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 底层基于数组实现 插入和删除的时候，涉及到元素复制","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"多线程基础","slug":"多线程基础","date":"2018-04-09T13:03:41.000Z","updated":"2018-04-14T06:31:11.726Z","comments":true,"path":"2018/04/09/多线程基础/","link":"","permalink":"https://hsb786.github.io/2018/04/09/多线程基础/","excerpt":"线程间通信线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。","text":"线程间通信线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。 锁队列每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。 多线程对象的常用函数 Thread.currentThread()方法返回代码段正在被哪个线程调用的信息 Thread对象实例.isAlive()方法的功能是判断当前线程是否处于活跃状态(正在运行状态或者准备开始运行状态) Thread.sleep()方法的作用是在指定的毫秒数内让”当前执行的线程”休眠(暂停执行) getId()方法可以获取线程的唯一标识 yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。当放弃的时间不确定，有可能刚刚放弃，马上又获取CPU时间片。 对象锁何时会被释放 执行完同步代码块 在执行同步代码块的过程中，遇到异常而导致线程终止 在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池 如何判断线程是否处于停止状态 Thread.interrupted():测试当前线程是否已经中断，static方法，调用这个方法后线程的中断状态被清除。换句话说，如果连续２次调用该方法，则第二次调用将返回false。 this.isInterrupted():测试线程Thread对象实例是否已经中断，非static方法，不清除状态标识 调用interrupt()方法不会真的停止线程，而是在当前线程中打了一个停止的标记，还需要配合其他的代码来停止线程。 守护线程守护线程是一种特殊的线程，当进程中不存在非守护线程了，守护线程就自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。Deamon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。 对象及变量的并发访问“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是”脏读”，也就是取到的数据其实是被更改过的。而”线程安全”获得的实例变量的值是经过同步处理的，不会出现”脏读”的现象。 方法内的私有变量“非线程安全”问题存在于”实例变量”，如果是方法内部的私有变量，则不存在”非线程安全”问题，永远都是线程安全的，这是方法内部的变量是私有(作用域)的特性造成的。 锁关键字synchronized取得的锁都是对象锁，而不是把一段代码或者方法(函数)当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈现等待状态，前提是多个线程访问的是同一个对象。如果多个线程访问多个对象，则JVM会创建多个锁。 “可重入锁”:当有一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当这个线程再次想要获得这个对象的锁的时候还是可以获取的。特别的说明，当存在父子类继承关系时，子类是完全可以通过”可重入锁”调用父类的同步方法的。 静态同步synchronized方法与synchronized(class)代码块关键字synchronized还可以应用在static静态方法上，如果这样写，那是对当前的.java文件对应的Class类进行持锁。synchronized关键字加到static静态方法上是给Class类上锁，可以对类的所有对象实例起作用，而synchronized关键字加到非static静态方法上是给对象上锁，这2个锁不是同一个锁。synchronized(class)代码块的作用其实和synchronized static方法的作用一样。我们需要注意的是，synchronized(ClassName)与synchronized(ClassName的实例)，线程各自获取各自的锁，不会有等待。 注意:我们在将任何数据类型作为同步锁时，需要观察，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，就是异步的。 volatile关键字volatile的主要作用是使变量在多个线程间可见。简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动。同时关键字synchronized也可以同样的完成volatile关键字可见性的功能。(happens-before) ThreadLocal类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。 类Threadlocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入Threadlocal类中进行保存的。 公平锁与非公平锁公平与非公平锁：锁Lock分为”公平锁”和”非公平锁”，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果就是不公平的了。默认情况下，ReentrantLock类使用的是非公平锁。 ReentrantReadWriteLock类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用它可以加快运行效率。 读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的线程Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。 简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ReadWriteLock &#123; private int readThreadCounter = 0; // 正在读取的线程数（0个或多个） private int waitingWriteCounter = 0; // 等待写入的线程数（0个或多个） private int writeThreadCounter = 0; // 正在写入的线程数（0个或1个） private boolean writeFlag = true; // 是否对写入优先（默认为是） // 读取加锁 public synchronized void readLock() throws InterruptedException &#123; // 若存在正在写入的线程，或当写入优先时存在等待写入的线程，则将当前线程设置为等待状态 while (writeThreadCounter &gt; 0 || (writeFlag &amp;&amp; waitingWriteCounter &gt; 0)) &#123; wait(); &#125; // 使正在读取的线程数加一 readThreadCounter++; &#125; // 读取解锁 public synchronized void readUnlock() &#123; // 使正在读取的线程数减一 readThreadCounter--; // 读取结束，对写入优先 writeFlag = true; // 通知所有处于 wait 状态的线程 notifyAll(); &#125; // 写入加锁 public synchronized void writeLock() throws InterruptedException &#123; // 使等待写入的线程数加一 waitingWriteCounter++; try &#123; // 若存在正在读取的线程，或存在正在写入的线程，则将当前线程设置为等待状态 while (readThreadCounter &gt; 0 || writeThreadCounter &gt; 0) &#123; wait(); &#125; &#125; finally &#123; // 使等待写入的线程数减一 waitingWriteCounter--; &#125; // 使正在写入的线程数加一 writeThreadCounter++; &#125; // 写入解锁 public synchronized void writeUnlock() &#123; // 使正在写入的线程数减一 writeThreadCounter--; // 写入结束，对读取优先 writeFlag = false; // 通知所有处于等待状态的线程 notifyAll(); &#125;&#125; Java多线程学习笔记 Lock 那点事儿","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"术语","slug":"术语","date":"2018-04-09T05:53:41.000Z","updated":"2018-04-15T06:22:46.867Z","comments":true,"path":"2018/04/09/术语/","link":"","permalink":"https://hsb786.github.io/2018/04/09/术语/","excerpt":"happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 需要注意的是，上面提到的两个操作可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作可见","text":"happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 需要注意的是，上面提到的两个操作可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作可见 happends-before规则 程序顺序规则： 单个线程中的每个操作，happens-before于该线程中的任意后续操作 监视器锁规则： 对一个锁的解锁，happens-before于随后对这个锁的加锁 volatile变量规则： 对一个volatile变量的写，happends-before于任意后续对这个volatile变量的读 传递性： 如果A happeens-before B，且 B happeend-before C，那么A happeens-before C join规则： 如果线程A执行操作ThreadB.join()成功返回，那么线程B中的任意操作happeens-before与线程A从ThreadB.join()操作成功返回 fail-fastfail-fast机制是java集合(Collection)中的一种错误机制。当多个线程对同一集合的内容进行操作时，就可能会产生fail-fast事件。 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件 要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常 当使用fail-fast iterator对Collection或对Map进行操作过程中尝试直接修改Collection/Map的内容时，即使是在单线程下运行，java.util.ConcurrentModificationException异常也将抛出 Iterator是工作在一个独立的线程，并且拥有一个mutex锁。Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来对象发生变化时，这个索引表的内容不会同步该表，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照fail-fast原则Iterator会马上抛出ConsurrentModificationException异常。 所以Iterator在工作的时候是不允许被迭代的对象被改变的。但你可以使用Iterator本身的方法remove()来删除对象，Iteraror.remove()方法会在删除当前迭代对象的同时维护索引的一致性。 fail-safe 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 数据库三大范式 1NF：字段不可再分 2NF：主键依赖，一张表里的数据，必须是跟主键相关的 3NF：任意两个表不能出现重复的非主键字段 设计模式六大原则单一职责(Single Responsibility Principle)：一个类只负责一个功能领域中的相应职责 开闭(Open-Closed Principle)：对扩展开放，对修改关闭 里氏替换(Liskov Subsitution Principle)：子类能出现在基类出现的地方 依赖倒置(Dependency Inversion Principle)：针对接口编程，而不是针对实现类编程 接口隔离(Interface Segregation Principle)：使用多个专门的接口，而不使用单一的总接口 迪米特(Law of Demeter)：一个类尽可能少的与其它类发生相互作用 分布式领域CAP理论Consistency(一致性)：数据一致更新，所有数据变动都是同步的 Availability(可用性)：好的响应性能 Partition tolerance(分区容忍性)：可靠性 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 强一致性,弱一致性,最终一致性强一致性 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。 弱一致性 系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。 最终一致性 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。 假唤醒(spurious wake up)Linux中帮助中提到的：在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。 结果是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应成为”虚假唤醒”(spurious wakeup) 虽然虚假唤醒在pthread_cond_wait函数中可以解决，为了发生概率很低的情况而降低边缘条件（fringe condition）效率是不值得的，纠正这个问题会降低对所有基于它的所有更高级的同步操作的并发度。所以pthread_cond_wait的实现上没有去解决它。 所以通常的标准解决办法是这样的：将条件的判断从if 改为while pthread_cond_wait中的while()不仅仅在等待条件变量前检查条件变量，实际上在等待条件变量后也检查条件变量。 这样对condition进行多做一次判断，即可避免“虚假唤醒”. 这就是为什么在pthread_cond_wait()前要加一个while循环来判断条件是否为假的原因。 PO(persistant object) 持久对象在 o/r 映射的时候出现的概念，如果没有 o/r 映射，没有这个概念存在了。通常对应数据模型 ( 数据库 ), 本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的 java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。一般和数据中的表结构对应。 TO(Transfer Object) ，数据传输对象在应用程序不同 tie( 关系 ) 之间传输的对象 DTO（Data Transfer Object）数据传输对象这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 VO(view object) 值对象视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 BO(business object) 业务对象从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。 POJO(plain ordinary java object) 简单无规则 java 对象纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法！。 DAO(data access object) 数据访问对象是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作 设计模式分类设计模式分为三种类型，共23种。 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 23种设计模式简单介绍Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。 Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。 Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。 State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。","categories":[],"tags":[{"name":"术语","slug":"术语","permalink":"https://hsb786.github.io/tags/术语/"}]},{"title":"记录一些容易忘记的东西","slug":"记录一些容易忘记的东西","date":"2018-04-09T00:42:41.000Z","updated":"2018-04-15T10:37:44.365Z","comments":true,"path":"2018/04/09/记录一些容易忘记的东西/","link":"","permalink":"https://hsb786.github.io/2018/04/09/记录一些容易忘记的东西/","excerpt":"接口不可以实现接口，可以继承多个接口 抽象类可以继承具体类 static不能被重写，重写是运行时动态绑定的 static变量发生在静态解析阶段，此时已经将字段的符号引用转换成了内存引用，将它与对应的类关联在了一起","text":"接口不可以实现接口，可以继承多个接口 抽象类可以继承具体类 static不能被重写，重写是运行时动态绑定的 static变量发生在静态解析阶段，此时已经将字段的符号引用转换成了内存引用，将它与对应的类关联在了一起子类构造方法默认会寻找父类无参构造方法，若没有，编译不通过 关于抽象类JDK 1.8以前，抽象类的方法默认访问权限为protectedJDK 1.8时，抽象类的方法默认访问权限变为default 关于接口JDK 1.8以前，接口中的方法必须是public的JDK 1.8时，接口中的方法可以是default，还可以是staticJDK 1.9时，接口中的方法可以是private的 volatile 禁止指令重排序： 添加内存屏障，保证前面已经完成，后面都没开始（happens-before） 内部类访问外部类 外部类.this.成员XX 重载静态绑定，根据参数的静态类型而不是实际类型作为判断依据的 java的8中基本类型，除了float和double之外，其它6种都实现了常量池 boolean类型不允许进行任何类型的转换处理 java7以后，常量池被放入到堆空间中。导致intern()函数的功能不同。intern()检查常量池时候存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用 ArrayList 默认容量 10 HashMap 16 newInstance 低效率，只能调用无参构造。将new这个方式分解为两步： 首先调用class的加载方式加载某个类，然后实例化 HashSet底层借用HashMap，利用HashMap中key不重复的特性 12345private static final Object PRESENT=new Object(); public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 字符只有在内存中才会形成，其它都是以字节的方式进行的 强引用： Object obj=new Object()，只要引用还在，就不会被回收软引用： 内存不够才会被回收弱引用： 下一次垃圾收集器工作时会被回收。虚引用： 随时可能被回收，目的是能在这个对象被回收时收到一个系统通知 内加载器： JVM动态加载所需的类。 委托、可见、单一。双亲委派，交给父加载器；父加载器加载的类子加载器都能看到；一个类只能被一个加载一次 每个对象有两个队列： 就绪队列、阻塞队列 ReentrantLock结合Condition可以有选择性地进行通知，在调度上更加灵活 指令重排序： 编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段 null可以强制转换为任何java类类型；其返回值还是null，可以调用static方法 基本类型与包装类比较；包装类拆箱，进行值比较 子类，也叫导出类、派生类 Math.round() +0.5Math.ceil() 向上取整Math.floor() 向下取整 类变量有默认值，局部变量是没有默认值的 wait，sleep都必须进行异常捕获 IllegalMonitorStateException 抛出该异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器，然而本身没有指定的监视器的线程。 也就是当前的线程不是此对象监视器的所有者。当前线程要锁定该对象之后，才能用锁定的对象执行这些方法，这里需要用到synchronized关键字，锁定哪个对象就用哪个对象来执行notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException异常。 1234567891011121314151617181920enum AccountType&#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125;class EnumOne&#123; public static void main(String[]args) &#123; System.out.println(AccountType.FIXED); &#125;&#125;//output It is a account typeIt is a account typeIt is a account type 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中： private AccountType(){ System.out.println(“It is a account type”); } 会变成： private AccountType(String s, int i){ super(s,i); System.out.println(“It is a account type”); } 而在这个类中，会添加若干字段来代表具体的枚举类型： 123456public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT; ~~~ 而且还会添加一段static代码段： static{ SAVING = new AccountType(“SAVING”, 0); … CURRENT = new AccountType(“CURRENT”, 0); $VALUES = new AccountType[]{ SAVING, FIXED, CURRENT } } ~~~ 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 Java的跨平台特性是指它的字节码可以在多个平台上运行","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"区别","slug":"区别","date":"2018-04-08T23:48:41.000Z","updated":"2018-04-15T06:06:18.932Z","comments":true,"path":"2018/04/09/区别/","link":"","permalink":"https://hsb786.github.io/2018/04/09/区别/","excerpt":"sleep和wait区别 sleep是Thread类的static方法； wait是Object类的方法 sleep睡眠时保持对象锁； wait释放锁 sleep可以放在任何地方； wait必须放在synchronized block中，否则会在runtime时扔出IllegalMonitorStateExcetion异常","text":"sleep和wait区别 sleep是Thread类的static方法； wait是Object类的方法 sleep睡眠时保持对象锁； wait释放锁 sleep可以放在任何地方； wait必须放在synchronized block中，否则会在runtime时扔出IllegalMonitorStateExcetion异常 synchronized和volatile区别 volatile是线程同步的轻量级实现，性能比synchronized好 volatile只能修饰变量； synchronized可修饰方法和代码块 volatile能保证数据可见性，不保证原子性； synchronized可以保证原子性，也可以间接保证可见性。synchronized会将私有内存和公共内存中的数据进行同步 volatile解决的是变量在多个线程间的可见性； synchronized解决的是多个线程访问资源的同步性 内部类在类中定义一个类(私有内部类，静态内部类)在方法中定义一个类(局部内部类，匿名内部类) 私有内部类编译器做的手脚 在内部类中创建了包可见构造器，从而使外部类获得了创建权限 在外部类中创建了访问私有变量的静态方法，从而使内部类获得了范围权限 静态内部类只能访问其外部类的静态成员 局部内部类没有修饰符，局部内部类只能范围该方法中的局部变量，并且这些局部变量一定要是final修饰的常量或者隐含是final的(java8) 匿名内部类不能抽象；仅能被使用一次；不能存在静态成员变量和方法 只有静态内部类可以访问静态成员变量 Session和Cookie的区别 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 客户端传JSESSIONID，服务端就可以通过这个ID，来将存储到服务端的数据取出 Servlet和Filter的区别 Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对响应的数据进行后处理。 强、软、弱、虚引用强引用 Object obj=new Object()，只要引用还在，就不会被回收软引用 内存不够才会被回收弱引用 下一次垃圾收集器工作时会被回收。虚引用 随时可能被回收，目的是能在这个对象被回收时收到一个系统通知。 垃圾回收期是一个优先级较低的线程，并不一定能迅速发现弱引用对象 HashMap和Hashtable的区别先吐槽一下Hashtable的命名，为啥t要小写 Hashtable是线程安全的； HashMap不是 Hashtable不允许有null的KV； HashMap允许 Hashtable继承Dictionary类； HashMap继承AbstractMap HashMap有一个子类LinkedHashMap，对这个类对象进行迭代时，它的顺序是有序的。可以轻易的将LinkedHashMap转换成HashMap； Hashtable不好实现 相同点：都实现了Map接口 join和synchronized的区别join在内部使用wait()方法进行等待；synchronized使用的是对象监视器原理作为同步 join和sleep的区别join底层调用wait方法，执行到wait释放锁sleep在睡眠时不释放锁 JDK动态代理和CGLIB代理的区别 JDK动态动态代理是利用反射机制生存一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类 CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。 重载和重写的区别重载： 方法有同样的名称，但是参数列表不同 重写：在java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法 区别 重载 重写 编译期概念，遵循“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法 运行期概念，遵循“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法 方法签名必须不同 方法签名必须一样 返回类型可以不同 返回类型必须相同 无限制 更好的访问，不能抛出更广泛的异常（遵循里式替换原则） 组合与继承的区别和联系在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；) 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法） 继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。） 组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。 优缺点对比 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 如何选择 继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。&lt;&lt;java编程思想&gt;&gt; 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。&lt;> Compareable和ComparatorComparable：一个实现了Comparable接口的类，可以让其自身的对象和其它对象进行比较。也就是说，同一个类的对象之间要想比较，对应的类就要实现Compareable接口，并实现compareTo()方法。 Comparator：不改变原有的类。通过定义一个类实现Comparator接口，重写compare()方法。 Comparator通常用于排序。Java中的Collectinos和Arrays都包括排序的sort方法，该方法可以接受一个Comparator的实例(比较器)来进行排序；new TreeSet&lt;&gt;(new Comparator()) getAttribute和getParameter的区别ServletRequest接口中提供了getAttribute和getParameter两个方法，都是用于获取参数（属性）值的，那么这两个方法有什么区别呢？或者说Attribute和Parameter的区别是什么呢？ 来源不同 参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的； 属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的. 操作不同 参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取； 属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute() 数据类型不同 参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。 属性（attribute）的值可以是任意一个Object类型。 forward和include的区别void forward(ServletRequest request, ServletResponse response) – 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。 void include(ServletRequest request, ServletResponse response) – 把另一个资源的内容包含到当前响应中。 如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。 用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"hash（转载）","slug":"hash（转载）","date":"2018-04-08T13:23:41.000Z","updated":"2018-04-15T05:49:44.734Z","comments":true,"path":"2018/04/08/hash（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/08/hash（转载）/","excerpt":"Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。","text":"Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。 常见的Hash函数有以下几个： 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种： 开放定址法： 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 参考 全网把Map中的hash()分析的最透彻的文章，别无二家。","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"事务","slug":"事务","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-14T07:56:31.393Z","comments":true,"path":"2018/04/08/事务/","link":"","permalink":"https://hsb786.github.io/2018/04/08/事务/","excerpt":"事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。在计算机术语中，事务通常就是指数据库事务。","text":"事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。在计算机术语中，事务通常就是指数据库事务。 概念一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包括有以下两个目的 为数据库提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离的方法，以防止彼此的操作互相干扰。 当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。 但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。 特性并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 原子性是基础，隔离性是手段，持久性是目的，最重要的是一致性 脏读，不可重复读，幻读Dirty Read（脏读）：又称无效数据的读出。指一个事务对数据进行了修改，还没有提交到数据库中，另外一个事务访问并使用了该数据。由于这个数据还没有提交，所以另外一个事务读到的这个数据是脏数据。 时间 事务A（存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 查询余额（1000 元） T4 取出 1000 元（余额 0 元） T5 查询余额（0 元） T6 撤销事务（余额恢复为 1000 元） T7 存入 500 元（余额 500 元） T8 提交事务 Unrepeatable Read（不可重复读）：一个事务范围内对两个相同的查询却返回了不同数据。这是因为其它事务修改的提交而引起的。 时间 事务A（存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 查询余额（1000 元） T4 查询余额（1000 元） T5 取出 1000 元（余额 0 元) T6 提交事务 T7 查询余额（0 元) Phantom Read（幻读）：指当事务不是独立执行时发生的一种现象。例如第一个事务涉及到表中全部数据行的修改，另一个事务添加了一行新数据，那么执行第一个事务后，发现表中还有没有被修改的数据行。 时间 事务 A（统计总存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 统计总存款（10000 元） T4 存入 100 元 T5 提交事务 T6 统计总存款（10100 元） 银行工作人员，每次统计总存款，都看到不一样的结果。不过这也确实也挺正常的，总存款增多了，肯定是这个时候有人在存钱。但是如果银行系统真的这样设计，那算是玩完了。这同样也是事务没有隔离所造成的，但对于大多数应用系统而言，这似乎也是正常的，可以理解，也是允许的。银行里那些恶心的那些系统，要求非常严密，统计的时候，甚至会将所有的其他操作给隔离开，这种隔离级别就算非常高了（估计要到 SERIALIZABLE 级别了）。 归纳 脏读：事务 A 读取了事务 B 未提交的数据，并在这个基础上又做了其他操作。 不可重复读：事务 A 读取了事务 B 已提交的更改数据。 幻读：事务 A 读取了事务 B 已提交的新增数据。 第一条是坚决抵制的，后两条在大多数情况下可不作考虑。 隔离级别 未提交读(Read uncommitted)：一个事务可以读取另一个事务未提交的数据 提交读(Read committed)：在一个事务修改数据过程中，其它事务不能读该数据 数据库锁情况 事务对当前读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。 可重复读(Repeatable reads)：解决不可重复读的问题 数据库锁情况 事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放 事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放 序列化(Serializable)：最高的隔离级别 数据库锁情况 事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放 事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放 事务隔离级别 脏读 不可重复读 幻读 READ_UNCOMMITTED 允许 允许 允许 READ_COMMITTED 禁止 允许 允许 REPEATABLE_READ 禁止 禁止 允许 SERIALIZABLE 禁止 禁止 禁止 隔离级别越高，同时在并发性上也越低 我们知道 JDBC 只是连接 Java 程序与数据库的桥梁而已，那么数据库又是怎样隔离事务的呢？其实它就是“锁”这个东西。当插入数据时，就锁定表，这叫“锁表”；当更新数据时，就锁定行，这叫“锁行”。 除了 JDBC 给我们提供的事务隔离级别这种解决方案以外，还有哪些解决方案可以完善事务管理功能呢？ 不妨看看 Spring 的解决方案吧，其实它是对 JDBC 的一个补充或扩展。它提供了一个非常重要的功能，就是：事务传播行为（Transaction Propagation Behavior）。 事务传播行为（Transaction Propagation Behavior） PROPAGATION_REQUIRED RROPAGATION_REQUIRES_NEW PROPAGATION_NESTED PROPAGATION_SUPPORTS PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_MANDATORY 首先要明确的是，事务是从哪里来？传播到哪里去？答案是，从方法 A 传播到方法 B。Spring 解决的只是方法之间的事务传播，那情况就多了，比如: 方法 A 有事务，方法 B 也有事务。 方法 A 有事务，方法 B 没有事务。 方法 A 没有事务，方法 B 有事务。 方法 A 没有事务，方法 B 也没有事务。 假设事务从方法 A 传播到方法 B，您需要面对方法 B，问自己一个问题： 方法 A 有事务吗？ 如果没有，就新建一个事务；如果有，就加入当前事务。这就是 PROPAGATION_REQUIRED，它也是 Spring 提供的默认事务传播行为，适合绝大多数情况。 如果没有，就新建一个事务；如果有，就将当前事务挂起。这就是 RROPAGATION_REQUIRES_NEW，意思就是创建了一个新事务，它和原来的事务没有任何关系了。 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。这就是 PROPAGATION_NESTED，也就是传说中的“嵌套事务”了，所嵌套的子事务与主事务之间是有关联的（当主事务提交或回滚，子事务也会提交或回滚）。 如果没有，就以非事务方式执行；如果有，就使用当前事务。这就是 PROPAGATION_SUPPORTS，这种方式非常随意，没有就没有，有就有，有点无所谓的态度，反正我是支持你的。 如果没有，就以非事务方式执行；如果有，就将当前事务挂起。这就是 PROPAGATION_NOT_SUPPORTED，这种方式非常强硬，没有就没有，有我也不支持你，把你挂起来，不鸟你。 如果没有，就以非事务方式执行；如果有，就抛出异常。这就是 PROPAGATION_NEVER，这种方式更猛，没有就没有，有了反而报错，确实够牛的，它说：我从不支持事务！ 如果没有，就抛出异常；如果有，就使用当前事务。这就是 PROPAGATION_MANDATORY，这种方式可以说是牛逼中的牛逼了，没有事务直接就报错，确实够狠的，它说：我必须要有事务！ Spring 给我们带来了事务传播行为，这确实是一个非常强大而又实用的功能。除此以外，也提供了一些小的附加功能，比如： 事务超时（Transaction Timeout）：为了解决事务时间太长，消耗太多的资源，所以故意给事务设置一个最大时常，如果超过了，就回滚事务。 只读事务（Readonly Transaction）：为了忽略那些不需要事务的方法，比如读取数据，这样可以有效地提高一些性能。 锁的分类按锁级别划分：共享锁(Share Lock) 又称读锁，是读取操作创建的锁。其它用户可以并发读取数据，但任何事务都不能对数据进行修改，直到已释放所有共享锁 如果事务T对数据A加上共享锁后，则其它事务只能对A再加共享锁，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据 用法 select … LOCK IN SHARE MODE， 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其它线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据 排他锁(eXclusive Lock) 又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。获取排他锁的事务既能读数据，又能修改数据 用法 select … FOR UPDATE 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞 按锁的粒度划分行级锁 对当前操作的行进行加锁。加锁粒度最小，但加锁的开销最大。行级锁分为共享锁和排他锁 特点 开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁 特点 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 Innodb中的行锁与表锁 InnoDB行锁是通过给索引上的索引项加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 行级锁与死锁 在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。 当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。 常见的三种解决死锁的方法 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率 按使用方式划分悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 在数据库中，悲观锁的流程如下： 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 悲观锁，就是总觉得有刁民想害朕，每次访问数据的时候都觉得会有别人修改它，所以每次拿数据时都会上锁，确保在自己使用的过程中不会被他人访问。乐观锁就是很单纯，心态好，所以每次拿数据的时候都不会上锁，只是在更新数据的时候去判断该数据是否被别人修改过。(阿姨真有意思) 大多数的关系数据库写入操作都是基于悲观锁，缺点在于如果持有锁的客户端运行的很慢，那么等待解锁的客户端被阻塞的时间就越长。Redis的事务是基于乐观锁的机制，不会在执行WATCH命令时对数据进行加锁，只是会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端。乐观锁适用于读多写少的情况，因为在写操作比较频繁的时候，会不断地retry，从而降低性能。 参考 数据库 面试总结 Transaction 那点事儿","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"},{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"值传递和引用传递","slug":"值传递和引用传递","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-12T10:43:16.657Z","comments":true,"path":"2018/04/08/值传递和引用传递/","link":"","permalink":"https://hsb786.github.io/2018/04/08/值传递和引用传递/","excerpt":"值传递 指在调用函数时将实际参数复制一份传递到函数中，那么在函数中对参数所进行的修改，将不会影响到实际参数。 引用传递 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。","text":"值传递 指在调用函数时将实际参数复制一份传递到函数中，那么在函数中对参数所进行的修改，将不会影响到实际参数。 引用传递 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。求值策略 | 求值时间 | 求值方式 | 根本区别—|—|—|—值传递 | 调用前 | 值的结果（原值的副本）| 会创建副本引用传递 | 调用前 | 原值（原始对象，无副本）| 不创建副本 值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份到形参 java只有值传递，不存在引用传递 java在传递引用类型数据时，把实际参数的内存地址复制了一份，传递给了形参","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"一些小技巧","slug":"一些小技巧","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-15T05:44:54.198Z","comments":true,"path":"2018/04/08/一些小技巧/","link":"","permalink":"https://hsb786.github.io/2018/04/08/一些小技巧/","excerpt":"位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快 X % 2^n = X &amp; (2^n-1)","text":"位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快 X % 2^n = X &amp; (2^n-1) 判段一个数组是否包含某个值12Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(arr)); return set.contains(targetValue); 效率慢，要将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其它操作。 可以使用Apache Commons类库中提供的ArrayUtils类的contains方法contains内部调用indexOf方法 123456789101112131415161718192021222324252627282930public static boolean contains(Object[] array, Object objectToFind) &#123; return indexOf(array, objectToFind) != INDEX_NOT_FOUND;&#125;public static int indexOf(Object[] array, Object objectToFind) &#123; return indexOf(array, objectToFind, 0);&#125;public static int indexOf(Object[] array, Object objectToFind, int startIndex) &#123; if (array == null) &#123; return INDEX_NOT_FOUND; &#125; if (startIndex &lt; 0) &#123; startIndex = 0; &#125; if (objectToFind == null) &#123; for (int i = startIndex; i &lt; array.length; i++) &#123; if (array[i] == null) &#123; return i; &#125; &#125; &#125; else if (array.getClass().getComponentType().isInstance(objectToFind)) &#123; for (int i = startIndex; i &lt; array.length; i++) &#123; if (objectToFind.equals(array[i])) &#123; return i; &#125; &#125; &#125; return INDEX_NOT_FOUND;&#125; 整数二进制表示中1的个数 123456int count=0;while(n!=0) &#123; //将二进制表示中的最低位的1变为0 n=n&amp;(n-1); count++;&#125;","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"防止重复发送 Ajax 请求的解决方案","slug":"防止重复发送 Ajax 请求的解决方案","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-12T10:48:59.497Z","comments":true,"path":"2018/04/08/防止重复发送 Ajax 请求的解决方案/","link":"","permalink":"https://hsb786.github.io/2018/04/08/防止重复发送 Ajax 请求的解决方案/","excerpt":"连续点击多个按钮，可能导致先请求的数据后显示出来。 解决方案 1. 将ajax请求的async设置为false 2. 利用jquery ajaxPrefilter中断请求 3. 加遮罩框","text":"连续点击多个按钮，可能导致先请求的数据后显示出来。 解决方案 1. 将ajax请求的async设置为false 2. 利用jquery ajaxPrefilter中断请求 3. 加遮罩框12345678910111213141516171819var pendingRequests = &#123;&#125;;$.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if ($.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;;&#125;); 核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清楚，这就保证了在任一时刻只能有一个同样的请求发送 局限性：仅对jquery的ajax有作用 参考 防止重复发送 Ajax 请求的解决方案","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-12T10:40:40.410Z","comments":true,"path":"2018/04/08/SpringMVC/","link":"","permalink":"https://hsb786.github.io/2018/04/08/SpringMVC/","excerpt":"SpringMVC工作流程SpringMVC是一种基于Servelt的技术，它提供了控制器DispatchServlet和相关组件，这些SpringMVC的组件一起协调工作，完成对web请求的相应。","text":"SpringMVC工作流程SpringMVC是一种基于Servelt的技术，它提供了控制器DispatchServlet和相关组件，这些SpringMVC的组件一起协调工作，完成对web请求的相应。 客户端发出一个HTTP请求，Web服务器接收到这个请求。服务器检查HTTP请求的路径，如果匹配DispatchServelt的请求映射路径(web.xml中指定)，则Web容器将该请求转交给对应的DispatchServlet处理 DispatchServlet接收到这个请求后，将根据请求的信息以及HandlerMapping配置找到处理请求的处理器（Handler）。HandlerMapping可以简单理解为统一资源标识符URL域与处理器Handler之间的关系。 找到对应的处理器之后，通过HandlerAdapter对Handler进行封装，再以同一的适配器接口调用Handler。因为为了更加灵活的编码和AOP增强功能，SpringMVC会给处理器加入拦截器，这样就可以在处理器执行前后加入执行前后加入自己的代码，于是就构成了一个处理器的执行链，所以SpringMVC提供了处理器适配器HandlerAdapter，帮助我们运行相应的处理器以及我们添加进去的拦截器。 处理器完成了请求的业务逻辑之后将返回一个ModelAndView对象给DIspatcherServlet，这里ModelAndView包含了视图的逻辑名和模型数据信息。 得到了ModelAndView之后，DispatchServlet借助ViewResolver视图解析器将逻辑试图转换为真实视图。 通过ViewResolver视图解析器得到了真实视图后，DispatServlet使用这个真实视图对象对ModelAndView中的模型数据进行渲染。 最终DispatchServlet将渲染过后的视图对象返回给请求的客户端，客户端得到的响应可能是一个普通的HTML页面，也可能是一个JSON串，甚至是一张图片等等不同的视图模型。 另一个说法 DispatcherServlet是什么它是Spring MVC的核心。每个由Spring MVC处理的请求都要经过DispatcherServlet。一般而言，它是前端控制器模式的实现，为应用提供一个统一入口。DispatcherServlet是连接Java与Spring的桥梁，处理所有传入的请求。并且与其他声明在web.xml中的Servlet一样，也是通过一个URL pattern将每个请求映射到DispatcherServlet。DispatcherServlet负责将请求委派给Spring MVC中其他的组处件理，比如注有@Controller或@RestController的Controller类，HandlerMappers（处理映射），View Resolvers(视图解析器)等等。 尽管，请求映射是由 @ResquestMapping 注解完成的，但实际上是由 DispatcherServlet 将请求委派给相应的 Controller 来处理的。 DispatcherServlet如何处理请求正如上面所说，DispatcherServlet 被用来处理所有传入的请求，并将它们路由到不同的 Controller 来进行进一步处理。它决定了由哪个 Controller 处理请求。 DispatcherServlet 使用处理器映射来将传入的请求路由到处理器。默认情况下，使用 BeanNameUrlHandlerMapping 和 由 @RequestMapping 注解驱动的DefaultAnnotationHandlerMapping。 为了找到正确的方法来处理请求，它会扫描所有声明了 @Controller 注解的类，并且通过 @RequestMapping 注解找到负责处理该请求的方法。@RequestMapping 注解可以通过路径来映射请求(比如: @RequestMapping(“path”)), 也可以通过 HTTP 方法(比如: @RequestMapping(“path”, method=RequestMethod.GET)), 也可以通过请求参数(比如: @RequestMapping(“path””, method=RequestMethod.POST, params=”param1”)),还可以通过 HTTP 请求头(比如: @RequestMapping(“path”, header=”content-type=text/*”))。我们也可以在类级别声明 @RequestMapping 注解来过滤传入的请求。 在请求处理之后，Controller 会将逻辑视图的名字和 model 返回给 DispatcherServlet。之后利用视图解析器定位到真正的 View 以便渲染结果。我们可以指定使用的视图解析器，默认情况下，DispatcherServlet 使用 InternalResourceViewResolver来将逻辑视图的名字转换成真正的视图，比如 JSP。 选定视图之后，DispatcherServlet 会将数据模型与视图相结合，并将结果返回给客户端。并不是任何时候都需要视图，比如一个 RESTful 的 web 服务就不需要，它们的处理方法会利用 @ResponseBody 注解直接将请求结果返回给客户端。可以看REST with Spring course了解更多关于如何使用 Spring MVC 开发和测试 RESTful 服务的知识。 总结 DispatcherServlet 是 Spring MVC 应用中主要的控制器。所有的请求都会先经由 DispatcherServlet 处理，再由 Controller (声明有 @Controller 注解的类) 处理。 DispatcherServlet 是前端控制器模式的实现。前端控制器就是个用来处理网站所有请求的控制器。 就像其他的 Servlet， DispatcherServlet 也是声明和配置在 web.xml 文件中的： 1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; DispatcherServlet 继承自 HttpServlet 基类。Servlet 引擎(比如 Tomcat) 创建该类的实例，并且调用它不同的方法，比如：init(), service(), destroy()。 DispatcherServlet 为 Spring MVC 应用提供统一入口，处理所有的请求。 DispatcherServlet 也完全与 Spring IoC 容器集成，可以使用 Spring 框架的每一个特性，比如依赖注入。 当 DispatcherServlet 被配置为 load-on-startup = 1,意味着该 servlet 会在启动时由容器创建，而不是在请求到达时。这样做会降低第一次请求的响应时间，因为DispatcherServlet 会在启动时做大量工作，包括扫描和查找所有的 Controller 和 RequestMapping。 在 DispatcherServlet 初始化期间，Spring 框架会在 WEB-INF 文件夹中查找名为 [servlet-name]-servlet.xml 的文件，并创建相应的 bean。比如，如果 servlet 像上面 web.xml 文件中配置的一样，名为 “SpringMVC”，那么会查找 “SpringMVC-Servlet.xml”的文件。如果全局作用域中有相同名字的bean，会被覆盖。可以用 servlet 初始化参数 contextConfigLocation更改配置文件的位置。 在 Spring MVC 框架中，每个 DispatcherServlet 都有它自己的 WebApplicationContext ，并且继承了根 WebApplicationContext 中定义的所有 bean。这些继承的 bean 在 servlet 指定的作用域中可以被重载，也可以在其指定作用域中定义新的 bean。 Spring MVC 中的 DispatcherServlet也允许返回 Servlet API 定义的 last-modification-date。为了决定请求最后修改时间，DispatcherServlet会先查找合适的 handler mapping，然后检测处理器是否实现了 LastModified 接口。如果实现了，就调用接口的 getLastModified(request) 方法，并将该值返回给客户端。 以上就是关于 DispatcherSerlvet 的内容。正如上面所讲，DispacherServlet 是 Spring MVC 的骨干，是主要的控制器，用来将不同的 HTTP 请求路由当相应的 Controller。它是前端控制器设计模式的实现，并且为应用提供单一入口。可以在 web.xml 中配置 DispatcherServlet，但建议将 load-on-startup 设置为 1。这样容器会在启动时加载该 Serlvet 而不是请求到达时。这样能减少第一个请求的响应时间。 参考 Spring-MVC框架入门 【译】Spring MVC 中的 DispatcherServlet","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"Java虚拟机是如何执行线程同步的","slug":"Java虚拟机是如何执行线程同步的","date":"2018-04-08T09:48:41.000Z","updated":"2018-04-12T10:26:36.981Z","comments":true,"path":"2018/04/08/Java虚拟机是如何执行线程同步的/","link":"","permalink":"https://hsb786.github.io/2018/04/08/Java虚拟机是如何执行线程同步的/","excerpt":"线程和共享数据 在JVM中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其它线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。 在JVM中，堆内存是所有线程共享的。对象在堆中。 还有一部分数据保存JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象引用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。","text":"线程和共享数据 在JVM中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其它线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。 在JVM中，堆内存是所有线程共享的。对象在堆中。 还有一部分数据保存JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象引用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。 对象和类的锁 JMM中有两块区域可以被所有线程共享 堆，存放着所有对象方法区，存放着静态变量 那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果 为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。但线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其它申请锁的线程。 类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个java.lang.Class对象，当你锁住一个类的时候，其实锁住的是其对应的Class对象 监视器（Monitors） 锁其实是通过监视器实现的，监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。 每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，它是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。 当线程离开代码块时，无论如何离开，都会释放所关联对象的锁 多次加锁 同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为1，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其它线程便可以获得锁。 同步 在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。 参考 Java虚拟机是如何执行线程同步的","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"lombok","slug":"lombok","date":"2018-04-08T08:23:41.000Z","updated":"2018-04-11T04:46:26.649Z","comments":true,"path":"2018/04/08/lombok/","link":"","permalink":"https://hsb786.github.io/2018/04/08/lombok/","excerpt":"通过使用@Data注解自动帮你生成getters,setters,toString(),equals(),hashCode()方法 @AllArgsConstructor 全参构造函数 @NoArgsConstructor 无参构造函数","text":"通过使用@Data注解自动帮你生成getters,setters,toString(),equals(),hashCode()方法 @AllArgsConstructor 全参构造函数 @NoArgsConstructor 无参构造函数","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"NaN","slug":"NaN","date":"2018-04-08T08:07:41.000Z","updated":"2018-04-12T10:18:38.350Z","comments":true,"path":"2018/04/08/NaN/","link":"","permalink":"https://hsb786.github.io/2018/04/08/NaN/","excerpt":"","text":"NaN表示未定义或不可表示的值 A constant holding a Not-a-Number (NaN) value of type public static final double NaN = 0.0d /0.0; Java中的Double和Float都有isNaN。判断一个数是不是NaN，通过v!=v的方式。 NaN是唯一与自己不相等的值，NaN与任何值都不相等。","categories":[],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"VSCode快捷键","slug":"VSCode快捷键","date":"2018-04-08T07:58:41.000Z","updated":"2018-04-13T04:19:33.526Z","comments":true,"path":"2018/04/08/VSCode快捷键/","link":"","permalink":"https://hsb786.github.io/2018/04/08/VSCode快捷键/","excerpt":"","text":"命令 语义 ctrl B 侧边栏显/隐 ctrl shift E 资源管理器 ctrl tab 文件切换 F1或ctrl shift p 命令窗口 ctrl , 用户设置","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"git命令","slug":"gitCommand","date":"2018-04-08T07:42:41.000Z","updated":"2018-04-14T06:01:14.203Z","comments":true,"path":"2018/04/08/gitCommand/","link":"","permalink":"https://hsb786.github.io/2018/04/08/gitCommand/","excerpt":"","text":"","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"markdown","slug":"markdown","date":"2018-04-08T04:31:41.000Z","updated":"2018-04-13T11:31:54.189Z","comments":true,"path":"2018/04/08/markdown/","link":"","permalink":"https://hsb786.github.io/2018/04/08/markdown/","excerpt":"Cmd Markdown 简明语法手册标签： Cmd-Markdown","text":"Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]}]}