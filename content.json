{"meta":{"title":"HuShengBin’s blog","subtitle":"码渣的个人博客","description":"记录码渣的奋斗史","author":"HuShengBin","url":"https://hsb786.github.io"},"pages":[{"title":"关于我","date":"2018-04-09T10:17:26.000Z","updated":"2018-04-18T12:01:33.892Z","comments":true,"path":"about/index.html","permalink":"https://hsb786.github.io/about/index.html","excerpt":"","text":"1995 天枰座，身高不高 码渣一枚，喜欢敲代码，可惜太笨 常年混迹在知乎、豆瓣、网易云，想做个文艺青年，可惜没那个气质 对科技非常感兴趣，可惜穷 咖啡就是生命 联系方式：786398798@qq.com"},{"title":"分类","date":"2018-04-20T13:36:52.783Z","updated":"2018-04-20T13:36:52.783Z","comments":true,"path":"categories/index.html","permalink":"https://hsb786.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-20T13:36:26.660Z","updated":"2018-04-20T13:36:26.660Z","comments":true,"path":"tags/index.html","permalink":"https://hsb786.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java内存访问重排序的研究（转载）","slug":"Java内存访问重排序的研究","date":"2018-04-21T13:40:14.000Z","updated":"2018-04-21T13:58:54.750Z","comments":true,"path":"2018/04/21/Java内存访问重排序的研究/","link":"","permalink":"https://hsb786.github.io/2018/04/21/Java内存访问重排序的研究/","excerpt":"美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。原文链接","text":"美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。原文链接 什么是重排序12345678910111213141516171819202122public class PossibleReordering &#123;static int x = 0, y = 0;static int a = 0, b = 0;public static void main(String[] args) throws InterruptedException &#123; Thread one = new Thread(new Runnable() &#123; public void run() &#123; a = 1; x = b; &#125; &#125;); Thread other = new Thread(new Runnable() &#123; public void run() &#123; b = 1; y = a; &#125; &#125;); one.start();other.start(); one.join();other.join(); System.out.println(“(” + x + “,” + y + “)”);&#125; 很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。 然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程，如下图所示。值得注意的是，a=1和x=b这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”(reordering)。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文） 对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。 实验代码是构造一个循环，反复执行上面的实例代码，直到出现a=0且b=0的输出为止。实验结果说明，循环执行到第13830次时输出了(0,0). 大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作4，即生成的机器指令与字节码指令顺序不一致。 as-if-serial语义As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。 123int a = 1;int b = 2;int c = a + b; 将上面的代码编译成Java字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。 对a赋值1 对b赋值2 取a的值 取b的值 将取到两个值相加后存入c 在上面5个动作中，动作1可能会和动作2、4重排序，动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，一旦重排，as-if-serial语义便无法保证。 为保证as-if-serial语义，Java异常处理机制也会为重排序做一些特殊处理。例如在下面的代码中，y = 0 / 0可能会被重排序在x = 2之前执行，为了保证最终不致于输出x = 1的错误结果，JIT在重排序时会在catch语句中插入错误代偿代码，将x赋值为2，将程序恢复到发生异常时应有的状态。这种做法的确将异常捕捉的逻辑变得复杂了，但是JIT的优化的原则是，尽力优化正常运行下的代码逻辑，哪怕以catch块逻辑变得复杂为代价，毕竟，进入catch块内是一种“异常”情况的表现。 12345678910111213public class Reordering &#123; public static void main(String[] args) &#123; int x, y; x = 1; try &#123; x = 2; y = 0 / 0; &#125; catch (Exception e) &#123; &#125; finally &#123; System.out.println(&quot;x = &quot; + x); &#125; &#125;&#125; 内存访问重排序与内存可见性计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。其模型如下图所示。 在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。有的观点会将这种现象也视为重排序的一种，命名为“内存系统重排序”。因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。这种内存可见性问题也会导致章节一中示例代码即便在没有发生指令重排序的情况下的执行结果也还是(0, 0)。 内存访问重排序与Java内存模型Java的目标是成为一门平台无关性的语言，即Write once, run anywhere. 但是不同硬件环境下指令重排序的规则不尽相同。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-1337制定了Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性。从Java 5开始，Java内存模型成为Java语言规范的一部分。根据Java内存模型中的规定，可以总结出以下几条happens-before规则8。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。 volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4。 除此之外，Java内存模型对volatile和final的语义做了扩展。对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（的前提是没有this引用溢出）。 Java内存模型关于重排序的规定，总结后如下表所示。 表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有volatile写重排序。另外，JMM也规定了上述volatile和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括JIT，下同）证明了一个volatile变量只能被单线程访问，那么就可能会把它做为普通变量来处理。留白的单元格代表允许在不违反Java基本语义的情况下重排序。例如，编译器不会对对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。 除此之外，为了保证final的新增语义。JSR-133对于final变量的重排序也做了限制。 构建方法内部的final成员变量的存储，并且，假如final成员变量本身是一个引用的话，这个final成员变量可以引用到的一切存储操作，都不能与构建方法外的将当期构建对象赋值于多线程共享变量的存储操作重排序。例如对于如下语句x.finalField = v; … ; 构建方法边界sharedRef = x;v.afield = 1; x.finalField = v; … ; 构建方法边界sharedRef = x;这两条语句中，构建方法边界前后的指令都不能重排序。 初始读取共享对象与初始读取该共享对象的final成员变量之间不能重排序。例如对于如下语句x = sharedRef; … ; i = x.finalField;前后两句语句之间不会发生重排序。由于这两句语句有数据依赖关系，编译器本身就不会对它们重排序，但确实有一些处理器会对这种情况重排序，因此特别制定了这一规则。 内存屏障内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。内存屏障可以被分为以下几种类型 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。 为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。x.finalField = v; StoreStore; sharedRef = x; Intel 64/IA-32架构下的内存访问重排序Intel 64和IA-32是我们较常用的硬件环境，相对于其它处理器而言，它们拥有一种较严格的重排序规则。Pentium 4以后的Intel 64或IA-32处理的重排序规则如下。 在单CPU系统中 读操作不与其它读操作重排序。 写操作不与其之前的写操作重排序。 写内存操作不与其它写操作重排序，但有以下几种例外 CLFLUSH的写操作 带有non-temporal move指令(MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD)的streaming写入。 字符串操作 读操作可能会与其之前的写不同位置的写操作重排序，但不与其之前的写相同位置的写操作重排序。 读和写操作不与I/O指令，带锁的指令或序列化指令重排序。 读操作不能重排序到LFENCE和MFENCE之前。 写操作不能重排序到LFENCE、SFENCE和MFENCE之前。 LFENCE不能重排序到读操作之前。 SFENCE不能重排序到写之前。 MFENCE不能重排序到读或写操作之前。 在多处理器系统中 各自处理器内部遵循单处理器的重排序规则。 单处理器的写操作对所有处理器可见是同时的。 各自处理器的写操作不会重排序。 内存重排序遵守因果性(causality)（内存重排序遵守传递可见性）。 任何写操作对于执行这些写操作的处理器之外的处理器来看都是一致的。 s带锁指令是顺序执行的。 值得注意的是，对于Java编译器而言，Intel 64/IA-32架构下处理器不需要LoadLoad、LoadStore、StoreStore屏障，因为不会发生需要这三种屏障的重排序。 一例Intel 64/IA-32架构下的代码性能优化现在有这样一个场景，一个容器可以放一个东西，容器支持create方法来创建一个新的东西并放到容器里，支持get方法取到这个容器里的东西。我们可以较容易地写出下面的代码。 1234567891011121314151617181920212223242526public class Container &#123; public static class SomeThing &#123; private int status; public SomeThing() &#123; status = 1; &#125; public int getStatus() &#123; return status; &#125; &#125; private SomeThing object; public void create() &#123; object = new SomeThing(); &#125; public SomeThing get() &#123; while (object == null) &#123; Thread.yield(); //不加这句话可能会在此出现无限循环 &#125; return object; &#125;&#125; 在单线程场景下，这段代码执行起来是没有问题的。但是在多线程并发场景下，由不同的线程create和get东西，这段代码是有问题的。问题的原因与普通的双重检查锁定单例模式(Double Checked Locking, DCL)10类似，即SomeThing的构建与将指向构建中的SomeThing引用赋值到object变量这两者可能会发生重排序。导致get中返回一个正被构建中的不完整的SomeThing对象实例。为了解决这一问题，通常的办法是使用volatile修饰object字段。这种方法避免了重排序，保证了内存可见性，摒弃比使用同步块导致的性能损失更小。但是，假如使用场景对object的内存可见性并不敏感的话（不要求一个线程写入了object，object的新值立即对下一个读取的线程可见），在Intel 64/IA-32环境下，有更好的解决方案。 根据上一章的内容，我们知道Intel 64/IA-32下写操作之间不会发生重排序，即在处理器中，构建SomeThing对象与赋值到object这两个操作之间的顺序性是可以保证的。这样看起来，仅仅使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。但令人高兴的是，Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。 我们将做一个小实验来比较二者的性能差异。一种是使用volatile修饰object成员变量。 1234567891011121314151617181920212223242526public class Container &#123; public static class SomeThing &#123; private int status; public SomeThing() &#123; status = 1; &#125; public int getStatus() &#123; return status; &#125; &#125; private volatile SomeThing object; public void create() &#123; object = new SomeThing(); &#125; public SomeThing get() &#123; while (object == null) &#123; Thread.yield(); //不加这句话可能会在此出现无限循环 &#125; return object; &#125;&#125; 一种是利用Unsafe. putOrderedObject在避免在适当的位置发生重排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Container &#123; public static class SomeThing &#123; private int status; public SomeThing() &#123; status = 1; &#125; public int getStatus() &#123; return status; &#125; &#125; private SomeThing object; private Object value; private static final Unsafe unsafe = getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset(Container.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; public void create() &#123; SomeThing temp = new SomeThing(); unsafe.putOrderedObject(this, valueOffset, null); //将value赋null值只是一项无用操作，实际利用的是这条语句的内存屏障 object = temp; &#125; public SomeThing get() &#123; while (object == null) &#123; Thread.yield(); &#125; return object; &#125; public static Unsafe getUnsafe() &#123; try &#123; Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); f.setAccessible(true); return (Unsafe)f.get(null); &#125; catch (Exception e) &#123; &#125; return null; &#125;&#125; 由于直接调用Unsafe.getUnsafe()需要配置JRE获取较高权限，我们利用反射获取Unsafe中的theUnsafe来取得Unsafe的可用实例。unsafe.putOrderedObject(this, valueOffset, null)这句仅仅是为了借用这句话功能的防止写重排序，除此之外无其它作用。 利用下面的代码分别测试两种方案的实际运行时间。在运行时开启-server和 -XX:CompileThreshold=1以模拟生产环境下长时间运行后的JIT优化效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args) throws InterruptedException &#123; final int THREADS_COUNT = 20; final int LOOP_COUNT = 100000; long sum = 0; long min = Integer.MAX_VALUE; long max = 0; for(int n = 0;n &lt;= 100;n++) &#123; final Container basket = new Container(); List&lt;Thread&gt; putThreads = new ArrayList&lt;Thread&gt;(); List&lt;Thread&gt; takeThreads = new ArrayList&lt;Thread&gt;(); for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; putThreads.add(new Thread() &#123; @Override public void run() &#123; for (int j = 0; j &lt; LOOP_COUNT; j++) &#123; basket.create(); &#125; &#125; &#125;); takeThreads.add(new Thread() &#123; @Override public void run() &#123; for (int j = 0; j &lt; LOOP_COUNT; j++) &#123; basket.get().getStatus(); &#125; &#125; &#125;); &#125; long start = System.nanoTime(); for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; takeThreads.get(i).start(); putThreads.get(i).start(); &#125; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; takeThreads.get(i).join(); putThreads.get(i).join(); &#125; long end = System.nanoTime(); long period = end - start; if(n == 0) &#123; continue; //由于JIT的编译，第一次执行需要更多时间，将此时间不计入统计 &#125; sum += (period); System.out.println(period); if(period &lt; min) &#123; min = period; &#125; if(period &gt; max) &#123; max = period; &#125; &#125; System.out.println(&quot;Average : &quot; + sum / 100); System.out.println(&quot;Max : &quot; + max); System.out.println(&quot;Min : &quot; + min);&#125; 在笔者的计算机上运行测试，采用volatile方案的运行结果如下Average : 62535770Max : 82515000Min : 45161000 采用unsafe.putOrderedObject方案的运行结果如下Average : 50746230Max : 68999000Min : 38038000 从结果看出，unsafe.putOrderedObject方案比volatile方案平均耗时减少18.9%，最大耗时减少16.4%，最小耗时减少15.8%.另外，即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"HashMap中的扩容","slug":"HashMap中的扩容","date":"2018-04-21T12:10:50.000Z","updated":"2018-04-21T13:14:27.270Z","comments":true,"path":"2018/04/21/HashMap中的扩容/","link":"","permalink":"https://hsb786.github.io/2018/04/21/HashMap中的扩容/","excerpt":"以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。","text":"以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。术语： 高位运算：不太了解，网上也找不到解释。让高位参加运算? 取模运算：例如对于整数a，b来说，取模或者求余主要分为以下两步 求整数商: c=a/b 计算模或者余数：r=a-c*b 取模运算是r向负无穷方向舍弃小数位 求余运算时r向正无穷方向舍弃小数位 针对java8 根据key获取哈希桶数组索引位置12345678910111213public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; //1. h=key.hashCode() 取hashCode值 //2. h^(H&gt;&gt;&gt;16) 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//方法二tab[i = (n - 1) &amp; hash] 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，(length-1)&amp; h运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 扩容机制我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。 final Node&lt;K,V&gt;[] resize()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //// 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 总结 (n - 1) &amp; hash，当n是2次幂的时候，hash%n等于(n-1)&amp;hash，&amp;比%具有更高的效率 由于长度是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。 参考 Java 8系列之重新认识HashMap","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"},{"name":"集合","slug":"爪哇/集合","permalink":"https://hsb786.github.io/categories/爪哇/集合/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"Metaspace","slug":"Metaspace","date":"2018-04-21T04:21:05.000Z","updated":"2018-04-21T07:35:08.004Z","comments":true,"path":"2018/04/21/Metaspace/","link":"","permalink":"https://hsb786.github.io/2018/04/21/Metaspace/","excerpt":"现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。","text":"现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。 目的 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 Oracle 可能会将HotSpot 与 JRockit 合二为一。 优点避免了OutOfMemoryError的问题。类的元数据分配只受本地内存大小的限制。 GC如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。 JVM参数 -XX:MetaspaceSize 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。 -XX:MaxMetaspaceSize 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。 -XX:MinMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。 -XX:MaxMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。 参考 深入探究JVM | 探秘 Metaspace Java8内存模型—永久代(PermGen)和元空间(Metaspace) JDK 8 Memory Layout and garbage collection","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/tags/JVM/"}]},{"title":"jvm-GC","slug":"jvm-GC","date":"2018-04-21T03:10:31.000Z","updated":"2018-04-21T07:35:23.737Z","comments":true,"path":"2018/04/21/jvm-GC/","link":"","permalink":"https://hsb786.github.io/2018/04/21/jvm-GC/","excerpt":"关键字约定 Young generation –&gt;新生代 Tenured / Old Generation –&gt;老年代 Perm Area –&gt;永久代","text":"关键字约定 Young generation –&gt;新生代 Tenured / Old Generation –&gt;老年代 Perm Area –&gt;永久代 新生代（Young Generation）新生代是所有新对象产生的地方。当新生代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。新生代分为Enden、Survivor1、Survivor2。 大多数新建的对象都位于Eden区。 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。 Minor GC同样会检查存活下来的对象，如果需要会把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。 经过多次GC周期后，仍然存活下来的对象会被转移到老年代内存空间。通常这是在新生代有资格提升到老年代前通过设定年龄阈值来完成的。 老年代（Old Generation）一些大对象(长字符串或数组)可能会直接存放到老年代。老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。 Major GC会花费更多的时间。 永久代（Perm Area）永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。 java8中移除了永久代，取而代之的是Metaspace(元空间) 重要的东东 在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。 GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。 GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。 在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。 在从内存回收一个对象之前会调用对象的finalize()方法。 作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。 System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。 如果堆没有内存创建新的对象了，会抛出OutOfMemoryError。 GC针对什么对象？了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。 引用记数法 思想：给对象设置引用计数器，没引用该对象一次，计数器就+1，引用失效时，计数器就-1，当任意时候引用计数器的值都为0时，则该对象可被回收 Java不适用原因：无法解决对象互相循环引用的问题 GC Root可达性分析法, 当一个对象通过一系列根对象(Root)都不可达时就会被回收。 可作为GC Root的对象有: 虚拟机栈（栈帧中的局部变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 在可达性分析过程中，对象引用类型会对对象的生命周期产生影响，JAVA中有这几种类型的引用： 强引用：只要该引用还有效，GC就不会回收 软引用：内存空间足够时不进行回收，在内存溢出发生前进行回收、用SoftReference类实现 弱引用：弱引用关联的对象只能存活到下一次Gc收集、用WeakReference类实现 虚引用：无法通过虚引用获得对象实例，也不会对对象的生存时间产生影响、唯一目的：当该对象被Gc收集时，收到一个系统通知。用PhantomReference类实现 一个对象真正不可用，要经历两次标记过程： 首先进行可达性分析，筛选出与GC Root没用引用链的对象，进行第一次标记 第一次标记后，再进行一次筛选，筛选条件是是否有必要执行finalize()方法。若对象有没有重写finalize()方法，或者finalize()是否已被jvm调用过，则没必要执行，GC会回收该对象 若有必要执行，则该对象会被放入F-Queue中，由jvm开启一个低优先级的线程去执行它（但不一定等待finalize执行完毕）。 finalize()是对象最后一次自救的机会，若对象在finalize()中重新加入到引用链中，则它会被移出要回收的对象的集合。其他对象则会被第二次标记，进行回收 GC算法 标记清除算法 分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。 复制算法 把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。 标记整理算法 标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理。优点是不会造成内存碎片。 内存分配规则 对象优先在Eden分配 当Eden区没有足够的空间时就会发起一次Minor GC 大对象直接进入老年代 典型的大对象是很长的字符串和数组 长期存活的对象进入老年代 每个对象有年龄计数器，每经过一次GC，计数器值加一，当到达一定程度时（默认15），就会进入老年代 年龄的阈值可通过参数 -XX:MaxTenuringThreshold设置 对象年龄的判定 Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可直接进入老年代，无须等到MaxTenuringThreshold要求的年龄 空间分配担保 发生Minor GC前，jvm会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若大于，则Minor GC是安全的 若不大于，jvm会查看HandlePromotionFailure是否允许担保失败，若不允许，则改为一次Full GC 若允许担保失败，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试进行Minor GC；若小于，则要改为Full GC Java中垃圾回收器的类型Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。 Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。 ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。 Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。 Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。 CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。 与GC有关的JVM参数 参数 描述 -Xms 设置JVM启动时堆的初始化大小。 -Xmx 设置堆最大值。 -Xmn 设置新生代的空间大小，剩下的为老年代的空间大小。 -XX:SurvivorRatio 提供Eden区和survivor区的空间比例。比如，如果新生代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。 -XX:NewRatio 提供老年代和新生代的比例大小。默认值是2。 -XX:MetaspaceSize 分配给类元数据空间的初始大小 -XX:MaxMetaspaceSize 分配给类元数据空间的最大值 -XX:MinMetaspaceFreeRatio 一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。 -XX:MaxMetaspaceFreeRatio 一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。 GC监控 总结 为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。java8开始老年代已移出 新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。 Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。 发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。 Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。 参考 【译】Java中的垃圾回收机制 Java HotSpot VM Options Java内存与垃圾回收调优 Java GC 中的一些概念","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/tags/JVM/"}]},{"title":"Unsafe","slug":"Unsafe","date":"2018-04-20T10:48:25.000Z","updated":"2018-04-20T13:19:46.046Z","comments":true,"path":"2018/04/20/Unsafe/","link":"","permalink":"https://hsb786.github.io/2018/04/20/Unsafe/","excerpt":"sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作 Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）","text":"sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作 Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）1234567891011121314151617181920212223242526272829public final class Unsafe &#123; private static native void registerNatives(); static &#123; registerNatives(); sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, &quot;getUnsafe&quot;); &#125; //饿汉式单例 private Unsafe() &#123;&#125; private static final Unsafe theUnsafe = new Unsafe(); @CallerSensitive public static Unsafe getUnsafe() &#123; //获取调用该方法的调用者信息 Class&lt;?&gt; caller = Reflection.getCallerClass(); //判断类加载器是否是系统类加载器 if (!VM.isSystemDomainLoader(caller.getClassLoader())) throw new SecurityException(&quot;Unsafe&quot;); return theUnsafe; &#125; .............&#125;//VM.class public static boolean isSystemDomainLoader(ClassLoader loader) &#123; return loader == null;&#125; Unsafe.getUnsafe()只能被boostrap classloader加载的类使用，所以可以利用java反射来获取Unsafe的实例。 123456//获取Unsafe类中的theUnsafe字段Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);//由于theUnsafe被private修饰，所以要跳过安全检查f.setAccessible(true);//获取当前f的值，也就是Unsafe的实例Unsafe unsafe = (Unsafe) f.get(null); public native long objectFieldOffset(Field f)和public native long staticFieldOffset(Field f)：用于返回类定义中某个属性在主内存中设定的偏移量。相当于CAS中的V。 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);：对属性进行比较并替换（CAS过程——Compare And Swap）。offect：V，expected：A，x：B 1234567891011//java8public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; //自旋，一直循环直到compareAndSwapInt执行成功 v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125;public native int getIntVolatile(Object o, long offset); getAndAddInt()采用的是基于Unsafe的”乐观锁”进行实现的，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。适合并发量不高的情况。 @CallerSensitive12345678910111213141516171819//sun.reflect.CallerSensitive/** * A method annotated @CallerSensitive is sensitive to its calling class, * via &#123;@link sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;, * or via some equivalent. * * @author John R. Rose */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;METHOD&#125;)public @interface CallerSensitive &#123;&#125;//sun.reflect.Reflection/** Returns the class of the caller of the method calling this method, ignoring frames associated with java.lang.reflect.Method.invoke() and its implementation. */@CallerSensitivepublic static native Class&lt;?&gt; getCallerClass(); 用@CallerSensitive注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用sun.reflect.Reflection.getCallerClass方法。 Reflection类位于调用栈中的0帧位置，sun.reflect.Reflection.getCallerClass()方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。 感觉不太懂，做个标记，以后再来看吧 参考 线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） 跟我一起剖析 Java 并发源码之 Unsafe JDK8的@CallerSensitive JVM注解@CallSensitive 深入解析Java反射（2） - invoke方法","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"多线程基础2","slug":"多线程基础2","date":"2018-04-20T05:28:33.000Z","updated":"2018-04-20T13:20:44.502Z","comments":true,"path":"2018/04/20/多线程基础2/","link":"","permalink":"https://hsb786.github.io/2018/04/20/多线程基础2/","excerpt":"线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。","text":"线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。 根据操作系统的不同（Windows/Unix/Linux/其他），他们所支持的线程底层实现和操作效果也是不尽相同的。不过一个操作系统支持的线程至少会有四种状态：就绪、执行、阻塞和终结。线程在四种状态下进行切换，都是要消耗不少的CPU计算能力的。 根据操作系统使用线程的进程的不一样，线程还分为用户线程和操作系统线程。操作系统线程（内核线程），是指操作系统内核为了完成硬件接口层操作，由操作系统内核创建的线程：例如I/O操作的内核线程，这些线程应用程序是不能干预的；用户线程，是指用户安装/管理的应用程序，为执行某一种操作，而由这个应用程序创建的线程。 黄色钥匙代表对象锁 Thread.interrupted()与thread.isInterrupted() 当Thread收到interrupt信号是，可能的两种结果: 线程处于运行状态时，线程对象的isInterrupt属性被置为true 处于阻塞状态是，抛出InterruptedException异常，其isInterrupt不会被置为true。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #isInterrupted() * @revised 6.0 */ public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; /** * Tests whether this thread has been interrupted. The &lt;i&gt;interrupted * status&lt;/i&gt; of the thread is unaffected by this method. * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted; * &lt;code&gt;false&lt;/code&gt; otherwise. * @see #interrupted() * @revised 6.0 */ public boolean isInterrupted() &#123; return isInterrupted(false); &#125; /** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */ private native boolean isInterrupted(boolean ClearInterrupted); 可以看出interrupted和isInterrupted区别在于传给ClearInterrupted的参数是true还是false。 ClearInterrupted参数向操作系统指明是否在获取状态后将当前线程的interrupted状态重置为false。 这就意味着当某个线程的isInterrupt属性成功被置为true后，如果您使用对象方法thread.isInterrupted()获取值，无论您获取多少次得到的返回值都是true；但是如果您使用静态方法Thread.interrupted()获取值，那么只有第一次获取的结果是true，随后线程的isInterrupt属性将被恢复成false，后续无论使用Thread.interrupted()调用还是使用thread.isInterrupted()调用，获取的结果都是false。 wait和sleep都是让当前线程进入阻塞状态，yield是让主线程等待调用yield的线程执行完。 sleep是static方法 Java语言为我们提供了两种基础线程池的选择：ScheduledThreadPoolExecutor和ThreadPoolExecutor。它们都实现了ExecutorService接口（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）。 JAVA主要线程池的继承结构 ThreadPoolExecutor：对于任务的执行是立即的、一次性的。 ScheduledThreadPoolExecutor：一个用来执行延迟任务、定时任务或者周期性任务的线程池。一般情况下，我们用它可以处理定时计算、周期性统计一类的任务。 ForkJoinPool：ScheduledThreadPoolExecutor和ThreadPoolExecutor都是在JDK1.5版本中提供的。在JDK1.7中，JAVA为我们提供了一种新的线程池ForkJoinPool以及配套的任务定义ForkJoinTask。除了可以执行实现了Runnable接口或者Callable接口的任务以外，ForkJoinPool还可以执行集成了ForkJoinTask定义的任务。ForkJoinPool的执行原理和ThreadPoolExecutor的执行原理是不一样的 ThreadFactory线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在ThreadPoolExecutor线程池中，创建线程的工作交给ThreadFactory来完成。要使用线程池，就必须要指定ThreadFactory。 如果我们使用的构造函数时并没有指定使用的ThreadFactory，这个时候ThreadPoolExecutor会使用一个默认的ThreadFactory：DefaultThreadFactory。（这个类在Executors工具类中） Executors工具类和ThreadPoolExecutor类存在循环依赖：ThreadPoolExecutor中使用了Executors工具类中定义的DefaultThreadFactory；而在Executors工具类中却又在创建ThreadPoolExecutor的对象实例。 参考 多线程基础","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"CAS","slug":"CAS","date":"2018-04-19T09:41:51.000Z","updated":"2018-04-20T13:14:19.777Z","comments":true,"path":"2018/04/19/CAS/","link":"","permalink":"https://hsb786.github.io/2018/04/19/CAS/","excerpt":"CAS（Compare And Swap），翻译过来就是比较和替换。 CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。","text":"CAS（Compare And Swap），翻译过来就是比较和替换。 CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。 举个例子 在内存地址V当中，存储着值为10的变量。 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11 线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。 线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。 这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。 线程1进行SWAP，把地址V的值替换为B，也就是12。 synchronized与CASsynchronized关键字会让没有得到线程锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的切换，代价比较高。 从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。 原子操作类指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。 AtomicInteger12345678910private volatile int value;private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; unsafe：Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。unsafe为我们提供了硬件级别的原子操作。 valueOffset：至于valueOffset对象，是通过unsafe.objectFieldOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单地把valueOffset理解为value变量的内存地址。 getAndIncrement 相当于i++，先返回值再加1 在java7中是这样实现的12345678910111213//AtomicInteger.classpublic final int getAndIncrement() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; &#125;&#125;public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; getAndIncrement方法内部会不停的循环，直到unsafe.comparAndSwapInt方法执行成功。valueOffset相当于前面讲的V，expect：旧的预期值A，update：新的预期值B java8中的实现1234//AtomicInteger.classpublic final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 这时需要查看Unsafe的源码，可以下载openjdk，openjdk中有关于sun.misc包中的源码 1234567891011121314//Unsafe.classpublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125;public native int getIntVolatile(Object o, long offset);public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 感觉跟jdk7差不多，只是把具体的实现从AtomicInteger移动到了Unsafe中。为了重用？这只是我的个人理解，错了欢迎指正。 Java语言CAS底层就是利用unsafe提供的原子性操作方法来实现的。 缺点1. CPU开销较大 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。 2. 不能保证代码块的原子性 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。 3. ABA问题 当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。利用版本号比较可以有效解决ABA问题。 参考 漫画：什么是CAS机制？ 漫画：什么是CAS机制？（进阶篇） 线程进阶：多任务处理（17）——Java中的锁（Unsafe基础）","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"RESTful","slug":"RESTful","date":"2018-04-18T05:37:06.000Z","updated":"2018-04-20T13:19:13.351Z","comments":true,"path":"2018/04/18/RESTful/","link":"","permalink":"https://hsb786.github.io/2018/04/18/RESTful/","excerpt":"起源REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 他在论文中提到： “本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”","text":"起源REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 他在论文中提到： “本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。” RESTFielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer（表现层状态转化）的缩写。 如果一个架构符合REST原则，就称它为RESTful架构。 资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 补充HTTP协议，是一个无状态协议，无状态是什么意思回答1有状态：A：你今天中午吃的啥？B：吃的大盘鸡。A：味道怎么样呀？B：还不错，挺好吃的。 无状态：A：你今天中午吃的啥？B：吃的大盘鸡。A：味道怎么样呀？B：？？？啊？啥？啥味道怎么样？ 所以需要cookie这种东西：A：你今天中午吃的啥？B：吃的大盘鸡。A：你今天中午吃的大盘鸡味道怎么样呀？B：还不错，挺好吃的。 回答2 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见 【状态】的含义就是：客户端和服务器在某次会话中产生的数据，从而【无状态】就意味着，这些数据不会被保留 但是： 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 例子 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 总结 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 参考 理解RESTful架构 HTTP是一个无状态的协议。这句话里的无状态是什么意思？ http协议无状态中的 “状态” 到底指的是什么？！ RESTful API 设计指南","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"基本排序算法","slug":"基本排序算法","date":"2018-04-18T04:27:50.000Z","updated":"2018-04-20T13:21:43.798Z","comments":true,"path":"2018/04/18/基本排序算法/","link":"","permalink":"https://hsb786.github.io/2018/04/18/基本排序算法/","excerpt":"快速排序基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列","text":"快速排序基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列123456789101112131415161718192021222324252627282930313233static void quickSort(int[] array) &#123; quickSort(array, 0, array.length - 1);&#125;static void quickSort(int[] array, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int mid = partion(array, left, right); quickSort(array, left, mid - 1); quickSort(array, mid + 1, right);&#125;static int partion(int[] array, int left, int right) &#123; // 取第一个数为基准元素 int tmp = array[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt;= tmp) &#123; right--; &#125; // 比基准元素小的移动到低端 array[left] = array[right]; while (left &lt; right &amp;&amp; array[left] &lt;= tmp) &#123; left++; &#125; // 比基准元素大的移动到高端 array[right] = array[left]; &#125; // 插入基准元素 array[left] = tmp; return left;&#125; 归并排序基本思想：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列 12345678910111213141516171819202122232425262728293031323334353637static void mergeSort(int[] arr) &#123; int[] temp = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, temp);&#125;static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序 mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序 merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作 &#125;&#125;static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left;// 左序列指针 int j = mid + 1;// 右序列指针 int t = 0;// 临时数组指针 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t++] = arr[i++]; &#125; else &#123; temp[t++] = arr[j++]; &#125; &#125; while (i &lt;= mid) &#123;// 将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while (j &lt;= right) &#123;// 将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; // 将temp中的元素全部拷贝到原数组中 while (left &lt;= right) &#123; arr[left++] = temp[t++]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"代理模式","slug":"代理模式","date":"2018-04-17T10:21:28.000Z","updated":"2018-04-20T13:20:26.051Z","comments":true,"path":"2018/04/17/代理模式/","link":"","permalink":"https://hsb786.github.io/2018/04/17/代理模式/","excerpt":"为其他对象提供一种代理以控制对这个对象的访问","text":"为其他对象提供一种代理以控制对这个对象的访问 优点 代理对象可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能，符合开闭原则 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。 代理类分类 静态代理:静态定义代理类，我们自己静态定义的代理类。 动态代理:通过程序动态生成代理类，该代理类不是我们自己定义的，而是由程序自动生成，常用的动态代理技术有JDK自带的动态代理和CGLIB动态代理。 *参考 代理模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/tags/设计模式/"}]},{"title":"策略模式","slug":"策略模式","date":"2018-04-17T10:07:27.000Z","updated":"2018-04-20T13:20:07.750Z","comments":true,"path":"2018/04/17/策略模式/","link":"","permalink":"https://hsb786.github.io/2018/04/17/策略模式/","excerpt":"策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 根据条件的不同选择不同的策略","text":"策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 根据条件的不同选择不同的策略 优点 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用享元模式在一定程度上减少对象的数量。 参考 设计模式（十二）——策略模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/tags/设计模式/"}]},{"title":"抽象工厂","slug":"抽象工厂","date":"2018-04-17T09:17:08.000Z","updated":"2018-04-20T13:20:15.747Z","comments":true,"path":"2018/04/17/抽象工厂/","link":"","permalink":"https://hsb786.github.io/2018/04/17/抽象工厂/","excerpt":"提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。","text":"提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。 产品等级结构和产品族产品等级结构： 产品等级结构即产品的继承结构，同一类产品，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，同一个品牌产品，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 抽象工厂与工厂方法抽象工厂和工厂方法最大的区别在于，工厂方法针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。 工厂方法：用来生产同一等级结构中的固定产品（支持增加任意产品，新增产品是不需要更改已有的工程，需要增加该产品对应的工程。符合单一职责原则、符合开闭原则。但是引入了复杂性） 抽象工厂：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开闭原则，降低了复杂性） 优点每次可以通过具体工厂类创建一个产品族的多个对象，增加新的具体工厂和产品族很方便。 缺点增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。 参考 工厂模式-下 设计模式（八）——工厂模式总结设计模式（七）——抽象工厂模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/tags/设计模式/"}]},{"title":"工厂方法","slug":"工厂方法","date":"2018-04-17T09:05:30.000Z","updated":"2018-04-20T13:21:25.925Z","comments":true,"path":"2018/04/17/工厂方法/","link":"","permalink":"https://hsb786.github.io/2018/04/17/工厂方法/","excerpt":"定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。","text":"定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 优点 在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 缺点在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 参考 工厂模式(上) 设计模式：工厂方法模式 设计模式（五）——工厂方法模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/tags/设计模式/"}]},{"title":"ClassLoader","slug":"ClassLoader","date":"2018-04-16T12:21:34.000Z","updated":"2018-04-20T13:25:48.321Z","comments":true,"path":"2018/04/16/ClassLoader/","link":"","permalink":"https://hsb786.github.io/2018/04/16/ClassLoader/","excerpt":"Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。","text":"Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。 public abstract class ClassLoader class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 使用指定的二进制名称来加载类，这个方法的默认实现按照以下顺序查找类： 调用findLoadedClass(String)方法检查这个类是否被加载过 使用父加载器调用loadClass(String)方法，如果父加载器为Null，类加载器装载虚拟机内置的加载器调用findClass(String)方法装载类， 如果，按照以上的步骤成功的找到对应的类，并且该方法接收的resolve参数的值为true,那么就调用resolveClass(Class)方法来处理类。 java中的类大致分为三种: 系统类 扩展类 由程序员自定义的类 类装载方式，有两种： 隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。 显式装载， 通过class.forName()等方法，显式加载需要的类 类加载的动态性体现： 一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现 java类装载器Java中的类装载器实质上也是类，功能是把类载入jvm中，jvm的类装载器有三个，层次结构如下： 类加载器之间是如何协调工作的java是如何区分一个类该由哪个类加载器来完成呢。 在这里java采用了委托模型机制，这个机制简单来讲，就是“类装载器有载入类的需求时，会先请示其Parent使用其搜索路径帮忙载入，如果Parent 找不到,那么才由自己依照自己的搜索路径搜索类” 123456789101112131415Public class Test&#123; Public static void main(String[] arg)&#123; ClassLoader c = Test.class.getClassLoader(); //获取Test类的类加载器 System.out.println(c); ClassLoader c1 = c.getParent(); //获取c这个类加载器的父类加载器 System.out.println(c1); ClassLoader c2 = c1.getParent();//获取c1这个类加载器的父类加载器 System.out.println(c2); &#125;&#125;//outputAppClassLoaderExtClassLoaderNull 可以看出Test是由AppClassLoader加载器加载的，AppClassLoader的Parent 加载器是 ExtClassLoader,但是ExtClassLoader的Parent为 null 是怎么回事。Bootstrap Loader是用C++语言写的，依java的观点来看，逻辑上并不存在Bootstrap Loader的类实体，所以在java程序代码里试图打印出其内容时，我们就会看到输出为null。 java类加载器基于三个机制：委托，可见，单一。 委托机制：指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载他。 可见性机制：指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。 单一性机制：指的是一个类只能被同一种加载器加载一次。 JVM加载class文件的原理机制类装载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤： 装载：查找和导入Class文件 链接： 验证：检查载入的class文件数据的正确性 准备： 给类的静态变量分配存储空间 解析： 将符号引用转成直接引用 初始化：对静态变量，静态代码块执行初始化工作 类装载工作由ClassLoder和其子类负责。JVM在运行时会产生三个ClassLoader：根装载器，ExtClassLoader(扩展类装载器)和AppClassLoader，其中根装载器不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库，如JRE目录下的rt.jar,charsets.jar等。ExtClassLoader是ClassLoder的子类，负责装载JRE扩展目录ext下的jar类包；AppClassLoader负责装载classpath路径下的类包，这三个类装载器存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下使用AppClassLoader装载应用程序的类 Java装载类使用“全盘负责委托机制”。“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入；“委托机制”是指先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全方面考虑的，试想如果一个人写了一个恶意的基础类（如java.lang.String）并加载到JVM将会引起严重的后果，但有了全盘负责制，java.lang.String永远是由根装载器来装载，避免以上情况发生 除了JVM默认的三个ClassLoder以外，第三方可以编写自己的类装载器，以实现一些特殊的需求。类文件被装载解析后，在JVM中都有一个对应的java.lang.Class对象，提供了类结构信息的描述。数组，枚举及基本数据类型，甚至void都拥有对应的Class对象。 装载过程有两个比较重要的特征：层次组织结构和代理模式。层次组织结构指的是每个类加载器都有一个父类加载器，通过getParent()方法可以获取到。类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。代理模式则指的是一个类加载器既可以自己完成Java类的定义工作，也可以代理给其它的类加载器来完成。由于代理模式的存在，启动一个类的加载过程的类加载器和最终定义这个类的类加载器可能并不是一个。ClassLoader的加载类过程主要使用loadClass方法，该方法中封装了中加载机制：双亲委派模式。 一般来说，父类优先的策略就足够好了。在某些情况下，可能需要采取相反的策略，即先尝试自己加载，找不到的时候再代理给父类加载器。这种做法在Java的Web容器中比较常见，也是Servlet规范推荐的做法。比如，Apache Tomcat为每个Web应用都提供一个独立的类加载器，使用的就是自己优先加载的策略。 类加载器的一个重要用途是在JVM中为相同名称的Java类创建隔离空间。在JVM中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加载器。只有两者完全一样，才认为两个类的是相同的。因此，即便是同样的Java字节代码，被两个不同的类加载器定义之后，所得到的Java类也是不同的。如果试图在两个类的对象之间进行赋值操作，会抛出java.lang.ClassCastException。这个特性为同样名称的Java类在JVM中共存创造了条件。在实际的应用中，可能会要求同一名称的Java类的不同版本在JVM中可以同时存在。通过类加载器就可以满足这种需求。 Java类的链接Java类的链接指的是将Java类的二进制代码合并到JVM的运行状态之中的过程。在链接之前，这个类必须被成功加载。链接的过程比加载过程要复杂很多，这是实现java的动态性的重要一步！分为三部分：verification （验证）， preparation（准备） 和 resolution（解析） 1. verification（验证）：验证是用来确保Java类的二进制表示在结构上是完全正确的。要验证比如class文件格式规范、这个类是否继承了final类、不能把一个父类对象赋值给子类数据类型等等。如果验证过程出现错误的话，会抛出java.lang.VerifyError错误。 2.preparation（准备）： 准备阶段为方法区中的静态变量分配内存空间。并将其赋值为初始值，所有原始类型的值都为0。如float为0f、 int为0、boolean为0、引用类型为null。 3.resolution（解析）： 解析的过程就是确保这些被引用的类能被正确的找到。解析的过程可能会导致其它的Java类被加载。 为类、接口、方法、成员变量的符号引用定位直接引用。 符号引用是一个字符串，它唯一标识一个类、一个字段、一个方法等目标。 而直接引用对于类变量、类方法指的是指向方法区的指针，然后对于实例方法、实例对象来说就是偏移量，比如一个实例方法，子类中方法表中的偏移量和父类是一致的，这个偏移量可以确定某个方法的位置。 Java类的初始化类的初始化是延迟的，直到类第一次被主动使用(active use)，JVM 才会初始化类。当一个Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。初始化过程的主要操作是执行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的顺序依次执行静态代码块和初始化静态域。 初始化过程会被触发的条件汇总： 使用new关键字实例化对象、访问一个类的静态字段、静态方法的时候。 对类进行反射调用的时候。 当初始化子类时，如果发现其父类还没有进行过初始化，则进行父类的初始化。 参考 深度分析Java的ClassLoader机制（源码级别） Java类的加载、链接和初始化 java基础巩固笔记(3)-类加载器 JVM——Java类加载机制总结","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/tags/JVM/"}]},{"title":"TCP/IP","slug":"TCP-IP","date":"2018-04-16T10:43:52.000Z","updated":"2018-04-21T07:34:20.144Z","comments":true,"path":"2018/04/16/TCP-IP/","link":"","permalink":"https://hsb786.github.io/2018/04/16/TCP-IP/","excerpt":"感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？ 还能怎么办，学啊。 TCP/IP百度百科上的解释 Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。","text":"感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？ 还能怎么办，学啊。 TCP/IP百度百科上的解释 Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 TCP/IP协议族就采用了分层的思想，自上而下分成了四层： 应用层，传输层，网络层，链路层，每一层的协议只约定了特定的功能，HTTP就位于应用层。利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。一次HTTP请求的典型过程如下图所示 URI URI是Uniform Resource Identifier的缩写，是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。 比如12http://ftp:// 我们比较熟悉的URL（Uniform Resource Locator，统一资源定位符）表示资源在互联网上的地址，它其实是URI的一个子集，因为URI仅仅表示「标识」， 标识的类型有很多，比如ISBN号码，电话号码，邮箱，网页链接地址等，而URL则把概念缩小到了「地址」。 由于URI在绝大多数场景下都是以URL的形式存在，大家一般都说URL居多，这也没什么问题，但是在心里要清楚URI和URL还是有所区别的。 HTTP协议内容接下来的内容基于HTTP 1.1版本。 请求 &amp; 响应报文结构 在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出， 最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。 HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。 请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 如下是一个HTTP请求和响应报文的实例 响应状态码 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 数字中的第一位指定了响应类别，后两位无分类。 状态码主要类型一览： 首部 &amp; 实体 HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。 HTTP首部字段由首部字段名和字段值构成的，中间用冒号“:”分隔。比如：Content-Type: text/html。 HTTP实体是HTTP请求和响应传输的主体内容，根据场景不同可能是表单参数，HTML文本，JSON文本，二进制流等。 Cookie HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。 Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 GET和POST的区别GET和POST最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数 W3school的解答 方法 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 这个对比只是给出了一些现象上的区别 GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 如果你用GET服务，在request body中存了数据，不同服务器的处理方式是不同的，有些服务器会读出数据，有些服务器直接忽略。所以，虽然GET可以带request body，但不能保证一定能被接受到。 RFC 征求意见稿（英语：Request For Comments，缩写为RFC），是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件，以编号排定。目前RFC文件是由互联网协会（ISOC）赞助发行。 简单理解RFC就是互联网的规范，我们通常所说的「协议」就是以RFC的形式存在，而现行的HTTP/1.1规范的RFC有如下几个： RFC7230， RFC7231， RFC7232， RFC7233， RFC7234， RFC7235。 其中RFC7231里的Section 4. Request Methods涉及到了几个HTTP方法，接下来仔细阅读这一章节。 The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result. semantic[语义]，语法与语义的区别： 一种语言是合法句子的集合。什么样的句子是合法的呢？可以从两方面来判断：语法和语义。语法是和文法结构有关，然而语义是和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。 对于HTTP请求来说，语法是指请求响应的格式，比如请求第一行必须是 方法名 URI 协议/版本 这样的格式。 语义则定义了这一类型的请求具有什么样的性质。比如GET的语义就是「获取资源」，POST的语义是「处理资源」，那么在具体实现这两个方法时，就必须考虑其语义，做出符合其语义的行为。 当然在符合语法的前提下实现违背语义的行为也是可以做到的，比如使用GET方法修改用户信息，POST获取资源列表，这样就只能说这个请求是「合法」的，但不是「符合语义」的。 RFC7231里紧接着定义了HTTP方法的几个特性： Safe - 安全这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此RFC定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用GET修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。 Idempotent - 幂等幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。 Cacheable - 可缓存性顾名思义就是一个方法是否可以被缓存，此RFC里GET，HEAD和某些情况下的POST都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持GET和HEAD。 在这三个特性里一直在强调同一个事情，那就是协议不等于实现：协议规定安全在实现里不一定安全，协议规定幂等在实现里不一定幂等，协议规定可缓存在实现里不一定可缓存。 语义之争GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-Control Header的约束）,GET方法的报文主体没有任何语义。 POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。 TCP为什么是三次握手 TCP作为一种可靠传输控制协议,其核心思想:既要保证数据可靠传输,又要提高传输的效率 三次是保证双方互相明确对方能收能发的最低值 参考 TCP/IP协议 百度百科 99%的人都理解错了HTTP中GET与POST的区别 图解HTTP-读书笔记 HTTP 方法：GET 对比 POST HTTP协议中GET和POST方法的区别 TCP 为什么是三次握手，而不是两次或四次？","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"单例模式","slug":"单例模式","date":"2018-04-16T05:35:59.000Z","updated":"2018-04-20T13:20:30.545Z","comments":true,"path":"2018/04/16/单例模式/","link":"","permalink":"https://hsb786.github.io/2018/04/16/单例模式/","excerpt":"定义：单例对象的类必须保证只有一个实例存在场景：希望在整个系统中只能出现某个类的一个实例 分类 懒汉式：指全局的单例实例在第一次被使用时构建 饿汉式：指全局的单例实例在类装载时构建 日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。","text":"定义：单例对象的类必须保证只有一个实例存在场景：希望在整个系统中只能出现某个类的一个实例 分类 懒汉式：指全局的单例实例在第一次被使用时构建 饿汉式：指全局的单例实例在类装载时构建 日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。 单例模式的实现懒汉式单例1234567891011121314public class Single &#123; private static volatile Single instance; private Single() &#123;&#125; public static Single getInstance() &#123; if (instance == null) &#123; synchronized (Single.class) &#123; if (instance == null) &#123; instance = new Single(); &#125; &#125; &#125; return instance; &#125;&#125; instance = new Single()；这个语句在JVM中，实际执行的原子语句包括： 给Single分配内存 调用Single的构造函数完成初始化，返回类实例 将instance指向之前分配的完成初始化的内存 编译器在不改变单线程程序语义的前提下，可以对指令重排序。1-2-3可能会变成1-3-2 导致的结果可能就是，线程B执行到1- 3 , 已经将instance引用指向了分配的内存，但是并没有执行初始化操作，所以这个时候instance并不等于null，但是没有被初始化。然后，线程B让出CPU，线程A开始执行，判断if(instance==null)，由于instance不等于null，于是线程A就直接返回这个instance，但是这个对象是线程B没有初始化的对象。 so，加上volatile修饰后，就可以禁止指令重排，遵循happens-before原则。保证B线程对instance的修改happens-before于A线程对instance的读。 饿汉式单例1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 静态内部类实现 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 前一种方法只要Single类被加载了，那么instance就会被实例化。而这种方式是Singleton类被加载了，instance不一定被实例化。因为SingletonHoler类没有被主动使用，只在外部类的Singleton的getInstance()中被调用时才加载，从而实例化Instance，这样就可以启动延迟加载。 参考 单例模式 设计模式（二）——单例模式 [转+注]单例模式的七种写法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hsb786.github.io/tags/设计模式/"}]},{"title":"Integer","slug":"Integer","date":"2018-04-16T05:09:49.000Z","updated":"2018-04-20T13:16:50.058Z","comments":true,"path":"2018/04/16/Integer/","link":"","permalink":"https://hsb786.github.io/2018/04/16/Integer/","excerpt":"类定义public final class Integer extends Number implements Comparable&lt;Integer&gt; Integer不能被继承 Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较 Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值","text":"类定义public final class Integer extends Number implements Comparable&lt;Integer&gt; Integer不能被继承 Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较 Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值 属性private final int value; value属性就是Integer对象中保存的int值 方法12Integer i=new Integer(1);i=2; 反编译之后的代码 12Integer i = new Integer(1);i = Integer.valueOf(2); 编译器会把i=2转换成i=Integer.valueOf(2)； 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 通常情况下，IntegerCache.low=-128，IntegerCache.high=127（除非显示声明java.lang.Integer.IntegerCache.high的值），Integer中有一段静态代码块，该部分内容会在Integer类被加载的时候就执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 也就是说，当Integer被加载时，就新建了-128到127的所有数字并存放在Integer数组cache中。 再回到valueOf代码，可以得出结论。当调用valueOf方法时，如果参数的值在-127到128之间，则直接从缓存中返回一个已经存在的对象。如果参数的值不在这个范围内，则new一个Integer对象返回。 所以，当把一个int变量转成Integer的时候（或者新建一个Integer的时候），建议使用valueOf方法来代替构造函数。或者直接使用Integer i = 100;编译器会转成Integer s = Integer.valueOf(100); 参考 Java 源码学习系列（三）——Integer","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"String","slug":"String","date":"2018-04-16T04:35:57.000Z","updated":"2018-04-20T13:19:36.084Z","comments":true,"path":"2018/04/16/String/","link":"","permalink":"https://hsb786.github.io/2018/04/16/String/","excerpt":"Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过StringBuilder的append()方法来实现的，字符串的转换通过toString方法实现。","text":"Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过StringBuilder的append()方法来实现的，字符串的转换通过toString方法实现。 定义public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence{} 属性private final char value[]; 这是一个字符数组，并且是final类型，它用于存储字符串内容，从final这个关键字中我们可以看出，String的内容一旦被初始化了是不能被改变的。 private int hash; 缓存字符串的hashCode，默认值为0 构造方法1. 使用字符数组、字符串构造一个String但我们使用字符数组创建String的时候，会用到Arrays.copyOf方法和Arrays.copyOfRange方法。这两个方法是将原有的字符数组中的内容逐一复制到String中的字符数组中。同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将源String中的value和hash两个属性直接赋值给目标String。因为String是不可变的，所以不用担心改变源String的值会影响到目标String的值 2.使用字节数组构造一个String在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，构造成新的String。 3.使用StringBuffer和StringBuider构造一个String123456789public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125;&#125;public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length());&#125; 很少用到，当我们有了StringBuffer或者StringBuilfer对象之后可以直接使用他们的toString方法来得到String。 123456public String toString() &#123; // Create a copy, don&apos;t share the array return new String(value, 0, count); &#125;this.value = Arrays.copyOfRange(value, offset, offset+count); intern()java7以后，常量池被放入到堆空间中。导致intern()函数的功能不同。intern()检查常量池是否存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用 参考 Java 7 源码学习系列（一）——String","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"enum","slug":"enum","date":"2018-04-16T03:47:49.000Z","updated":"2018-04-20T13:15:16.177Z","comments":true,"path":"2018/04/16/enum/","link":"","permalink":"https://hsb786.github.io/2018/04/16/enum/","excerpt":"Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类","text":"Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable Enum类无法被继承 定义一个Color枚举 enum Color {RED, GREEN, YELLOW} 反编译后的结果12345678910public final class EnumTest.Color extends java.lang.Enum&lt;EnumTest.Color&gt; &#123; public static final EnumTest.Color RED; public static final EnumTest.Color GREEN; public static final EnumTest.Color YELLOW; private static final EnumTest.Color[] ENUM$VALUES; static &#123;&#125;; private EnumTest.Color(java.lang.String, int); public static EnumTest.Color[] values(); public static EnumTest.Color valueOf(java.lang.String);&#125; 从反编译之后的代码中，我们发现，编译器不让我们继承Enum，但是当我们使用enum关键字定义一个枚举的时候，他会帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。 Enum实现了Serializable和Comparable接口，进行比较时只有同类型的enum才能进行比较，要想实现不同类型的enum之间的比较，只能重写compareTo方法 Enum&lt;E extends Enum&lt;E>> 一个Enum只接受一个Enum或者他的子类作为参数 compartTo12345678public final int compareTo(E o) &#123; Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; &#125; Java使用Enum&lt;E extends Enum&gt;声明Enum，并且在compareTo的中使用E作为参数。这两个条件限制Color.RED只能和Color定义出来的枚举进行比较 成员变量在Enum中，有两个成员变量，一个是名字(name)，一个是序号(ordinal)。序号是一个枚举常量，表示在枚举中的位置，从0开始，依次递增。 构造函数Enum是一个抽象类，不能被实例化，但是他也有构造函数。1234protected Enum(String name，int ordinal)&#123; this.name=name; this.ordinal=ordinal;&#125; 参考 Java 7 源码学习系列（二）——Enum","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"javap","slug":"javap","date":"2018-04-15T11:11:13.000Z","updated":"2018-04-20T13:17:12.174Z","comments":true,"path":"2018/04/15/javap/","link":"","permalink":"https://hsb786.github.io/2018/04/15/javap/","excerpt":"javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件","text":"javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件 1234567891011public class T01 &#123; private volatile int n; public void add() &#123; n++; &#125; private void sub() &#123; n--; &#125;&#125; javap T01 输出T01的public域及方法 javap -c T01 列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用 javap -p T01 输出所有类和成员 javap -v T01 输出栈大小，方法参数的个数 语法12345678910-help 帮助-l 输出行和变量的表-public 只输出public方法和域-protected 只输出public和protected类和成员-package 只输出包，public和protected类和成员，这是默认的-p -private 输出所有类和成员-s 输出内部类型签名-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，-verbose 输出栈大小，方法参数的个数-constants 输出静态final常量 编译版本 major version java版本 46 2 47 3 48 4 49 5 50 6 51 7 52 8","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"LinkedList","slug":"LinkedList","date":"2018-04-15T07:17:54.000Z","updated":"2018-04-21T07:32:36.433Z","comments":true,"path":"2018/04/15/LinkedList/","link":"","permalink":"https://hsb786.github.io/2018/04/15/LinkedList/","excerpt":"LinkedList是由双向链表实现的","text":"LinkedList是由双向链表实现的123456789101112131415161718192021222324public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; //头节点 transient Node&lt;E&gt; first; //尾节点 transient Node&lt;E&gt; last; public LinkedList() &#123; &#125; private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;&#125; 可以看出LinkedList存放了Node first,Node last两个节点，分别对应头节点和未节点Node是LinkedList的静态内部类。里面有三个元素：item存放数据，next存放下一个节点，prev存放上一个节点 public boolean add(E e)1234567891011121314151617public boolean add(E e) &#123; linkLast(e); return true;&#125;//添加e到链表尾部void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; public boolean remove(Object o)1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"},{"name":"集合","slug":"爪哇/集合","permalink":"https://hsb786.github.io/categories/爪哇/集合/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"ArrayList","slug":"ArrayList","date":"2018-04-15T06:18:58.000Z","updated":"2018-04-21T07:32:39.210Z","comments":true,"path":"2018/04/15/ArrayList/","link":"","permalink":"https://hsb786.github.io/2018/04/15/ArrayList/","excerpt":"以前都是看别人分析的ArrayList，现在尝试自己分析一下","text":"以前都是看别人分析的ArrayList，现在尝试自己分析一下 针对java8 ArrayList底层是用数组实现的。123456789101112131415161718192021222324252627282930313233343536public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; //默认初始容量 private static final int DEFAULT_CAPACITY = 10; //调用new ArrayList()时，底层数组指向EMPTY_EMEMENTDATE（空的数组） // static final修饰，节省空间，不用每次初始化都分配一块新的内存 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //ArrayList存放元素的数组 //新建一个空的ArrayList时，elementData==EMPTY_ELEMENTDATE； //执行添加或者初始化时指定元素个数时，elementDate将替换原来的EMPTY_ELEMENTDATE transient Object[] elementData; //ArrayList实际元素个数 private int size; public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;&#125; public boolean add(E e)1234567891011121314151617181920212223242526272829303132333435363738public boolean add(E e) &#123; //确定内部容量 ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; //如果数组指向EMPTY_ELEMENTDATE，就是初始化时调用的是无参构造函数 //那么minCapacity就等于DEFAULT_CAPACITY 10 与minCapacity的最大值。 //这样不用每次添加都扩容，一开始就分配了大小为10的数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //超过数组容量 //比如说当添加第11个元素时，minCapacity=11，此时elementData.lenth=10 //所以需要对数组扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //将数组容量扩容为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //扩容后，将原来的数组复制到新的数组中 elementData = Arrays.copyOf(elementData, newCapacity);&#125; java.util.Arrays12345678910111213141516//复制original数组前newLength位并返回public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType&#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //如果original.length&gt;newLength，则复制前newLength位到copy中 //否则将original全部复制到copy System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; public E remove(int index)1234567891011121314151617public E remove(int index) &#123; //判断下标有没有溢出 rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //将elementDate中要移除元素的后面元素都往前移一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将最后一个元素设为null，以便让GC回收 elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 总结ArrayList由于底层是由数组实现的，而数组的容量是固定的。所以添加元素时牵涉到数组的扩容，扩容时需要把原来的数组复制到扩容后的数组中。扩容为原来的1.5倍。 删除元素时，需要把待删除元素后面的元素往前移一位，并且将最后一位置为null。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"},{"name":"集合","slug":"爪哇/集合","permalink":"https://hsb786.github.io/categories/爪哇/集合/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-04-14T08:14:06.000Z","updated":"2018-04-20T13:19:06.738Z","comments":true,"path":"2018/04/14/Proxy/","link":"","permalink":"https://hsb786.github.io/2018/04/14/Proxy/","excerpt":"JDK动态代理通过java.lang.reflect.Proxy类以及java.lang.reflect.InvocationHandler接口来实现动态代理 InvocationHandlerInvocationHandler接口的唯一方法： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy: 代理类实例 method: 方法 args: 方法入参","text":"JDK动态代理通过java.lang.reflect.Proxy类以及java.lang.reflect.InvocationHandler接口来实现动态代理 InvocationHandlerInvocationHandler接口的唯一方法： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; proxy: 代理类实例 method: 方法 args: 方法入参 Proxypublic static Object newProxyInstance Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) loader： ClassLoader，定义由哪个ClassLoader对象类对生成的代理对象进行加载 interfaces：该实现类的所有接口 h：调用处理程序，表示当这个动态代理对象在调用方法时，会关联到哪一个InvocationHandler对象上 123public interface Hello &#123; void say(String name);&#125; 定义被代理的接口 12345678public class HelloImpl implements Hello &#123; @Override public void say(String name) &#123; System.out.println(&quot;Hello &quot; + name); &#125;&#125; 接口的实现类 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。 * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。 * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。 */public class DynamicProxy implements InvocationHandler &#123; //目标对象，被代理接口的实现类 private Object target; public DynamicProxy(Object target) &#123; this.target = target; &#125; /** * @param proxy 代理类实例 * @param method 方法 * @param args 方法入参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; /** * @Description: 获取代理对象 */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; private void before() &#123; System.out.println(&quot;Before&quot;); &#125; private void after() &#123; System.out.println(&quot;After&quot;); &#125;&#125; 执行程序12345678910111213public class ClientProxy &#123; public static void main(String[] args) &#123; Hello hello = new HelloImpl(); DynamicProxy dynamicProxy = new DynamicProxy(hello); Hello helloProxy = dynamicProxy.getProxy(); helloProxy.say(&quot;hh&quot;); &#125;&#125;//output: Before Hello hh After 用DynamicProxy类去包装HelloImpl实例，然后再调用Proxy类的工厂方法newProxyInstance()去动态地创建一个Hello接口的代理类，调用这个代理类的say()方法。 被代理方法的调用都是通过InvocationHadler的invoke来实现的。 Proxy.newProxyInstance这个方法的第二个参数，我们给这个代理对象提供了一组什么接口，那么这个代理对象就会实现了这组接口，这个时候我们可以将这个代理对象强制转化为这组接口中的任意一个。 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 动态代理，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，代理类也要变。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有用武之地了！ 总结 通过实现InvocationHandler接口来自定义自己的InvocationHandler；在实现的过程中，通过传入目标对象（被代理的对象）来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。 通过Proxy.newProxyInstance来动态创建代理类 通过代理对象调用目标方法，实际上是通过InvocationHandler实现类的invoke()方法调用 能否代理没有接口的类? CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。 CGLIB动态代理Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。 1234567891011121314151617181920212223public class CGLibProxy implements MethodInterceptor &#123; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123; return (T) Enhancer.create(cls, this); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; before(); Object result = proxy.invokeSuper(obj, args); after(); return result; &#125; private void before() &#123; System.out.println(&quot;Before&quot;); &#125; private void after() &#123; System.out.println(&quot;After&quot;); &#125;&#125; 需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。 与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧： 123CGLibProxy cgLibProxy = new CGLibProxy();HelloImpl helloProxy2 = cgLibProxy.getProxy(HelloImpl.class);helloProxy2.say(&quot;cg&quot;); 与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象 JDK动态代理和CGLIB代理生成的区别 JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。 CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。 在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。 参考 Proxy 那点事儿 动态代理 java的动态代理机制详解","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"ThreadLocal","slug":"ThreadLocal","date":"2018-04-14T07:06:57.000Z","updated":"2018-04-20T13:19:42.824Z","comments":true,"path":"2018/04/14/ThreadLocal/","link":"","permalink":"https://hsb786.github.io/2018/04/14/ThreadLocal/","excerpt":"早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。","text":"早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。 ThreadLocal常用方法： public void set(T value)：将值放入线程局部变量中 public T get()：从线程局部变量中获取值 public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收） protected T initialValue()：返回线程局部变量中的初始值（默认为 null） 为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。 ThreadLocal简单实现1234567891011121314151617181920212223242526public class MyThreadLocal&lt;T&gt; &#123; private Map&lt;Thread, T&gt; container = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;()); public void set(T value) &#123; container.put(Thread.currentThread(), value); &#125; public T get() &#123; Thread thread = Thread.currentThread(); T value = container.get(thread); if (value == null &amp;&amp; !container.containsKey(thread)) &#123; value = initialValue(); container.put(thread, value); &#125; return value; &#125; public void remove() &#123; container.remove(Thread.currentThread()); &#125; protected T initialValue() &#123; return null; &#125;&#125; ThreadLocal 具体有哪些使用案例呢？通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。(每个线程应该拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接) 注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！ 参考 ThreadLocal 那点事儿","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"IOC-实现原理（转载）","slug":"IOC-实现原理（转载）","date":"2018-04-14T05:22:40.000Z","updated":"2018-04-20T13:16:55.928Z","comments":true,"path":"2018/04/14/IOC-实现原理（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/14/IOC-实现原理（转载）/","excerpt":"本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部 IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。","text":"本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部 IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。从实例出发，先看看以下 Action 代码。 123456789101112131415161718@Beanpublic class ProductAction extends BaseAction &#123; @Inject private ProductService productService; @Request(&quot;GET:/product/&#123;id&#125;&quot;) public Result getProductById(long productId) &#123; if (productId == 0) &#123; return new Result(ERROR_PARAM); &#125; Product product = productService.getProduct(productId); if (product != null) &#123; return new Result(OK, product); &#125; else &#123; return new Result(ERROR_DATA); &#125; &#125;&#125; 以上使用了两个自定义注解：@Bean 与 @Inject。在 ProductAction 类上标注了 @Bean 注解，表示该类会交给“容器”处理，以便加入依赖注入框架。 在 produceService 字段上标注了 @Inject 注解，表示该字段将会被注入进来，而无需 new ProductServiceImpl()，实际上 new 这件事情不是我们做的，而是框架做的，也就是说控制权正好反过来了，所以“依赖注入（DI）”也称作“控制反转（IoC）”。 那么，应该如何实现依赖注入框架呢？首先还是看看下面的 BeanHelper 类吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BeanHelper &#123; private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); static &#123; try &#123; // 获取并遍历所有的 Bean（带有 @Bean 注解的类） List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class); for (Class&lt;?&gt; beanClass : beanClassList) &#123; // 创建 Bean 实例 Object beanInstance = beanClass.newInstance(); // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例） beanMap.put(beanClass, beanInstance); &#125; // 遍历 Bean Map for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123; // 获取 Bean 类与 Bean 实例 Class&lt;?&gt; beanClass = beanEntry.getKey(); Object beanInstance = beanEntry.getValue(); // 获取 Bean 类中所有的字段（不包括父类中的方法） Field[] beanFields = beanClass.getDeclaredFields(); if (ArrayUtil.isNotEmpty(beanFields)) &#123; // 遍历所有的 Bean 字段 for (Field beanField : beanFields) &#123; // 判断当前 Bean 字段是否带有 @Inject 注解 if (beanField.isAnnotationPresent(Inject.class)) &#123; // 获取 Bean 字段对应的接口 Class&lt;?&gt; interfaceClass = beanField.getType(); // 获取该接口所有的实现类 List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass); if (CollectionUtil.isNotEmpty(implementClassList)) &#123; // 获取第一个实现类 Class&lt;?&gt; implementClass = implementClassList.get(0); // 从 Bean Map 中获取该实现类对应的实现类实例 Object implementInstance = beanMap.get(implementClass); // 设置该 Bean 字段的值 beanField.setAccessible(true); // 必须使该字段可访问 beanField.set(beanInstance, implementInstance); &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123; return beanMap; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123; return (T) beanMap.get(cls); &#125;&#125; 其实很简单，依赖注入其实分为两个步骤：1. 通过反射创建实例；2. 获取需要注入的接口实现类并将其赋值给该接口。以上代码中的两个 for 循环就是干这两件事情的。 依赖注入框架实现完毕！ 大家上面看到的 BeanHelper 类，其实兼任了两种职责：1.初始化所有的 Bean 类；2.实现依赖注入。 这违法了设计模式中的“单一责任原则”，所有有必要将其重构一下，现在的 BeanHelper 类更加苗条了，只是负责初始化 Bean 类而已。代码如下： 1234567891011121314151617181920212223242526272829public class BeanHelper &#123; // Bean 类 =&gt; Bean 实例 private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); static &#123; try &#123; // 获取并遍历所有的 Bean（带有 @Bean 注解的类） List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class); for (Class&lt;?&gt; beanClass : beanClassList) &#123; // 创建 Bean 实例 Object beanInstance = beanClass.newInstance(); // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例） beanMap.put(beanClass, beanInstance); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123; return beanMap; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123; return (T) beanMap.get(cls); &#125;&#125; 那么，依赖注入功能放哪里呢？我搞了一个 IOCHelper，用这个类来实现 IOC 功能。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class IOCHelper &#123; static &#123; try &#123; // 获取并遍历所有的 Bean 类 Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123; // 获取 Bean 类与 Bean 实例 Class&lt;?&gt; beanClass = beanEntry.getKey(); Object beanInstance = beanEntry.getValue(); // 获取 Bean 类中所有的字段（不包括父类中的方法） Field[] beanFields = beanClass.getDeclaredFields(); if (ArrayUtil.isNotEmpty(beanFields)) &#123; // 遍历所有的 Bean 字段 for (Field beanField : beanFields) &#123; // 判断当前 Bean 字段是否带有 @Inject 注解 if (beanField.isAnnotationPresent(Inject.class)) &#123; // 获取 Bean 字段对应的接口 Class&lt;?&gt; interfaceClass = beanField.getType(); // 判断接口上是否标注了 @Impl 注解 Class&lt;?&gt; implementClass = null; if (interfaceClass.isAnnotationPresent(Impl.class)) &#123; // 获取强制指定的实现类 implementClass = interfaceClass.getAnnotation(Impl.class).value(); &#125; else &#123; // 获取该接口所有的实现类 List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass); if (CollectionUtil.isNotEmpty(implementClassList)) &#123; // 获取第一个实现类 implementClass = implementClassList.get(0); &#125; &#125; // 若存在实现类，则执行以下代码 if (implementClass != null) &#123; // 从 Bean Map 中获取该实现类对应的实现类实例 Object implementInstance = beanMap.get(implementClass); // 设置该 Bean 字段的值 if (implementInstance != null) &#123; beanField.setAccessible(true); // 取消类型安全检测（可提高反射性能） beanField.set(beanInstance, implementInstance); // beanInstance 是普通实例，或 CGLib 动态代理实例（不能使 JDK 动态代理实例） &#125; &#125; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可见，IOCHelper 是依赖于 BeanHelper 的。这样分离，还有一个好处，就是方便实现 ServiceHelper 与 AOPHelper。也就是说，首先通过 BeanHelper 初始化所有的 Bean 类，然后依次初始化 ServiceHelper、IOCHelper、AOPHelper，这个顺序不能搞错。因为在 ServcieHelper 中，对 Servcie 实现类进行了动态代理，所有保证了 IOC 注入进来的是代理类，而并非目标类。 参考 IOC 实现原理 1000行代码读懂Spring（一）- 实现一个基本的IoC容器","categories":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"Servlet","slug":"Servlet","date":"2018-04-14T04:35:27.000Z","updated":"2018-04-20T13:19:19.304Z","comments":true,"path":"2018/04/14/Servlet/","link":"","permalink":"https://hsb786.github.io/2018/04/14/Servlet/","excerpt":"Servlet概述Servlet是在Java中创建web应用程序的J2ee 服务端技术。javax.servlet 和 javax.servlet.http包中提供了编写servlet的接口和类。所有的servlet都要实现javax.servlet.Servlet接口。该接口中定义了一个Servlet生命周期中的所有方法。 Servlet接口定义了Servlet与Servlet容器之间的契约，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法。在一个应用程序中，每种Servlet类型只有一个实例。 用户请求指使Servlet容器调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例。","text":"Servlet概述Servlet是在Java中创建web应用程序的J2ee 服务端技术。javax.servlet 和 javax.servlet.http包中提供了编写servlet的接口和类。所有的servlet都要实现javax.servlet.Servlet接口。该接口中定义了一个Servlet生命周期中的所有方法。 Servlet接口定义了Servlet与Servlet容器之间的契约，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法。在一个应用程序中，每种Servlet类型只有一个实例。 用户请求指使Servlet容器调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例。对于每个应用程序，Servlet容器还会创建一个ServletContext实例，封装了上下文（应用程序的环境详情）。每个上下文只有一个ServletContext，每个Servlet实例也都有一个封装Servlet配置的ServletConfig。 多数情况下，web应用程序都使用http协议，所以，我们多数时候都通过继承HttpServlet类来实现自己的Servlet。 Servlet API的层次结构javax.servlet.Servlet是Servlet Api的最上层接口。还有一些其他的接口和类是我们在使用servlet的时候需要关注的。 Servlet 接口javax.servlet.Servlet 是Servlet Api的最上层接口，Servlet接口定义了一系列servlet的生命周期方法（init、service、destory等）。所有的Servlet类都需要继承这个接口。该接口中定义了以下方法： public abstract void init(ServletConfig paramServletConfig) throws ServletException 该方法由servlet容器调用，用于初始化servlet以及servlet配置参数。在init()方法执行之前，servlet是无法处理用户请求的。在servlet生命周期中该方法只会被调用一次，他会使servlet类不同区别于普通的java对象。我们可以扩展该方法来初始化资源，如数据库连接、socket连接等。 public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException 该方法负责处理客户端请求。当servlet容器收到客户端请求时，它会创建一个新线程并执行service()方法，并把request 和 response作为参数传递给该方法。servlet通常运行在多线程环境中，所以开发人员应该使用同步来保证访问共享资源的线程安全性问题。 public abstract void destroy() 该方法在整个servlet生命周期中只会被调用一次来关闭所有资源。有点像Java中的finalize方法。 public abstract ServletConfig getServletConfig() 该方法返回一个servlet配置对象，其中包含servlet中所有初始化参数和启动配置。我们可以用这个方法来获取servlet的初始化参数，这些参数一般被定义在web.xml或servlet 3的注解中。后面会介绍ServletConfig接口。 public abstract String getServletInfo() 该方法返回包含servlet信息的字符串，比如它的作者、版本和版权。返回的字符串应该是纯文本，不能有标记符号。 ServletConfig 接口javax.servlet.ServletConfig用于给servlet传递配置信息。每个servlet都有属于它自己的ServletConfig对象，该对象由servlet容器负责实例化。 ServletContext 接口javax.servlet.ServletContext接口用于描述应用程序的相关信息。ServletContext是一个独立的对象，可用于web应用程序中所有的servlet。当我们想要一些初始化的参数可用于web应用程序中多个或全部servlet时，我们可以使用ServletContext对象并且在web.xml中使用&lt; context-param&gt;标签定义参数。 ServletRequest 接口ServletRequest接口是用来向servlet提供客户端请求信息。每一个客户端请求到达Servlet容器的时候，他都会创建一个ServletRequest对象，并将其传递对应的servlet的service()方法。 Object getAttribute(String name) 返回指定的参数名对应的属性值。如果对应的参数不存在则返回null。 String getParameter(String name) 以字符串的形式返回请求参数值。 attribute和parameter的区别是什么呢？ 来源不同 参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的； 属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的. 操作不同 参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取； 属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute() 数据类型不同 参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。 属性（attribute）的值可以是任意一个Object类型。 ServletResponse 接口servlet使用ServletResponse向客户端发送响应。和ServletRequest类似，一个客户端请求到达Servlet容器的时候，他都会创建一个ServletResponse对象，并将其传递对应的servlet的service()方法。最终，该response对象用于给客户端生成html响应。 RequestDispatcher 接口RequestDispatcher 接口用于把一个请求转发给同一个servlet上下文中的其他的资源（Html、jsp、servlet）来处理。也可以用它来把另一个资源的内容包含到响应中。此接口用于同一个servlet上下文中的servlet相互沟通。 RequestDispatcher 接口的主要方法： void forward(ServletRequest request, ServletResponse response) 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。 void include(ServletRequest request, ServletResponse response) 把另一个资源的内容包含到当前响应中。 forward和include的区别： 如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。 用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。 在servlet中可以使用getRequestDispatcher(String path)来获取一个RequestDispatcher。路径必须以/开头，并且是针对于当前context的根路径的相对地址。 HTTPSessionHTTPSession对象在用户第一次访问网站的时候自动创建，可以通过HttpServletRequest的getSession方法获取该对象，一个用户最多只能有一个HttpSession，放入到HttpSession的值，是存储在内存中的，也可以在服务器转储到二级缓存中。放到HttpSession的值不限于String类型，可以是任意实现java.io.Serializale的java对象。 所有保存在HttpSession的数据不会被发送到客户端，Servlet容器为每个HttpSession生成唯一的标识，并将该标识发送给浏览器，或创建一个名为JSESSIONNID的cookie，或者在URL后面附加一个名为jessionid的参数，在后续的请求中，浏览器只需要将标识id放送给服务器即可。 参考 [译]Java Servlet初级知识 Servlet学习笔记","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"【译】如何重置一个ArrayList--clear vs removeAll （转载）","slug":"译-如何重置一个ArrayList-clear-vs-removeAll","date":"2018-04-13T07:55:17.000Z","updated":"2018-04-20T13:23:14.949Z","comments":true,"path":"2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/","link":"","permalink":"https://hsb786.github.io/2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/","excerpt":"很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置clear或removeAll。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现java.lang.OutOfMemoryError: Java Heap Space。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。","text":"很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置clear或removeAll。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现java.lang.OutOfMemoryError: Java Heap Space。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。 Clear() vs RemoveAll(Collection c)为了更好的比较这两个方法，阅读他们源码是很重要的。可以在java.utils.ArrayList类中找到clear()方法，不过为了方便我将它引入到了这里。下面的代码来自JDK 1.7.0_40版本。如果你想要学习更多的有关性能监控和调优的知识，我强烈建议阅读Scott Oaks写的Java Performance the Definitive Guide,它包含了java 7和一点java 8。下面是clear()的代码片段: 12345678910/** * Removes all of the elements from this list.The list will * be empty after this call returns. */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 大家可以看出，clear()在循环遍历ArrayList，并且将每一个元素都置为null，使它们在没有被外部引用的情况下可以被垃圾回收。相似的，我们可以在java.util.AbstractCollection类中查看removeAll(Collention c)的代码，下面是代码片段: 12345678910111213public boolean removeAll(Collection&lt;?&gt; c) &#123; //判断对象是否为null Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified; &#125; 这个方法会检查迭代器顺序返回的每个元素是否包含在特定的集合中。如果存在，调用迭代器的remove方法将它从集合中移除。因为会用到contains方法，removeAll的复杂度是O(n^2)。所以在想要重置一个大的ArrayList时，这种方法是绝对不可取的。下面我们比较一下两者在重置一个包含100K个元素时的性能差异。 删除一个包含100k个元素的列表中的所有元素 我本来想在例子中尝试重置一个包含10M个元素的列表，不过在超过半个小时等待removeAll()结束后，我决定将元素的数量降为100K。在这种情况下，两个方法的差距也是很明显的。removeAll()比clear()多花费了10000倍的时间。事实上，在API中clear()和removeAll(Collection c)这两个方法的目的是不同的。clear()方法是为了通过删除所有元素而重置列表，而removeAll(Collection c)是为了从集合中删除某些存在于另一个提供的集合中的元素，并不是为了从集合中移除所有元素。所以如果你的目的是删除所有元素，用clear(),如果你的目的是删除某些存在于另一集合的元素，那么选择removeAll(Collection c)方法。 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList; /** * Java Program to remove all elements from list in Java and comparing * performance of clearn() and removeAll() method. * * @author Javin Paul */ public class ArrayListResetTest &#123; private static final int SIZE = 100_000; public static void main(String args[]) &#123; // Two ArrayList for clear and removeAll ArrayList numbers = new ArrayList(SIZE); ArrayList integers = new ArrayList(SIZE); // Initialize ArrayList with 10M integers for (int i = 0; i &amp;lt; SIZE; i++) &#123; numbers.add(new Integer(i)); integers.add(new Integer(i)); &#125; // Empty ArrayList using clear method long startTime = System.nanoTime(); numbers.clear(); long elapsed = System.nanoTime() - startTime; System.out.println(&quot;Time taken by clear to empty ArrayList of 1M elements (ns): &quot; + elapsed); // Reset ArrayList using removeAll method startTime = System.nanoTime(); integers.removeAll(integers); long time = System.nanoTime() - startTime; System.out.println(&quot;Time taken by removeAll to reset ArrayList of 1M elements (ns): &quot; + time); &#125; &#125; Output: Time taken by clear to empty ArrayList of 100000 elements (ns): 889619 Time taken by removeAll to reset ArrayList of 100000 elements (ns): 36633112126 由于程序使用了两个arrayList存储Integers，所以在运行时要确保有足够的内存，尤其是你想比较在列表存有1M个元素时，两种方法的性能差异。另外，由于使用了在数字中加入下划线的特性，所以需要java7来运行。如果没有JDK7，也可以移除SIZE常量中的下划线。 参考 【译】如何重置一个ArrayList–clear vs removeAll","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"【译】以生产者消费者为例阐述如何使用wait，notify和notifyAll （转载）","slug":"译-以生产者消费者为例阐述如何使用wait，notify和notifyAll","date":"2018-04-13T07:34:36.000Z","updated":"2018-04-20T13:23:22.479Z","comments":true,"path":"2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/","link":"","permalink":"https://hsb786.github.io/2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/","excerpt":"在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:Producer(生产者)和Consumer(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。","text":"在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:Producer(生产者)和Consumer(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。 在代码中展示如何使用wait和notify尽管wait和notify是相当基础的概念，并且他们定义在Object类中，但要想在代码中使用他们并非易事。你可以在面试中让面试者通过手写代码解决Producer者和Consumer者问题来验证，我相信大多数人都会犯在错误的地方同步，没有在正确的对象上调用wait之类的错。讲真，这些常常会困惑许多程序员。第一个困惑点来自怎样调用wait方法，因为wait方法并不是定义在Thread类中，所以不能简单的Thread.wait()。而许多Java开发者习惯于Thread.sleep(),所以常常错误的想用同样的方式调用wait。实际上，wait()方法需要在一个被两个线程共享的对象上调用，例如在Producer者和消费Consumer的问题中，两个线程共享对象是一个队列。第二个困惑点来自wait方法应该在同步块还是同步方法中调用？如果使用同步块，那么哪个对象应该放到同步块中？这个对象和你想要获得锁的对象应该是同一个。在我们的例子中，这个对象就是两个线程共享的队列。 在循环中使用wait和notify，而不是If代码块中在你已经了解需要在一个共享的对象上调用wait方法后，接下来就是学会避免许多java开发者犯的错—在If代码块中调用wait而不是while循环中。因为需要在一定的条件下调用wait，比如Producer线程要在队列满了的情况下调用wait，所以第一反应都是使用If语句。但是，在If代码块中调用wait会产生bug，因为线程存在一定的可能在等待条件没有改变的情况下假唤醒(spurious wake up)。所以如果没有使用循环在线程唤醒后检查等待条件，可能会造成尝试在已经满了的队列中插入元素或者在空了的队列中取元素。这就是为什么我们要在while循环中调用wait而不是if。 Java中使用wait(),notify(),notifyAll()的例子下面是在Java中使用wait(),notify(),notifyAll()的例子。在这个程序中，有两个线程(PRODUCTOR和CONSUMER)，用继承了Thread类的Producer和Consumer类实现。Prodcuer和Consumer的业务逻辑写在他们各自的run()方法中。并且实现一个LinkedList，当做共享队列。Producer在一个死循环中不断在队列中插入随机数，直到队列满了。我们会检查while(queue.size == maxSize),需要注意的是在检查之前需要给队列加上同步锁以保证在检查时没有另一个线程修改队列。如果队列满了，PRODUCER线程就会休眠，直到CONSUMER消费了队列中的元素并且调用notify()方法通知PRODUCER线程。wait和notify都是在共享的对象(我们的例子中是队列)上调用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.LinkedList;import java.util.Queue;import java.util.Random;/** * Simple Java program to demonstrate How to use wait, notify and notifyAll() * method in Java by solving producer consumer problem. * * @author Javin Paul */public class MultipleThread &#123; public static void main(String args[]) &#123; System.out.println(&quot;How to use wait and notify method in Java&quot;); System.out.println(&quot;Solving Producer Consumper Problem&quot;); Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;(); int maxSize = 10; Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;); Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;); producer.start(); consumer.start(); &#125;&#125;/** * Producer Thread will keep producing values for Consumer * to consumer. It will use wait() method when Queue is full * and use notify() method to send notification to Consumer * Thread. * @author WINDOWS 8 * */class Producer extends Thread &#123; private Queue&lt;Integer&gt; queue; private int maxSize; public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name) &#123; super(name); this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.size() == maxSize) &#123; try &#123; System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;); queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; Random random = new Random(); int i = random.nextInt(); System.out.println(&quot;Producing value : &quot; + i); queue.add(i); queue.notifyAll(); &#125; &#125; &#125;&#125;/** * Consumer Thread will consumer values form shared queue. * It will also use wait() method to wait if queue is * empty. It will also use notify method to send * notification to producer thread after consuming values * from queue. * @author WINDOWS 8 **/class Consumer extends Thread &#123; private Queue&lt;Integer&gt; queue; private int maxSize; public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123; super(name); this.queue = queue; this.maxSize = maxSize; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue) &#123; while (queue.isEmpty()) &#123; System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;); try &#123; queue.wait(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; System.out.println(&quot;Consuming value : &quot; + queue.remove()); queue.notifyAll(); &#125; &#125; &#125;&#125;Output How to use wait and notify method in Java Solving Producer Consumper Problem Queue is empty,Consumer thread is waiting for producer thread to put something in queue Producing value : -1692411980 Producing value : 285310787 Producing value : -1045894970 Producing value : 2140997307 Producing value : 1379699468 Producing value : 912077154 Producing value : -1635438928 Producing value : -500696499 Producing value : -1985700664 Producing value : 961945684 Queue is full, Producer thread waiting for consumer to take something from queue Consuming value : -1692411980 Consuming value : 285310787 Consuming value : -1045894970 Consuming value : 2140997307 Consuming value : 1379699468 Consuming value : 912077154 Consuming value : -1635438928 Consuming value : -500696499 Consuming value : -1985700664 Consuming value : 961945684 Queue is empty,Consumer thread is waiting for producer thread to put something in queue 使用wait，notify，notifyAll需要注意的 在Java中可以使用wait，notify，notifyAll完成多线程(不仅仅是两个线程)的内部通信。 在同步方法或同步块中使用wait，notify，notifyAll，否则JVM会抛出IllegalMonitorStateException 在循环中调用wait，notify。 在线程共享的对象上调用wait 偏向选择notifyAll，而不是notify","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"【译】Java8中的扩展(default/extension)方法 （转载）","slug":"Java-8中的扩展-Default-Defender-Extension-方法","date":"2018-04-13T07:14:18.000Z","updated":"2018-04-20T13:17:08.750Z","comments":true,"path":"2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/","link":"","permalink":"https://hsb786.github.io/2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/","excerpt":"Java 8允许开发者使用default和static两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。","text":"Java 8允许开发者使用default和static两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。 Default方法的例子Java 8让我们可以通过default关键字为接口添加非抽象的方法。这一特性也被称作Extension(扩展)方法。下面是第一个例子： 12345678interface Multiplication&#123; int multiply(int a, int b); default int square(int a)&#123; return multiply(a, a); &#125; &#125; 除了抽象方法multiply()之外，接口Multiplication还包含一个default方法square()。任何实现Multiplication接口的类只需实现抽象方法multiply，default方法square()可以直接使用。 12345678Multiplication product = new Multiplication()&#123; @Override public int multiply(int x, int y)&#123; return x*y; &#125;&#125;; int square = product.square(2); int multiplication = product.multiply(2, 3); product是个匿名类。这段代码有点啰嗦了，用了6行实现一个简单地乘法的功能。我们可以利用lambda表达式来简化一下代码，lambda表达式也是Java 8中新引入的。因为我们的接口只包含一个抽象方法，而且lambda表达式也是SAM(Single Abstract method单一抽象方法)类型的。我们可以用lambda表达式来替代匿名类将代码简化成下面的样子。123Multiplication lambda = (x, y) -&gt; x*y; int product = lambda.multiply(3, 4); int square = lambda.square(4); 以上就是在接口中使用default方法的例子。现在，你可以毫无顾虑的在旧的接口中扩展新的方法，只要这些方法是default或static的就不用担心会破坏接口的实现类。 123456789101112131415161718192021222324252627282930313233343536373839404142/**Java Program to demonstrate use of default method in Java 8. * You can define non-abstract method by using default keyword, and more * than one default method is permitted, which allows you to ship default skeletal * implementation on interface itself. * @author Javin Paul */ public class Java8DefaultMethodDemo&#123; public static void main(String args[]) &#123; // Implementing interface using Anonymous class Multiplication product = new Multiplication()&#123; @Override public int multiply(int x, int y)&#123; return x*y; &#125; &#125;; int squareOfTwo = product.square(2); int cubeOfTwo = product.cube(2); System.out.println(&quot;Square of Two : &quot; + squareOfTwo); System.out.println(&quot;Cube of Two : &quot; + cubeOfTwo); // Since Multiplication has only one abstract method, it can // also be implemented using lambda expression in Java 8 Multiplication lambda = (x, y) -&gt; x*y; int squareOfThree = lambda.square(3); int cubeOfThree = lambda.cube(3); System.out.println(&quot;Square of Three : &quot; + squareOfThree); System.out.println(&quot;Cube of Three : &quot; + cubeOfThree); &#125; &#125; interface Multiplication&#123; int multiply(int a, int b); default int square(int a)&#123; return multiply(a, a); &#125; default int cube(int a)&#123; return multiply(multiply(a, a), a); &#125; &#125; Output : Square of Two : 4 Cube of Two : 8 Square of Three : 9 Cube of Three : 27 这是个很好的关于如何使用default方法在接口中方便的添加方法的例子。也展示了如何避免一个额外的帮助类，比如Collections类。它仅仅提供了一些用于Collection的工具方法，而现在我们可以直接在Collection中定义这些方法。在上面的例子中，我们有一个包含一个抽象方法multiply(a,b)的接口Multiplication，接口还包括两个依赖于multiply(a,b)方法的非抽象方法square(a)和cube(b)。接口的实现类只需要实现multiply(a,b)方法，就可以直接使用square(a)和cube(b)方法了。 default方法的关键点 在Java8中你可以在接口中添加default方法 default方法的出现使得接口和抽象类的不同变得模糊。所以，当在面试中被问到这个问题，别忘了提一下，以前只能通过抽象类实现的事情，现在也可以通过default方法实现了。 default并不是一个新的关键字，在JDK1.1中就是保留关键字 接口中default方法的数量没有限制 如果接口C继承了接口A和B，如果A和B中拥有一样的default方法，编译器在编译过程中会报错。为了避免歧义，这在Java 8中是不允许的。所以当default方法有冲突时，是不可以多继承的 在JDK1.8中有许多关于default方法的例子，比如forEach方法。也可以查看java.util.Map中新添的putIfAbsent方法，在JDK1.8之前，我们只能ConcurrentMap来使用它。 以上就是default方法。不得不说，这是一个巨大的突破，使我们可以更好更方便的使用接口。了解CurrentMap的putIfAbsent方法可以帮助我们更好的记住default方法。在JDK1.7中，putIfAbsent方法并不存在于Map接口中，所以为了使用putIfAbsent方法，必须将Map接口指向的ConcurrentMap对象强制转换成ConcurrentMap。但Java 8引入扩展方法之后，Map接口中也有了putIfAbsent方法。 参考 【译】Java8中的扩展(default/extension)方法","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"【译】如何在java中使用ConcurrentHashMap（转载）","slug":"【译】如何在java中使用ConcurrentHashMap","date":"2018-04-13T06:41:41.000Z","updated":"2018-04-20T13:14:54.280Z","comments":true,"path":"2018/04/13/【译】如何在java中使用ConcurrentHashMap/","link":"","permalink":"https://hsb786.github.io/2018/04/13/【译】如何在java中使用ConcurrentHashMap/","excerpt":"ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。","text":"ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。 Java中ConcurrentHashMap的实现CHM引入了分割，并提供了HashTable支持的所有的功能。在CHM中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。 另一个重要点是在迭代遍历CHM时，keySet返回的iterator是弱一致和fail-safe的，可能不会返回某些最近的改变，并且在遍历过程中，如果已经遍历的数组上的内容变化了，不会抛出ConcurrentModificationExceptoin的异常。 CHM默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，CHM还使用了ReentrantLock来对segments加锁。 Java中ConcurrentHashMap putifAbsent方法的例子很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码 1234567synchronized(map)&#123; if (map.get(key) == null)&#123; return map.put(key, value); &#125; else&#123; return map.get(key); &#125;&#125; 上面这段代码在HashMap和HashTable中是好用的，但在CHM中是有出错的风险的。这是因为CHM在put操作时并没有对整个Map加锁，所以一个线程正在put(k,v)的时候，另一个线程调用get(k)会得到null，这就会造成一个线程put的值会被另一个线程put的值所覆盖。当然，你可以将代码封装到synchronized代码块中，这样虽然线程安全了，但会使你的代码变成了单线程。CHM提供的putIfAbsent(key,value)方法原子性的实现了同样的功能，同时避免了上面的线程竞争的风险。 什么时候使用ConcurrentHashMapCHM适用于读者数量超过写者时，当写者数量大于等于读者时，CHM的性能是低于Hashtable和synchronized Map的。这是因为当锁住了整个Map时，读操作要等待对同一部分执行写操作的线程结束。CHM适用于做cache,在程序启动时初始化，之后可以被多个请求线程访问。正如Javadoc说明的那样，CHM是HashTable一个很好的替代，但要记住，CHM的比HashTable的同步性稍弱。 总结现在我们知道了什么是ConcurrentHashMap和什么时候该用ConcurrentHashMap，下面我们来复习一下CHM的一些关键点。 CHM允许并发的读和线程安全的更新操作 在执行写操作时，CHM只锁住部分的Map 并发的更新是通过内部根据并发级别将Map分割成小部分实现的 高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争 CHM的所有操作都是线程安全 CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常 CHM不允许null的键值 可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map 参考 【译】如何在java中使用ConcurrentHashMap","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"【译】Executor, ExecutorService 和 Executors 间的不同 （转载）","slug":"difference-between-executor-executorService","date":"2018-04-13T05:21:41.000Z","updated":"2018-04-20T13:15:24.474Z","comments":true,"path":"2018/04/13/difference-between-executor-executorService/","link":"","permalink":"https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/","excerpt":"java.util.concurrent.Executor, java.util.concurrent.ExecutorService, java.util.concurrent. Executors 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。","text":"java.util.concurrent.Executor, java.util.concurrent.ExecutorService, java.util.concurrent. Executors 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：FixedThreadPool(包含固定数目的线程)，CachedThreadPool(可根据需要创建新的线程)等等。 ExecutorExecutor, ExecutorService, 和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。 123public interface Executor &#123; void execute(Runnable command);&#125; 不同于 java.lang.Thread 类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 difference between Thread and Executor 来了解 Thread 和 Executor 间更多的不同。 ExecutorServiceExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用 shutDown 方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。 Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get() 方法获得执行结果。需要注意的是，Future.get() 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。 通过 ExecutorService.submit() 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 cancel() 方法用来取消执行 pending 中的任务。 ExecutorService 部分代码如下： 123456public interface ExecutorService extends Executor &#123; void shutdown(); &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;&#125; ExecutorsExecutors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。 Executors 部分代码： 123456789public class Executors &#123; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125;&#125; 下面详细看一下三者的区别： Executor vs ExecutorService vs Executors正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解： Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口 Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。 Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。 Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。 Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。 总结下表列出了 Executor 和 ExecutorService 的区别： Executor ExecutorService Executor 是 Java 线程池的核心接口，用来并发执行提交的任务 ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法 提供execute()方法用来提交任务 提供submit()方法用来提交任务 execute()方法无返回值 submit()方法返回Future对象，可用来获取任务执行结果 不能取消任务 可以通过Future.cancel()取消pending中的任务 没有提供和关闭线程池有关的方法 提供了关闭线程池的方法 参考 【译】Executor, ExecutorService 和 Executors 间的不同","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"vscode-database","slug":"vscode-database","date":"2018-04-13T03:55:59.000Z","updated":"2018-04-20T13:19:53.435Z","comments":true,"path":"2018/04/13/vscode-database/","link":"","permalink":"https://hsb786.github.io/2018/04/13/vscode-database/","excerpt":"最近发现了一个很好用的vscode插件, vscode-database 迷上了vscode","text":"最近发现了一个很好用的vscode插件, vscode-database 迷上了vscode 快捷键 命令 语义 ctrl q querySQL ctrl shift e Run selected text as SQL query","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"触发器","slug":"触发器","date":"2018-04-13T03:43:11.000Z","updated":"2018-04-20T13:20:20.879Z","comments":true,"path":"2018/04/13/触发器/","link":"","permalink":"https://hsb786.github.io/2018/04/13/触发器/","excerpt":"对某一个表的某种操作，触发某种条件，从而执行的一段程序 new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。 old：旧数据，数据库里原先有的数据","text":"对某一个表的某种操作，触发某种条件，从而执行的一段程序 new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。 old：旧数据，数据库里原先有的数据 说明：在把userjob(用户岗位关联表)中的success(审批状态)更新为true时，自动在成绩表中出入数据；否则说明没有审批没有通过，把成绩表中对应的数据删除1234CREATE TRIGGER `insertScore` AFTER UPDATE ON `userjob` FOR EACH ROW if new.success=true theninsert into score(id) values(new.id);else delete from score where id=new.id;end if 说明：在删除userjob(用户岗位关联表)的数据时，自动删除成绩表对应中的数据123CREATE TRIGGER `deleteScore` BEFORE DELETE ON `userjob` FOR EACH ROW if old.success=true thendelete from score where id=old.id;end if","categories":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"索引","slug":"索引","date":"2018-04-12T12:56:19.000Z","updated":"2018-04-20T13:22:39.072Z","comments":true,"path":"2018/04/12/索引/","link":"","permalink":"https://hsb786.github.io/2018/04/12/索引/","excerpt":"索引索引（Index）是帮助MySQL高效获取数据的数据结构 排好序的快速查找数据结构 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。","text":"索引索引（Index）是帮助MySQL高效获取数据的数据结构 排好序的快速查找数据结构 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。 优势 提高数据检索效率，降低数据库的IO成本 通过索引对数据进行排序，降低数据排序的成本，降低了消耗 劣势 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引列也是要占空间的 虽然索引列大大提高了查询速度，同时会降低更新表的速度。因为更新表时，还要保存一下索引文件每次更新添加了索引列的字段 哪些情况需要创建索引 主键自动建立唯一索引 （不需要自己建） 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外键关系建立索引 （自动建立） 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度 查询中统计或者分组的字段 哪些情况不需要创建索引 表记录太小 经常增删改的表 某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果","categories":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"Java虚拟机基础","slug":"Java虚拟机基础","date":"2018-04-12T12:01:50.000Z","updated":"2018-04-21T04:19:49.302Z","comments":true,"path":"2018/04/12/Java虚拟机基础/","link":"","permalink":"https://hsb786.github.io/2018/04/12/Java虚拟机基础/","excerpt":"内存区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。","text":"内存区域Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。 JVM(Java Virtual Machine)JVM并不是专为Java所实现的。实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。 JVM通过执行Java bytecode可以使java代码在不改变的情况下运行在各种硬件之上，因此实现Java平台无关性 JVM = 类加载器 Class Loader + 执行引擎 Execution Engine + 运行时数据区域 Runtime Data Area 首先Java源代码文件被Java编译器编译为字节码文件，然后JVM中的类加载器加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM中的运行时数据区（内存）会用来存储程序执行期间需要用到的数据和相关信息。 Class LoaderClassLoader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它并不负责这个类文件能否执行，而这个是执行引擎负责的。 Execution Engine执行字节码，或者执行本地方法 Runtime DataArea指JVM在运行期间，其对JVM内存空间的划分和分配。 程序计数器（Program Counter Register）一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。 当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。 Java虚拟机栈（Java Virtual Machine Stacks）该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 在Java虚拟机规范中，对这个区域规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 本地方法栈（Native Method Stacks）该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。 和JVM栈一样，也会抛出StackOverflowError和OutOfMemoryError异常 Java堆（Java Heap）Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。 根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。 方法区（Method Area）方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。 由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，但java7已经把常量池转移到堆里面了。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 在JDK1.7及以前的HotSpot JVM中，方法区位于永久代（Permanent Generation，PermGen）中。由于永久代内可能会发生内存泄露或溢出等问题而导致的java.lang.OutOfMemoryError: PermGen ，JEP小组从JDK1.7开始就筹划移除永久代（JEP 122: Remove the Permanent Generation），并且在JDK 1.7中把字符串常量，符号引用等移出了永久代。到了Java 8，永久代被彻底地移出了JVM，取而代之的是元空间（Metaspace） 运行时常量池 （runtime constant pool）)运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，是方法区的一部分。它包括了若干种不同的常量。常量池表存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具有动态性，运行期间也可以将新的量放到运行时常量池中，典型的应用是String类的intern方法: public native String intern() JDK 1.7开始，字符串常量和符号引用等就被移出永久代： 符号引用迁移至系统堆内存(Native Heap) 字符串字面量迁移至Java堆(Java Heap) 参考 【深入Java虚拟机】之一：Java内存区域与内存溢出 读书笔记-深入理解Java虚拟机1","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/tags/JVM/"}]},{"title":"java8新特性（转载）","slug":"java8新特性（转载）","date":"2018-04-12T07:56:55.000Z","updated":"2018-04-20T13:17:04.928Z","comments":true,"path":"2018/04/12/java8新特性（转载）/","link":"","permalink":"https://hsb786.github.io/2018/04/12/java8新特性（转载）/","excerpt":"Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。","text":"Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。 Default Methods for InterfacesJava 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子： 1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; 在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt.Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。 123456789Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 那么这个新特征有啥用呢？ 我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类，那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法，那么我们需要去重写每个实现了这个接口的类，而这大大增加了我们的实现需求的负担。 正是为了解决Java接口中只能定义抽象方法的问题。Java8新增加了默认方法的特性。默认方法可以被继承接口重写成抽象方法或者重新定义成默认方法。除了默认方法，接口里还可以声明静态方法，并且可以实现。例子如下：123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; Conflict因为一个类可以实现多个接口，所以当一个类实现了多个接口，而这些接口中存在两个或两个以上方法签名相同的默认方法时就会产生冲突，java8定义如下三条原则来解决冲突： 类或父类中显式声明的方法，其优先级高于所有的默认方法； 如果1规则失效，则选择与当前类距离最近的具有具体实现的默认方法； 如果2规则也失效，则需要显式指定接口。 Lambda ExpressionsLambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式，它提供了轻量级的语法 重点留意这四个关键词：匿名、函数、传递、简洁 Lambda的三个部分： 参数列表 箭头 Lambda 主体 Lambda的基本语法大概就是下面这样子的了： (parameters) -&gt; expression (parameters) -&gt; { statements; } 1234567Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;);或者是Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));亦或是Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Lexiacal Scope访问局部变量可以直接在Lambda表达式中访问外层的局部变量，但是和匿名对象不同的是，Lambda表达式的局部变量可以不用声明为final，不过局部变量必须不可被后面的代码修改（即隐性的具有final的语义）。 eg：下面代码无法编译1234int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; String.valueOf(param + num); num = 5; 在Lambda表达式中试图修改局部变量是不允许的！ 在 Lambda 表达式当中被引用的变量的值不可以被更改。 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 和局部变量不同的是，Lambda内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。 不能访问接口的默认方法Lambda表达式中是无法访问到默认方法的。 补充：Lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，在这里增加一个例子以说明这个特性： 12345int sum = 0;list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over valuesList&lt;Integer&gt; aList = new List&lt;&gt;();list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables 匿名内部类的简写？Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件 Lambda表达式中的this既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。 Functional Interfaces任意只包含一个抽象方法的接口，我们都可以用来做成Lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。 12345678@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125; Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted); // 123 注意，如果你不写@FunctionalInterface 标注，程序也是正确的。 下面是Java SE 7中已经存在的函数式接口： java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.beans.PropertyChangeListener 除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如： Predicate——接收T对象并返回boolean Consumer——接收T对象，不返回值 Function&lt;T, R&gt;——接收T对象，返回R对象 Supplier——提供T对象（例如工厂），不接收值 UnaryOperator——接收T对象，返回T对象 BinaryOperator——接收两个T对象，返回T对象 除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。 Method and Constructor ReferencesLambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。 方法引用和Lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。 方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。方法引用有很多种，它们的语法如下： 静态方法引用：ClassName::methodName 实际上的实例方法引用：instanceReference::methodName 超类上的实例方法引用：super::methodName 类型上的实例方法引用：ClassName::methodName 构造方法引用：Class::new 数组构造方法引用：TypeName[]::new 对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。 结合Lambda可以使我们的代码更加简洁： 1234List&lt;String&gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;);strings.stream().map(String::toUpperCase).forEach(System.out::println);List&lt;Character&gt; chars = Arrays.asList(&apos;a&apos;, &apos;b&apos;); System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;))); OptionalNullPointException可以说是所有Java程序员都遇到过的一个异常，虽然Java从设计之初就力图让程序员脱离指针的苦海，但是指针确实是实际存在的，而java设计者也只能是让指针在Java语言中变得更加简单、易用，而不能完全的将其剔除，所以才有了我们日常所见到的关键字null。 空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。当异常真的发生的时候，处理策略也很简单，在存在异常的地方添加一个if语句判定即可，但是这样的应对策略会让我们的程序出现越来越多的null判定，我们知道一个良好的程序设计，应该让代码中尽量少出现null关键字，而Java8所提供的Optional类则在减少NullPointException的同时，也提升了代码的美观度。但首先我们需要明确的是，它并 不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现，从而避免NullPointException。 java.util.Optional 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。 创建 Optional 对象,三个静态工厂方法： Optional.empty：创建空的 Optional 对象 Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE Optianal.ofNullable：创建 Optional 对象，允许传空值 Optional API： isPresent(): 变量存在返回true get(): 返回封装的变量值，或者抛出 NoSuchElementException orElse(T other): 提供默认值 orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版 orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型 ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法 filter(Predicate&lt;? super T&gt; predicate): 过滤 map(Function&lt;? super T, ? extends U&gt; mapper): 转换 flatMap(Function&lt;? super T, Optional&lt;U>>mapper): 转换成Optional 值得注意的是：Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题 Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法，没有考虑将它作为类的字段使用… 另外，在Java9中对Optional添加了三个新的方法： public Optional or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)or 方法的作用是，如果一个 Optional 包含值，则返回自己；否则返回由参数 supplier 获得的 Optional public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run() public Stream stream()stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream；否则返回一个空的 Stream（Stream.empty()） 举个例子，在 Java8，我们会写下面的代码： 12345678// 此处 getUserById 返回的是 Optional&lt;User&gt;public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123; return userIds.stream() .map(this::getUserById) // 获得 Stream&lt;Optional&lt;User&gt;&gt; .filter(Optional::isPresent)// 去掉不包含值的 Optional .map(Optional::get) .collect(Collectors.toList());&#125; 而有了 Optional.stream()，我们就可以将其简化为： 123456public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123; return userIds.stream() .map(this::getUserById) // 获得 Stream&lt;Optional&lt;User&gt;&gt; .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流 .collect(Collectors.toList());&#125; Streams 流是什么12345Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;).stream() .filter(s -&gt; s.startsWith(&quot;c&quot;)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); 流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。 引入的原因： 声明性方式处理数据集合 透明地并行处理，提高性能 流 的定义：从支持数据处理操作的源生成的元素序列 两个重要特点 流水线 内部迭代 流与集合： 集合与流的差异就在于什么时候进行计算 集合是内存中的数据结构，包含数据结构中目前所有的值 流的元素则是按需计算/生成 另一个关键区别在于遍历数据的方式 集合使用 Collection 接口，需要用户去做迭代，称为外部迭代 流的 Streams 库使用内部迭代 流的使用 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果。 流的流水线背后的理念类似于构建器模式。常见的中间操作有filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。 流的操作类型分为两种： Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 流的使用构建流 由值创建流：Stream.of、Stream.empty、IntStream.range 由集合创建流：Collection.stream、Collection.parallelStream 由数组创建流：Arrays.stream(数组变量) 由文件生成流：Files.lines、Files.walk 由BufferedReader创建流：java.io.BufferedReader.lines 由函数生成流：创建无限流， 迭代： Stream.iterate（接受一个种子值，和一个UnaryOperator） 生成：Stream.generate（接收一个Supplier接口） 使用流Intermediate（中间操作）： 筛选 谓词筛选：filter 筛选互异的元素：distinct 忽略头几个元素：skip 截短至指定长度：limit 排序：sorted 偷瞄（输出）：peek 平行化：parallel 串行化：sequential 映射 对流中每个元素应用函数：map 流的扁平化：flatMap 转为原始流：mapToInt、mapToInt、mapToInt 从原始流转为普通流：boxed 数值范围 range:[起始值，结束值) rangeClosed:[起始值，结束值] Terminal（终结操作） 查找和匹配 检查谓词是否至少匹配一个元素：anyMatch 检查谓词是否匹配所有元素：allMatch/noneMatch 查找元素：findAny 查找第一个元素：findFirst 归约（折叠）：reduce(初值，结合操作) 元素求和：count、sum 最大值和最小值：min、 max 遍历 forEach、 forEachOrdered anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。 映射到数值流：mapToInt,mapToDouble,mapToLong 转换回流对象：boxed 默认值：OptionalInt,OptionalDouble,OptionalLong 用流收集数据对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。 Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能： 将流元素归约和汇总为一个值 元素分组 元素分区 归约和汇总(Collectors 类中的工厂方法)： 统计个数：Collectors.counting 查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy 汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数 连接字符串：joining 广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。 collect vs. reduce，两者都是 Stream 接口的方法，区别在于： 语意问题 reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约； collect 方法设计就是要改变容器，从而累积要输出的结果 实际问题 以错误的语义使用 reduce 会导致归约过程不能并行工作 分组和分区 分组：Collectors.groupingBy 多级分组 按子数组收集数据: maxBy 把收集器的结果转换为另一种结果 collectingAndThen 与 groupingBy 联合使用的其他收集器例子：summingInt,mapping 分区：Collectors.partitioningBy是分组的特殊情况，由一个谓词作为分类函数(分区函数)，返回一个Map，只有两个Boolean类型的key。 Ex1:使用collect()生成Collection前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成： 123456// 将Stream转换成List或SetStream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。 123// 使用toCollection()指定规约容器的类型ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4) 上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。 Ex2:使用collect()生成Map前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map： 使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。 使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。 使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。 情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。 1234// 使用toMap()统计学生GPAMap&lt;Student, Double&gt; studentToGPA = students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key student -&gt; computeGPA(student)));// 如何生成value 情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。 123// Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream() .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); 情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组： 123// Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); 以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。 1234// 使用下游收集器统计每个部门的人数Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));// 下游收集器 上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到： 12345// 按照部门对员工分布组，并只保留员工的名字Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.mapping(Employee::getName,// 下游收集器 Collectors.toList())));// 更下游的收集器 Notice And Optimization 流不可被复用 一般先filter、limit、skip操作后再进行sorted、peek、map等操作以达到short-circuiting 目的 Stream操作分类 方法 中间操作(Intermediate operations) 无状态(Stateless) unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek() 有状态(Stateful) distinct() sorted() sorted() limit() skip() 结束操作(Terminal operations) 非短路操作 forEach() forEachOrdered() toArray() reduce() collect() max() min() count() 短路操作(short-circuiting) anyMatch() allMatch() noneMatch() findFirst() findAny() Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。 Java8 对字符串连接的改进有时候，我们会有一种需求就是将若干个字符串用某个链接符衔接起来，例如有一个 List，将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式。 以前我们的一般做法就是使用StringBuilder： 1234567891011121314151617181920212223public static String formatList(List&lt;String&gt; list, String delimiter) &#123; StringBuilder result = new StringBuilder(); for (String str : list) &#123; result.append(str).append(delimiter); &#125; // 删除末尾多余的 delimiter result.delete(result.length() - delimiter.length(), result.length()); return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringBuilder：&quot;); String format = formatList(list, &quot;,&quot;); System.out.println(format);&#125;//运行结果使用 StringBuilder：a,b,c,d,e,f,g JDK1.8 时，添加了一个新的用于字符串连接的类，专门用于这种需要 分隔符 的场合，它就是 StringJoiner。StringJoiner 在构造时可以指定一个分隔符（delimiter），然后每连接一个元素它便会加上一个 delimiter，使用 StringJoiner 改写 formatList： 123456789101112131415public static String formatList(List&lt;String&gt; list, String delimiter) &#123; StringJoiner result = new StringJoiner(delimiter); for (String str : list) &#123; result.add(str); &#125; return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringJoiner：&quot;); String format = formatList(list, &quot;,&quot;); System.out.println(format);&#125; 或者使用String.join: 123public static String formatList(List&lt;String&gt; list, String delimiter) &#123; return String.join(delimiter, list);&#125; String.join 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 List 格式化为 { 元素1, 元素2, 元素3, … 元素N } 呢？（此时前缀为 “{ “，后缀为 “ }”） 1234567891011121314151617public static String formatList( List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123; StringJoiner result = new StringJoiner(delimiter, prefix, suffix); for (String str : list) &#123; result.add(str); &#125; return result.toString();&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 StringJoiner，带前缀和后缀：&quot;); String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;); System.out.println(format);&#125; 事实上，Java8 对于字符串集合的连接操作提供了一个专门的流式 API，即 Collectors.joining 函数 无参的 joining() 方法，即不存在连接符（底层实现为 StringBuilder）； joining(CharSequence delimiter) 方法，即分隔符为 delimiter（底层实现为 StringJoiner）； joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法，即分隔符为 delimiter，前缀为 prefix，后缀为 suffix（底层实现为 StringJoiner）。 那怎么使用呢？ 我们直接使用三个参数的 Collectors.joining 方法改写 formatList： 12345678910111213public static String formatList( List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123; return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 Collectors.joining：&quot;); String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;); System.out.println(format);&#125; Java8 中 Map 接口的新方法假如现在我们存在这样的需求：给定一个 List，统计每个元素出现的所有位置。 比如，给定 list：[“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “f”, “f”, “g”] ，那么应该返回：123456a : [0]b : [1, 2]c : [3, 4, 5]d : [6, 7, 8]f : [9, 10]g : [11] 很明显，我们很适合使用 Map 来完成这件事情： 12345678910111213141516171819202122232425public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); List&lt;Integer&gt; positions = positionsMap.get(str); if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt; positions = new ArrayList&lt;&gt;(1); positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap &#125; positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中 &#125; return positionsMap;&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 Java8 之前的 API：&quot;); Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list); System.out.println(elementPositions);&#125; 运行结果 12使用 Java8 之前的 API：&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125; computeIfAbsent1234567891011121314151617public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i); &#125; return positionsMap;&#125;public static void main(String[] args) throws Exception &#123; List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;); System.out.println(&quot;使用 computeIfAbsent：&quot;); Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list); System.out.println(elementPositions);&#125; 当 forEach 需要索引1234567public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i); &#125; return positionsMap;&#125; 但是方法里面的for循环似乎让这个方法不太优雅了，Java8中Iterable提供的foreach并不带索引的： 我们可以自己写一个： 1234567891011public static &lt;E&gt; void forEach( Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123; Objects.requireNonNull(elements); Objects.requireNonNull(action); int index = 0; for (E element : elements) &#123; action.accept(index++, element); &#125; &#125;&#125; 然后改造getElementPositions方法： 123456789public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123; Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;(); Iterables.forEach(list, (index, str) -&gt; &#123; positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index); &#125;); return positionsMap;&#125; 参考 Java8 Noob Tutorial","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"合并两个排序的链表","slug":"合并两个排序的链表","date":"2018-04-12T07:29:59.000Z","updated":"2018-04-20T13:21:40.349Z","comments":true,"path":"2018/04/12/合并两个排序的链表/","link":"","permalink":"https://hsb786.github.io/2018/04/12/合并两个排序的链表/","excerpt":"输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。","text":"输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static ListNode merge(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; if (list1.data &lt; list2.data) &#123; list1.next = merge(list1.next, list2); return list1; &#125; else &#123; list2.next = merge(list1, list2.next); return list2; &#125;&#125;public static ListNode mergeSortedList(ListNode list1, ListNode list2) &#123; if (list1 == null) &#123; return list2; &#125; if (list2 == null) &#123; return list1; &#125; ListNode mergeHead = null; ListNode current = null; if (list1.data &lt;= list2.data) &#123; mergeHead = current = list1; list1 = list1.next; &#125; else &#123; mergeHead = current = list2; list2 = list2.next; &#125; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.data &lt;= list2.data) &#123; current.next = list1; current = current.next; list1 = list1.next; &#125; else &#123; current.next = list2; current = current.next; list2 = list2.next; &#125; &#125; if (list1 == null) &#123; current.next = list2; &#125; else &#123; current.next = list1; &#125; return mergeHead;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2018-04-12T05:39:35.000Z","updated":"2018-04-20T13:18:58.913Z","comments":true,"path":"2018/04/12/MyBatis/","link":"","permalink":"https://hsb786.github.io/2018/04/12/MyBatis/","excerpt":"MyBatis简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。","text":"MyBatis简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。 MyBatis组件MyBatis的核心组件分为4个部分： SqlSessionFactoryBuilder(构造器)：它会根据mybatis的配置文件(Configuration配置类)来生成SqlSessionFactory，这里采用的是分步构建的Builder模式 SqlSessionFactory(工厂)：用于生成SqlSession，可以被认为是数据库连接池 SqlSession(会话)：既可以直接发送SQL执行并返回结果，也可以获取映射器Mapper接口(动态代理的类)执行SQL得到返回结果，相当于数据库连接(Connection对象) Mapper(映射器)：由一个Java接口和XML文件构成：接口用于给出方法的入参以及返回值，XML给出SQL语句和映射规则。映射器的主要作用就是将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中 注意，无论是映射器还是SqlSession都可以发送SQL到数据库执行，但是为了保证代码的可读性与可维护性，推荐使用Mapper接口编程来完成该操作。 SqlSession : 代表和数据库的一次会话，向用户提供了操作数据库的方法。 MappedStatement: 代表要发往数据库执行的指令，可以理解为是Sql的抽象表示。 Executor: 具体用来和数据库交互的执行器，接受MappedStatement作为参数。 映射接口: 在接口中会要执行的Sql用一个方法来表示，具体的Sql写在映射文件中。 映射文件: 可以理解为是Mybatis编写Sql的地方，通常来说每一张单表都会对应着一个映射文件，在该文件中会定义Sql语句入参和出参的形式。 作用域（Scope）和生命周期SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 映射器实例（Mapper Instances）映射器是一个你创建来绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125; 如何使用MyBatis首先，在MyBatis中有两种XML配置文件，一种是基础配置文件，它只有一个，用于配置一些MyBatis的上下文参数和运行环境；另一种是映射器的XML映射文件，它可以配置映射关系，SQL等等。简单来说，在使用MyBatis的时候，先给出MyBatis的配置文件用于生成SqlSession，然后再给出映射器Mapper的接口与相应的映射XML文件，最后就可以生成Mapper接口的动态代理类来发送SQL获取结果了。 映射器映射器是mybatis最核心的组件，它由一个接口加上xml文件组成。在映射器中可以配置参数，各类的SQL语句，缓存，级联等内容，并且可以通过映射规则映射到指定的POJO上。映射器的接口与映射xml文件配置使用，可以有效的消除jdbc底层代码。 映射器的映射xml文件有以下几个元素： cache – 给定命名空间的缓存配置 cache-ref – 其他命名空间缓存配置的引用 resultMap – 描述如何从数据库结果集中来加载对象，它将提供映射规则 sql – 可被其他语句引用的可重用语句块，可以定义一部分SQL，然后在其他地方引用 insert – 映射插入语句，执行后返回一个整数，代表插入的条数 update – 映射更新语句，执行后返回一个整数，代表更新的条数 delete – 映射删除语句，执行后返回一个整数，代表删除的条数 select – 映射查询语句，返回查询结果 select元素映射器中的select元素代表SQL的select语句，用于查询。select元素中有以下常用的属性： id:在Mapper的命名空间中唯一的标识符。Mapper的命名空间与select元素的id将唯一定位对应的映射器接口的某个方法。 parameterType：将会传入这条语句的参数类的完全限定名或别名，可以选择Java Bean，Map等参数类型传递给SQL。这个属性是可选的，mybatis可以通过TypeHandler推断出具体传入语句的参数。 resultType：从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。 resultMap：映射集的引用，用于结果集的映射，完成结果的映射功能。注意resultType和resultMap不能同时使用。 flushCache：将其设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。 useCache：将其设置为true，将会导致本条语句的结果被二级缓存，默认值：对select元素为true。 123&lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.spring.test.pojo.Person&quot;&gt; SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;&lt;/select&gt; 1public Person getPerson(@Param(&quot;id&quot;) int id); mybatis提供的自动映射功能，只要SQL的列名与POJO的属性名保持一致，同时在mybatis的配置文件中settings元素的autoMappingBehavior是开启的(默认是开启)即可完成自动映射。如果列名与属性名不一致的话，还可以通过SQL的别名机制来处理。比如说，假如原来列名为person_name，属性名为personName，那么在SQL中就可以这么写：select person_name as personName … 这样同样可以完成自动映射。 这里特别说明关于select元素返回一个对象或者对象集合的问题： 返回数据类型由DAO中的接口和映射xml文件共同决定。另外，不论是返回单一对象还是对象列表，映射xml中的配置都是一样的，都是resultType=“ . .”类型或resultMap=”resultMap-ref”*。 每一次mybatis从数据库中select数据之后，都会检查数据条数和DAO中定义的返回值是否匹配。 若返回一条数据，DAO中定义的返回值是一个对象或对象的List列表，则可以正常匹配，将查询的数据按照DAO中定义的返回值存放。 若返回多条数据，DAO中定义的返回值是一个对象，则无法将多条数据映射为一个对象，此时mybatis报错。 resultMap元素通过resultType加上mybatis的自动映射可以应对大多数的结果集的映射需求，但是这种方法无法定义更多的属性，比如typeHandler，级联等。为了支持更加复杂的映射，mybatis提供了resultMap属性来完成SQL到Java Bean的映射关系定义。接下来，用resulyMap改写之前使用自动映射的select元素。 123456789&lt;resultMap id = &quot;Map&quot; type = &quot;mybatis.spring.test.pojo.Person&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt; &lt;result property=&quot;tel&quot; column=&quot;tel&quot;&gt;&lt;/resultMap&gt; &lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultMap=&quot;Map&quot;&gt; SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125; &lt;/select&gt; 子元素id代表主键，result代表属性，id和result元素的property属性代表POJO的属性名称，column代表SQL的列名，这样就将POJO的属性和SQL的列名进行一一对应了。 一个完整的resultMap元素的构成有哪些？ constructor：类在实例化时,用来注入结果到构造方法中 id：表示哪个列是主键 result：注入到JavaBean属性的普通结果，配置POJO到SQL列名的映射关系 association：一个复杂的类型关联;许多结果将包成这种类型 collection：复杂类型的集 discriminator：使用结果值来决定使用哪个结果映射 constructor元素用于配置构造方法，一个POJO可能不存在没有参数的构造方法，就要使用construtor元素来配置了。 id元素，result元素主要来定义POJO与SQL列名的映射规则，它们有如下属性： property:映射规则中的POJO的属性名，可以用导航式字段，例如需要访问Person类的Address属性的id，就可以写成Address . id column：对应的SQL的列名 javaType：Java类型 jdbcType：数据库类型 typeHandler：类型处理器，允许使用自定义的类型处理器 其中association，collection和discriminator这些元素是与结果映射的级联相关的。Mybatis支持级联映射，简单来说，假如我们select一个person类，person类有一个属性为address，address也是一个POJO，也就是说需要再进行一次select才能查询到address类的信息。这里需要说明的是，级联不是必须的，级联可以便捷的获取关联数据，但是如果级联太多的话会影响执行效率，也就是著名的N+1问题(如果有N个关联关系完成了级联，那么只要再加入一个关联关系，就变成了N+1个，所有的级联SQL都会被执行，显然不是所有数据是我们感兴趣的，造成了资源的浪费与性能的浪费)。为了应对级联中的N+1问题，mybatis支持延迟加载，在select的时候并不是一次性取出所有的SQL结果来映射，对于那些不常用的级联数据等到需要的时候再取出。在mybatis的全局配置文件中可以设定延迟加载属性，同时在级联元素association和collection中的fetchType属性也可以定义延迟加载。 insert,update,delete相比于select来说，insert,update,delete就很简单了，它们执行的结果返回的是整数，用以标识该SQL语句影响了数据库的记录行数，不需要进行结果集的映射。除此之外，insert元素是支持主键回填的，在inser语句中有一个属性useGeneratedKeys，用来控制是否使用数据库生成的主键来回填到POJO，默认值为false。当打开了主键回填之后，还要配置keyProperty或者keyColumn，告诉mybatis把生成的主键放入哪个属性中。至于在实际中用不用得到数据库生成的主键，我也不能完全肯定，这里只要知道mybatis是支持主键回填的即可，使用起来也很容易。 sql元素这个元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中 12345678&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 动态SQLmybatis提供了对SQL语句动态的组装能力，大量的判断都可以在mybatis的映射xml里面配置，大大减少了代码量，提供了灵活性。 ifif元素使用的场景适用于在SQL语句的where子句中动态地选择某几个判断条件作为SQL语句的一部分进行拼接。 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 如果传入的参数title不是null，那么就将 AND title like #{title} 这子句拼接在where之后，这样就可以有条件地包含where子句的一部分。 choose(when,otherwise)if元素是单条件的，choose元素就是多条件的选择类似java里的switch语句，原理一样，还是接着上面的例子来举例： 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 上述参考文档中的例子otherwise元素写的是 AND featured = 1 是为了解决前面的所有case都不满足的情况，我建议写成 AND 1 = 1 更好理解。该动态SQL语句的功能：如果参数提供了“title”就按“title”查找，提供了“author”就按“author”查找，若两者都没有提供，就返回所有符合默认条件的查询结果集。 trim(where,set)前面的例子中的where子句总会有一个默认的查询条件也就是例子中的 state = ‘ACTIVE’ ，如果state也设置成动态的呢？可以通过where,set元素来达到这个需求。 123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 同样如果是update子句，那么也就相应的set元素，如下： 12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 如果where,set都无法满足动态拼接SQL的需求，我们可以使用trim来自定义如何拼接SQL子句，where和set只是mybatis定义好的拼接SQL的方法而已，但这也已经可以满足大多数需求了。 foreach动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。还是参考文档里买的例子： 123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach元素允许指定一个集合，声明可以用在元素体内的集合项和索引变量，也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。我们可以将任何可迭代对象（如列表、集合等）和任何的字典或者数组对象传递给foreach作为集合参数。当使用可迭代对象或者数组时，index是当前迭代的次数，item的值是本次迭代获取的元素。当使用字典（或者Map.Entry对象的集合）时，index是键，item是值。 #{}和${}#{}表示一个占位符号，用来传入参数，sql在解析的时候会加上” “,当成字符串来解析，可以防止sql注入 ${}表示一个拼接符号, 传入数据直接显示在生成的sql中，这样就会导致sql注入 MyBatis缓存MyBatis提供一级缓存和二级缓存 如果缓存中有数据就不用从数据库中获取，减少了和数据之间的交互次数，大大提高系统的性能。 一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)，用于存储缓存数据。不同的sqlSession之间的缓存区域(HashMap)是互不影响的。 二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个SqlSession可以公用二级缓存，二级缓存是跨sqlSession的。 一级缓存的工作原理 每一个SqlSession中持有了自己的Executor，每一个Executor中有一个Local Cache。当用户发起查询时，MyBatis会根据当前执行的MapperStatement生成一个key，去Local Cache中查询，如果缓存命中的话，返回。如果缓存没有命中的话，则写入Local Cache，最后返回结果给用户。 二级缓存的工作原理 参考 MyBatis官方文档 MyBatis入门 MyBatis进阶 Mybatis学习总结（九）——查询缓存 Mybatis缓存使用及源码分析","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://hsb786.github.io/categories/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://hsb786.github.io/tags/MyBatis/"}]},{"title":"HashMap","slug":"HashMap","date":"2018-04-12T03:29:30.000Z","updated":"2018-04-21T13:24:39.728Z","comments":true,"path":"2018/04/12/HashMap/","link":"","permalink":"https://hsb786.github.io/2018/04/12/HashMap/","excerpt":"HashMap内部存储结构 HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。","text":"HashMap内部存储结构 HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。 123456789101112131415161718192021222324252627public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; transient Node&lt;K,V&gt;[] table; transient int size; transient int modCount; static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; ..... &#125; .....&#125; table，一个存放节点(Node[])的数组，是Hashmap的基础设施，所有的节点都存放于此。 size，Hashmap存放的键值对的数目，并不等于table数组的长度，因为可能存在链表和红黑树结构。 modCount，Hashmap的修改次数，是实现fail-fast机制的关键 DEFAULT_INITIAL_CAPACITY，表示默认HashMap数组初始大小为16，并且为了后续的rehash操作的方便，Hashmap的数组大小始终为2的整数次幂，即使你输入一个不是2的整数次幂的值，也会变成最小的大于该值的2的整数次幂。 MAXIMUM_CAPACITY，表示Hashmap数组的最大容量，初始值为2^30。 DEFAULT_LOAD_FACTOR，表示负载因子，当Hashmap的实际容量超过了(设定容量乘负载因子)，就触发rehash操作，默认值为0.75。 TREEIFY_THRESHOLD，jkd1.8新增的，如果Hashmap数组元素的链表长度超过这个值，就使用红黑树结构代替链表提高查询效率，默认值为8。 数组内的元素的数据结构继承了Map.Entry，用于存放键值对，另外还包含了hash值和next节点，其中hash值可用于存取节点时来寻址的作用，next节点是实现Hashmap的数组+链表(红黑树)结构的关键。 在继续看Hashmap的内部方法之前，做个大致的总结： Hashmap是用于存放键值对的容器，内部实现是基于数组的，数组中存放的是键值对Node节点，一个Node节点保存了一个键值对信息，同时还保存了next节点，可以形成链表结构(在发生hash冲突的时候)。如果链表长度太长，超过了阀值(默认为8)，那么就自动升级为红黑树结构(高效的平衡查找树)，这样一来，数组元素的节点就成为了红黑树的根节点了。 需要注意的是，在java8中如果hash值相同的key数量大于指定值（默认是8）时使用平衡树来代替链表，这会将get()方法的性能从O(n)提高到O(logn)。 HashMap的自动扩容机制 HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶都有62500个元素，这时get()，put()，remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小*loadFactor(加载因子)后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16*0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置。 没扩容前，获取EntryE需要遍历5个元素，扩容之后只需要2次。 put() 对key的hashCode()做hash，然后计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长（大于等于TREEIFY_THRESHOLD），就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性)； 如果bucket满了(超过load factor*current capacity)，就要resize。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 如果put()方法添加的键值对的键已经存在于Hashmap中，那么就用新的键值的值替代旧值。再看源码put()调用了hash()方法以及putVal()方法 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当输入的key为null时，hash值为0，也就是说Hashmap的key是可以为null的。对比HashTable，HashTable的key直接进行了hashCode，如果key为null时，会抛出异常，所以HashTable的key不可以是null。具体如何得到key的hash值呢？首先调用key自身的hashcode()得到一个hash值h(32位int类型)，然后将h与h右移16位之后的数进行异或，得到最终的hash值。至于为什么这么做，这是前人总结出来的算法可以使得hash值分布更加均匀,尽量减少冲突 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 通过注释，我们可以知道入参都代表了什么： hash：表示key的hash值 key：待存储的key值 value：待存储的value值 onlyIfAbsent：是否需要替换相同的value值。如果为true，表示不替换已经存在的value evict：如果为false，表示数组是新增模式(暂时不知道啥意思,只在方法的最后出现,但不影响其他逻辑) 首先判断当前HashMap的数组是否为空，如果为空，就调用resize()方法初始化一个长度为16的数组，并且获取到数组的长度n，代码如下： 12if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; 然后，根据数组的长度n-1的值与入参key的hash值按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。但是，如果取到了数据，也就是这个hash值对应数组的位置上面已经有了键值对存在。那么，就判断这个Node,也就是p的hash值是否与传入的hash相等，然后接着判断key是否相等。如果判断通过，表示要传入的key-val键值对就是tab[i]位置上面的键值对，直接替换即可，不用管后面是链表还是红黑树。如果不是的话，就将这个新的键值对插入链表或者红黑树种即可。插入键值对分两种情况：如果数组元素是链表时，就将节点新增到列表尾部。如果链表的长度大于等于红黑树化的阀值-1，就将链表转成红黑树。如果数组元素是红黑树的话，就插入键值到对应的Node。 注意，java8开始用的是尾插法12345678910111213141516171819202122232425262728293031if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null);else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125;&#125; 最后，将修改次数加一，同时判断当前的键值对数量是否即将超过阀值，如果即将超过，需要进行resize操作。12345++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; get() bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry; 若为树，则在数中通过key.equals(k)查找，O(logn); 若为链表，则在链表中通过key.equals(k)查找，O(n)。 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 根据入参的key对象计算出key的hash值，调用getNode()方法，再来看看getNode()方法。12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 通过key的hash值与key对象，来查找key对应的键值对的值，如果查找失败则返回null。如何查找的呢？首先，通过key的hash值计算出对应数组的索引，如果索引到的第一个Node节点的key和hash值与入参相等，直接返回该Node。否则，循环遍历下一个节点(可能是链表也有可能是红黑树)。 为什么线程不安全 如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(根据hash值计算的bucket一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。 扩容时需要rehash，可能会造成死循环(java8已修复) 如何线程安全的使用HashMap Hashtable123456public synchronized V get(Object key) &#123; .....&#125;public synchronized V put(K key, V value) &#123; ......&#125; 效率低，一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以。 ConcurrentHashMap （效率高）JUC包中的一个类。ConcurrentHashMap 不仅线程安全而且效率高，因为它包含一个 segment 数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的锁分段技术。 SynchronizedMap调用synchronizedMap()方法后返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的 1234567891011121314151617181920212223242526272829303132333435363738394041// synchronizedMap方法public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123; return new SynchronizedMap&lt;&gt;(m); &#125;// SynchronizedMap类private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map&lt;K,V&gt; m) &#123; this.m = Objects.requireNonNull(m); mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; // 省略其他方法 &#125; 从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。 总结 HashMap在处理冲突时使用链表存储相同索引的元素。 从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。 当从链表切换到平衡树时，HashMap迭代的顺序将会改变。不过这并不会造成什么问题，因为HashMap并没有对迭代的顺序提供任何保证。 从Java 1中就存在的Hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。 除了Hashtable之外，WeakHashMap和IdentityHashMap也不会在频繁冲突的情况下使用平衡树。 使用HashMap之所以会产生冲突是因为使用了键对象的hashCode()方法，而equals()和hashCode()方法不保证不同对象的hashCode是不同的。需要记住的是，相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。 在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。 Java7在多线程操作hashmap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系；Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。 参考 Java 8中HashMap和LinkedHashMap如何解决冲突 如何线程安全的使用 HashMap 看看HashMap源码","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"},{"name":"集合","slug":"爪哇/集合","permalink":"https://hsb786.github.io/categories/爪哇/集合/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"工具网站","slug":"工具网站","date":"2018-04-11T04:22:11.000Z","updated":"2018-04-20T13:21:32.526Z","comments":true,"path":"2018/04/11/工具网站/","link":"","permalink":"https://hsb786.github.io/2018/04/11/工具网站/","excerpt":"","text":"图标 画图 在线编码转换 HTTP状态码 Sql转Class","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"EasyUI","slug":"EasyUI","date":"2018-04-11T03:28:06.000Z","updated":"2018-04-20T13:15:35.744Z","comments":true,"path":"2018/04/11/EasyUI/","link":"","permalink":"https://hsb786.github.io/2018/04/11/EasyUI/","excerpt":"","text":"当请求远程数据时，发送的额外参数。 在datagrid构造中加入queryParams参数12345678dataGrid = $(&apos;#dg&apos;).datagrid(&#123; url : &apos;$&#123;pageContext.request.contextPath&#125;/companys/datagrid&apos;, method : &apos;GET&apos;, ......................... queryParams : &#123; //传入当前日期查询 startTime : getNowFormatDate() &#125;, 重新加载行，保持在当前页1$(&apos;#dg&apos;).datagrid(&apos;reload&apos;); 加载并显示第一页的行,通过传递一些从参数进行查询，该方法被调用来从服务器加载新数据。 1234$(&quot;#dg&quot;).datagrid(&apos;load&apos;, &#123; &quot;job.name&quot; : $(&quot;#jobname&quot;).val(), &quot;user.realname&quot; : $(&quot;#realname&quot;).val() &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"KingEditor","slug":"KingEditor","date":"2018-04-11T03:22:23.000Z","updated":"2018-04-20T13:18:26.611Z","comments":true,"path":"2018/04/11/KingEditor/","link":"","permalink":"https://hsb786.github.io/2018/04/11/KingEditor/","excerpt":"","text":"官方文档示例 初始化；属于异步加载123KindEditor.ready(function(K) &#123; window.editor = K.create(&apos;#editor_id&apos;); &#125;); 同步加载；直接调用KindEditor创建，而不是等KindEditor.ready后再创建1234567891011about = KindEditor.create(&apos;textarea[id=&quot;about&quot;]&apos;, &#123; items : [ &apos;cut&apos;, &apos;copy&apos;, &apos;paste&apos;, &apos;justifyleft&apos;, &apos;justifycenter&apos;, &apos;justifyright&apos;, &apos;justifyfull&apos;, &apos;insertorderedlist&apos;, &apos;insertunorderedlist&apos;, &apos;indent&apos;, &apos;outdent&apos;, &apos;subscript&apos;, &apos;superscript&apos;, &apos;clearhtml&apos;, &apos;quickformat&apos;, &apos;selectall&apos;, &apos;|&apos;, &apos;fullscreen&apos;, &apos;/&apos;, &apos;formatblock&apos;, &apos;fontname&apos;, &apos;fontsize&apos;, &apos;|&apos;, &apos;forecolor&apos;, &apos;hilitecolor&apos;, &apos;bold&apos;, &apos;italic&apos;, &apos;underline&apos;, &apos;strikethrough&apos;, &apos;lineheight&apos;, &apos;removeformat&apos;, &apos;|&apos;, &apos;table&apos;, &apos;hr&apos;, &apos;emoticons&apos;, &apos;pagebreak&apos; ] &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2018-04-10T12:27:44.000Z","updated":"2018-04-20T13:16:34.511Z","comments":true,"path":"2018/04/10/HTTP状态码/","link":"","permalink":"https://hsb786.github.io/2018/04/10/HTTP状态码/","excerpt":"HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。","text":"HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 status 含义 100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 在最新版的规范中，306状态码已经不再被使用。 307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 该状态码是为了将来可能的需求而预留的。 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 客户端应当切换到TLS/1.0。（RFC 2817） 449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 获取资源所需要的策略并没有没满足。（RFC 2774）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://hsb786.github.io/tags/HTTP/"}]},{"title":"反转链表","slug":"反转链表","date":"2018-04-10T12:14:31.000Z","updated":"2018-04-20T13:21:09.478Z","comments":true,"path":"2018/04/10/反转链表/","link":"","permalink":"https://hsb786.github.io/2018/04/10/反转链表/","excerpt":"定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。","text":"定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。 1234567891011121314151617181920212223242526272829303132333435363738 /** * 维护两个节点，一个指向当前节点，一个指向下一个节点 * 缺点，需要new 对象，占用内存 * @author: husb * @date: 2018年4月10日 下午7:44:22 */private static ListNode reverseList(ListNode head) &#123; ListNode result = new ListNode(head.data); ListNode t; while (head.next != null) &#123; t = result; result = new ListNode(head.next.data); result.next = t; head = head.next; &#125; return result;&#125;/** * @Description: 需要维护三个节点，当前，前一个，下一个 * @author: husb * @date: 2018年4月10日 下午7:57:58 */private static ListNode reverseList2(ListNode head) &#123; ListNode result = null; ListNode t = head; ListNode preNode = null; while (t != null) &#123; ListNode nextNode = t.next; if (nextNode == null) &#123; result = t; &#125; t.next = preNode; preNode = t; t = nextNode; &#125; return result;&#125; 或者直接用Stack","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"Eclipse快捷键","slug":"Eclipse快捷键","date":"2018-04-10T12:02:48.000Z","updated":"2018-04-20T13:15:55.002Z","comments":true,"path":"2018/04/10/Eclipse快捷键/","link":"","permalink":"https://hsb786.github.io/2018/04/10/Eclipse快捷键/","excerpt":"","text":"命令 语义 Ctrl W 关闭当前Editor Ctrl E 当前Editor下拉列表 Ctrl T 显示当前类的结构 Ctrl G 搜索工作区中的声明 Ctrl N 新建 Ctrl K 查找选中的文本下一个 Ctrl Shift X 把当前选中的文本全部变为大写 Ctrl Shift Y 把当前选中的文本全部变为小写 Ctrl Shift K 查找选中的文本上一个 Ctrl+Shift+H 在层次结构中打开类型 Ctrl+Shift+↑ 转至上一个成员 Ctrl+Shift+↓ 转至下一个成员","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"Spring","slug":"Spring","date":"2018-04-10T09:58:41.000Z","updated":"2018-04-20T13:19:26.177Z","comments":true,"path":"2018/04/10/Spring/","link":"","permalink":"https://hsb786.github.io/2018/04/10/Spring/","excerpt":"Spring结构Spring框架的核心组件只有三个：Bean，Context，Core","text":"Spring结构Spring框架的核心组件只有三个：Bean，Context，Core Spring是面向Bean编程，自然Bean组件就是Spring对Java对象Object的封装，在Spring容器中管理的就是被Bean封装了的Java对象。 Context组件就是我们常说的IOC容器，也就是Spring容器。Context组件可以发现每个Bean之间的关系，为它们建立好Bean之间的依赖关系，为Bean提供生存环境。 Core组件，它是Context组件与Bean组件的工具包，可以把Core组件理解为Util工具包 总结来说，Bean组件解决Bean的定义，Bean的创建以及Bean的解析，例如在Spring配置文件中定义的节点，Spring会解析得到对应的BeanDefinition对象。Context组件提供了这些Bean的生存环境，保存各个Bean的状态。实际上Context组件结合Bean组件，Core组件共同建立了一个Bean的容器，就是我们接下来要介绍的IOC容器。 Spring容器Spring容器有时候也称为IOC容器。IOC: Inverse of Control，控制反转。控制：控制就是调用类对某一个接口具体实现类的选择控制权反转：选择控制权交给第三方决定，由Spring容器来统一配置管理Bean。 为了更好理解IOC，大家经常使用依赖注入来代替控制反转这个概念，即让调用类对某一接口的实现类的依赖关系由第三方容器注入，以移除调用类对某一接口实现类的依赖。那么IOC容器的工作就是通过配置文件和注解来描述类和类之间的依赖关系。利用反射机制完成类的初始化和依赖注入。 BeanFactory和ApplicationContextBeanFactory是Spring框架核心接口，提供了IOC的配置机制，是Spring的基础设施，面向Spring本身 ApplicationContext是建立在BeanFactory之上，提供了更多的面向应用的功能，是Spring给开发者提高了IOC容器接口 Bean的生命周期 如果在配置文件中声明了工厂后处理器接口BeanFactoryPostProcessor的实现类，那么在Spring容器装载配置文件之后，初始化Bean实例之前将调用这些BeanFactoryPostProcessor对配置信息进行加工处理。也就是说工厂后处理器是容器级别的，仅在容器初始化的时候调用一次，对配置文件进行加工 当我们通过getBean(String beanName)方法向容器请求某个Bean实例的时候，如果容器注册了InstantiationAwareBeanPostProcessor接口的实现类，那么在实例化Bean之前，将调用该接口的postProcessBeforeInstantiation()方法 实例化Bean 如果容器注册了InstantiationAwareBeanPostProcessor接口的实现类，那么在实例化Bean之后，将调用该接口的postProcessAfterInstantiation()方法 如果Bean配置了属性信息，那么容器在将属性值配置到Bean中之前，将调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()方法 为Bean设置属性值 如果Bean实现了BeanNameAware接口，那么就调用该接口的setBeanName()方法，将配置文件中该Bean对应的名称设置到Bean中 如果Bean实现了BeanFactoryAware接口，那么就调用该接口的setBeanFactory()方法，将BeanFactory容器实例设置到Bean中 如果Bean实现了ApplicationContextAware接口，那么就调用该接口的setApplicationContext()方法，将ApplicationContext容器实例设置到Bean中 如果BeanFactory装配了BeanPostProcessor接口的实现类，那么就调用该后处理器的postProcessBeforeInitialization(Object bean , String beanName)方法对Bean进行加工。其中，入参bean是当前正在处理的Bean，而beanName是当前Bean的配置名。开发者可以通过改方法对Bean进行特殊的改造，例如Spring提供的AOP功能就利用BeanPostPrecessor来实现 如果Bean实现了InitializingBean接口，那么就调用该接口的afterPropertiesSet()方法 如果在中通过init-method属性定义了初始化方法，那么就执行这个方法 这是工厂后处理器BeanPostProcessor接口定义的第二个方法，第一个方法在第10步执行了，该接口的postProcessAfterInitialization(Object bean , String beanName)方法给容器提供了再次对Bean进行加工的机会 如果在中配置的Bean的作用范围是scope=“prototype”，那么就直接将该Bean实例返回给调用者，这些Bean实例不再由Spring容器管理。如果scope=“singleton”，那么就缓存该Bean实例，再返回给调用者，同时Spring容器将继续管理缓存池中的Bean实例 对于scope=“singleton”(默认情况)的Bean，当容器关闭的时候，如果Bean实现了DisposableBean接口，那么就调用该接口的destroy()方法 对于scope=“singleton”(默认情况)的Bean，如果通过destroy-method属性配置的销毁方法，那么就调用该方法 上述16步描述了ApplicationContext管理的Bean的生命周期，其中的每一步都调用了相关的方法，主要有以下几类： Bean自身的方法：Bean的构造函数，Bean的Setter方法，以及init-method和destroy-method方法 Bean级生命周期接口方法：这些方法是Spring容器规定的，由Bean实现的方法，例如BeanNameAware接口，BeanFactoryAware接口，ApplicationContextAware接口，InitializingBean接口，DisposableBean接口 容器级生命周期接口方法：这些方法是容器来配置实现类的，无需Bean来实现，在流程图中用黑点标识的方法。由于是容器级别的后处理器，这些方法对容器中所有的Bean都起作用。 在ApplicationContext中，只需要在配置文件中通过定义工厂后处理器和Bean后处理器，容器就会按照预定的机制运行。以上就是Spring容器中管理的Bean的生命周期，并不是每一步都在实际中用到，但是这些生命周期体现了Spring容器对Bean的管理理念，提供给开发者足够的空间来自己控制Bean。 FactoryBean如果某些Bean的实例化过程比较复杂，如果按照XML或者注解来配置的话需要大量的配置信息，并且灵活性也受限制。Spring为了解决这一情况，提供了FactoryBean，我们可以通过实现该工厂接口来定制实例化Bean的逻辑。FactoryBean接口定义了3个方法： T getObject():返回由FactoryBean创建的Bean的实例。 boolean isSingleton():由FactoryBean创建的Bean是Singleton还是prototype Class&lt;?&gt; getObjectType():返回FactoryBean创建的Bean的类型 当配置文件中的类型是FactoryBean时，容器通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean.getObject()方法所返回的对象。Spring提供了FactoryBean接口给我们提供了自定义实例化Bean的方法，在某些复杂的情况下很有用处。 Spring中用到的设计模式 工厂模式:IOC容器 代理模式:AOP 策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的 单例模式:默认情况下spring中的bean只存在一个实例 Spring IoC和AOPIoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。 AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。 参考 Spring容器——面向Bean编程 面试总结","categories":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"旋转数组的最小数字","slug":"旋转数组的最小数字","date":"2018-04-10T08:11:33.000Z","updated":"2018-04-20T13:23:05.149Z","comments":true,"path":"2018/04/10/旋转数组的最小数字/","link":"","permalink":"https://hsb786.github.io/2018/04/10/旋转数组的最小数字/","excerpt":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。","text":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。旋转数组的特点： 旋转之后的数组可以分为两个排序的子数组，且前面的子数组的元素都大于或等于后面子数组的元素。 最小或者最大元素位于两个子数组的分界 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 由于旋转数组的特点，前一个数组一定大于后一个数组。数组内部是升序的。 * 所以就可以使用二分查找。 * 定义minIndex为0，highIndex为length-1 * 若中间位大于array[minIndex]，则代表中间位处于前面部分,将minIndex设为midIndex； * 小于则处于后面部分,将highIndex设为midIndex * 最终minIndex位于前一个数组的最后一位，highIndex位于后一个数组的第一位 * 显然最小值就是highIndex所在的值。 * 特殊情况，但minIndex与highIndex上的值相等时，无法判断中间值是在前，还是在后。 * 所以只能用顺序查找 * @author: husb * @date: 2018年4月10日 下午2:56:26 */public static int findMin(int[] array) &#123; int lowIndex = 0; int highIndex = array.length - 1; int midIndex = (lowIndex + highIndex) / 2; // 当代查找数组第一位大于最后一位时，代表是旋转数组 while (array[lowIndex] &gt;= array[highIndex]) &#123; // 临界条件 前面最后一位，后面第一位。 后面第一位就是最小值 if (highIndex - lowIndex == 1) &#123; return array[highIndex]; &#125; // 当左下标的元素等于右下标的元素时，无法判断中间位是位于前面还是后面的。 // 只能用顺序查找 if (array[lowIndex] == array[highIndex]) &#123; return findMinInOrder(array, lowIndex, highIndex); &#125; // 当中间位大于前面第一位时，代表处于前面 if (array[midIndex] &gt; array[lowIndex]) &#123; lowIndex = midIndex; &#125; else &#123; // 否则处于后面 highIndex = midIndex; &#125; // 计算中间位 midIndex = (lowIndex + highIndex) / 2; &#125; //已排好序，返回低位即可 return array[lowIndex];&#125;/** * @Description: 当有重复元素的时候，无法确定中间的元素是前面的还是后面的 * @author: husb * @date: 2018年4月10日 下午2:33:52 */private static int findMinInOrder(int[] array, int lowIndex, int highIndex) &#123; int result = array[lowIndex]; for (int i = lowIndex + 1; i &lt;= highIndex; i++) &#123; if (result &gt; array[i]) &#123; result = array[i]; &#125; &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"用两个队列实现一个栈","slug":"用两个队列实现一个栈","date":"2018-04-10T08:11:19.000Z","updated":"2018-04-20T13:23:29.908Z","comments":true,"path":"2018/04/10/用两个队列实现一个栈/","link":"","permalink":"https://hsb786.github.io/2018/04/10/用两个队列实现一个栈/","excerpt":"用两个队列实现一个栈","text":"用两个队列实现一个栈123456789101112131415161718192021222324252627282930313233343536373839404142/** * Queue方法: * offer() 添加一个元素，失败则返回false * pool() 移除并返回队列头部元素，无则返回null * peek() 返回头部元素 无则返回null */private static Queue&lt;Object&gt; queue1 = new LinkedList&lt;&gt;();private static Queue&lt;Object&gt; queue2 = new LinkedList&lt;&gt;();private static void push(Object obj) &#123; if (!queue1.isEmpty()) &#123; queue1.offer(obj); &#125; else &#123; queue2.offer(obj); &#125; System.out.println(&quot;入栈:&quot; + obj);&#125;/** * 将一个队列里的数据都剪切给另一个队列中，只保留最后一位。 * 这样弹出的数据就是栈尾数据 * @author: husb * @date: 2018年4月10日 下午1:55:11 */private static void pop() &#123; if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123; System.out.println(&quot;栈里没有数据&quot;); return; &#125; if (queue1.isEmpty()) &#123; while (queue2.size() &gt; 1) &#123; queue1.offer(queue2.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue2.poll()); return; &#125; while (queue1.size() &gt; 1) &#123; queue2.offer(queue1.poll()); &#125; System.out.println(&quot;出栈:&quot; + queue1.poll());&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"用两个栈实现队列","slug":"用两个栈实现队列","date":"2018-04-10T08:10:52.000Z","updated":"2018-04-20T13:23:35.986Z","comments":true,"path":"2018/04/10/用两个栈实现队列/","link":"","permalink":"https://hsb786.github.io/2018/04/10/用两个栈实现队列/","excerpt":"用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。","text":"用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。1234567891011121314151617181920212223242526272829private static Stack&lt;Object&gt; stack1 = new Stack&lt;Object&gt;();private static Stack&lt;Object&gt; stack2 = new Stack&lt;Object&gt;();/** * stack1用来存放压入的元素 * @author: husb * @date: 2018年4月10日 下午1:19:07 */public static void appendTail(Object item) &#123; stack1.push(item);&#125;public static void deleteHead() &#123; //当stack2中有数据，直接弹出 if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); return; &#125; else &#123; //stack2压入stack1弹出的数据,这样stack2就是一个队列 while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; if (!stack2.isEmpty()) &#123; System.out.println(&quot;栈顶:&quot; + stack2.pop()); &#125; else &#123; System.out.println(&quot;栈中没有元素&quot;); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"二维数组的查找","slug":"二维数组的查找","date":"2018-04-10T04:01:22.000Z","updated":"2018-04-20T13:20:59.669Z","comments":true,"path":"2018/04/10/二维数组的查找/","link":"","permalink":"https://hsb786.github.io/2018/04/10/二维数组的查找/","excerpt":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。","text":"在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345678910111213141516171819202122/** * 从左下角开始比，查找的数字大于遍历值右移；查找的数字小于遍历值上移 * @author: husb * @date: 2018年4月10日 上午11:55:27 */public static boolean find(int targer, int[][] array) &#123; int rows = array.length; int columns = array[0].length; int i = rows - 1, j = 0; while (targer != array[i][j]) &#123; if (targer &gt; array[i][j]) &#123; j++; &#125; else &#123; i--; &#125; if (i &lt; 0 || j &lt; 0 || i &gt; rows || j &gt; columns) &#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hsb786.github.io/tags/算法/"}]},{"title":"线程池","slug":"线程池","date":"2018-04-10T02:13:01.000Z","updated":"2018-04-20T13:22:44.687Z","comments":true,"path":"2018/04/10/线程池/","link":"","permalink":"https://hsb786.github.io/2018/04/10/线程池/","excerpt":"ThreadPoolExecutor 参数 说明 corePoolSize 线程池中核心线程数量 maximumPoolSize 线程池中最大线程数量 keepAliveTime 非核心线程存活时间 unit keepAliveTime的时间单位 workQueue 存放任务的队列 threadFactory 用来生产线程的工厂 handler 当线程池中不能再放入任务时执行的handler","text":"ThreadPoolExecutor 参数 说明 corePoolSize 线程池中核心线程数量 maximumPoolSize 线程池中最大线程数量 keepAliveTime 非核心线程存活时间 unit keepAliveTime的时间单位 workQueue 存放任务的队列 threadFactory 用来生产线程的工厂 handler 当线程池中不能再放入任务时执行的handler 线程池状态12345volatile int runState;static final int RUNNING = 0;static final int SHUTDOWN = 1;static final int STOP = 2;static final int TERMINATED = 3; 当创建线程池后，初始时，线程处于RUNNING状态 调用shutdown()，线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕 调用shutdownNow()，线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 任务提交给线程池之后的处理策略 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出来执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过KeepAliveTime，线程也会被终止 默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 任务缓存队列及排队策略workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue，通常可以取下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小 LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务 任务拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略。 ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 线程池的关闭 shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。 shutdownNown()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。 Executors类提供的三种线程池Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUEExecutors.newSingleThreadExecutor(); //创建容量为1的缓冲池Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； 类型 核心线程数 最大线程数 Keep Alive 时间 任务队列 任务处理策略 CachedThreadPool 0 Integer.MAX_VALUE 一分钟 SynchronousQueue 线程启动数量无限大，新任务会直接分配或者创建一个线程执行 SingleThreadExecutor 1 1 0 LinkedBlockingQueue 线程池的大小为1，适用于业务逻辑上只允许1个线程进行处理的场景 FixedThreadPool 固定大小 固定大小（与核心线程数相同） 0 LinkedBlockingQueue 线程池大小固定，没有可用线程的时候任务会放入队列等待，队列长度无限制 在ThreadPoolExecutor中提供了三个专门供子类覆盖/重写的方法：beforeExecute(Thread t, Runnable r)、afterExecute(Runnable r, Throwable t)和terminated()。 beforeExecute：当线程池正要开始执行某个任务的时候（注意不是任务进入等待队列的时候，是将要开始正式在线程池中执行的时候），线程池会触发这个方法的调用。 afterExecute：当线程池完成了某一个任务的执行后，线程池就会触发这个方法。 terminated：当线程池本身停止执行的时候，该方法就会被调用。 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 参考 Java并发编程：线程池的使用 Java多线程之Callable接口及线程池 人人都能掌握的Java服务端性能优化方案 java锁优化的方法与思路-减少锁持有时间、减小锁粒度、锁分离、锁粗化、锁消除","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"java基础总结","slug":"java基础总结","date":"2018-04-09T13:28:54.000Z","updated":"2018-04-20T13:26:21.921Z","comments":true,"path":"2018/04/09/java基础总结/","link":"","permalink":"https://hsb786.github.io/2018/04/09/java基础总结/","excerpt":"初始化顺序 父类（静态变量，静态语句块） 子类（静态变量，静态语句块） 父类（实例变量，普通语句块） 父类（构造函数） 子类（实例变量，普通语句块） 子类（构造函数）","text":"初始化顺序 父类（静态变量，静态语句块） 子类（静态变量，静态语句块） 父类（实例变量，普通语句块） 父类（构造函数） 子类（实例变量，普通语句块） 子类（构造函数） Object123456789101112131415161718192021public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; 异常Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error用来表示JVM无法处理的错误，Exception分为两种： 受检异常（checked exception）：需要try…catch…语句捕获并进行处理，并且可以从一场恢复 非受检异常（unchecked exception）：是程序运行时错误，例如除0会引发Arithmetic Exceptino，此时程序崩溃并且无法恢复 创建对象的方式 直接new 反射 使用Class类的newInstance 只能调用无参构造函数 使用Constructor的newInstance 可以调用有参构造函数 clone 不会调用任何构造函数 反序列化 不会调用任何构造函数 动态获取类的方式 类名.class 对象名.getClass Class.forName(“类名”) 泛型(generics)允许在定义类和接口的时候使用类型参数E(type parameter)。声明的类型参数在使用时用用具体的类型来替换。 java集合有一个缺点是当把一个对象放入集合里面之后，集合就会”忘记”这个对象的数据类型，当再次取出该对象的时候，该对象的编译类型就变成了Object类型(该对象的运行时类型没变)。 造成的问题： 集合对元素类型没有任何限制，这样会引发一些问题。例如，想创建一个保存Dog对象的集合，但是程序也可以轻易的把Cat对象保存进去，所以会引发异常。 由于把对象保存到集合里面时，集合丢失了对象的状态信息，集合只知道它盛装的是Object，因此取出集合元素之后通常还需要进行强制类型转换。这种强制类型转换即增加了编程的复杂度，也可能引发类型转换ClassCastException异常。 在Java7以前，如果使用带有泛型的接口，类定义常量，那么调用构造器创建对象时构造器的后面也必须带泛型，这显得有些多余了。 从java7开始，java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号(&lt;&gt;)即可，Java可以推断括号里面应该是什么泛型信息。即上面两条语句可以改写成为如下的形式： 12List&lt;String&gt; strList=new ArrayList&lt;String&gt;();Map&lt;String,Integer&gt; scores=new HashMap&lt;String,Integer&gt;(); - 术语 ArrayList&lt;E> 泛型类型 ArrayList 原始类型 E 参数类型 &lt;&gt; 读作”typeof” ArrayList&lt;Intege\\r&gt; 参数化的类型 Integer 实际类型参数 “?” 通配符？表示任意类型，使用？通配符可以引用各种参数化的类型 限定通配符的上边界ArrayList&lt;? extends Number&gt; collection=new ArrayList(); 限定通配符的下边界ArrayList&lt;? super Integer&gt; collection=new ArrayList(); “擦除”泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。 多态存在的三个条件 有继承关系 子类重写父类方法 父类引用指向子类对象 以下三种类型的方法不能被重写： static方法。被static修饰的方法是属于类的，而不是属于实例的 final方法。被final修饰的方法是无法被子类重写 private方法。被private修饰的方法对子类不可见， 多态的分类 编译时多态，即方法的重载 运行时多态，即方法的重写 throw和throwsthrow: 表示抛出一个类的实例。throw关键字可以写在任何地方，并不强制必须写在catch块中，运行到throw所在的行，打印异常并立即退出当前方法。 throws: 用于方法声明，指明可能发生的异常。 try能单独和finally一起使用异常 ArrayListtransient Object[] elementData; 扩容1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 底层基于数组实现 插入和删除的时候，涉及到元素复制 String类的equals方法，与其它类型比较返回false。其他包装类也一样。 public boolean equals(Object anObject)","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"长期更新","slug":"长期更新","permalink":"https://hsb786.github.io/tags/长期更新/"}]},{"title":"多线程基础","slug":"多线程基础","date":"2018-04-09T13:03:41.000Z","updated":"2018-04-20T13:20:38.566Z","comments":true,"path":"2018/04/09/多线程基础/","link":"","permalink":"https://hsb786.github.io/2018/04/09/多线程基础/","excerpt":"线程间通信线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。","text":"线程间通信线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。 锁队列每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。 多线程对象的常用函数 Thread.currentThread()方法返回代码段正在被哪个线程调用的信息 Thread对象实例.isAlive()方法的功能是判断当前线程是否处于活跃状态(正在运行状态或者准备开始运行状态) Thread.sleep()方法的作用是在指定的毫秒数内让”当前执行的线程”休眠(暂停执行) getId()方法可以获取线程的唯一标识 yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。当放弃的时间不确定，有可能刚刚放弃，马上又获取CPU时间片。 对象锁何时会被释放 执行完同步代码块 在执行同步代码块的过程中，遇到异常而导致线程终止 在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池 如何判断线程是否处于停止状态 Thread.interrupted():测试当前线程是否已经中断，static方法，调用这个方法后线程的中断状态被清除。换句话说，如果连续２次调用该方法，则第二次调用将返回false。 this.isInterrupted():测试线程Thread对象实例是否已经中断，非static方法，不清除状态标识 调用interrupt()方法不会真的停止线程，而是在当前线程中打了一个停止的标记，还需要配合其他的代码来停止线程。 关于Callable和FutureCallable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 Future提供了三种功能： 判断任务是否完成 能够中断任务 能够获取执行结果 Future对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后再需要时检查Future是否已经有了结果，如果任务已经执行完成，就可以通过Future.get()方法获得执行结果。需要注意的是，Future.get()方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。 FutureTask123456789public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTask既可以做为Runnable被线程执行，又可以作为Future得到Callable的返回值 守护线程守护线程是一种特殊的线程，当进程中不存在非守护线程了，守护线程就自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。Deamon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。 对象及变量的并发访问“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是”脏读”，也就是取到的数据其实是被更改过的。而”线程安全”获得的实例变量的值是经过同步处理的，不会出现”脏读”的现象。 方法内的私有变量“非线程安全”问题存在于”实例变量”，如果是方法内部的私有变量，则不存在”非线程安全”问题，永远都是线程安全的，这是方法内部的变量是私有(作用域)的特性造成的。 锁关键字synchronized取得的锁都是对象锁，而不是把一段代码或者方法(函数)当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈现等待状态，前提是多个线程访问的是同一个对象。如果多个线程访问多个对象，则JVM会创建多个锁。 “可重入锁”:当有一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当这个线程再次想要获得这个对象的锁的时候还是可以获取的。特别的说明，当存在父子类继承关系时，子类是完全可以通过”可重入锁”调用父类的同步方法的。 静态同步synchronized方法与synchronized(class)代码块关键字synchronized还可以应用在static静态方法上，如果这样写，那是对当前的.java文件对应的Class类进行持锁。synchronized关键字加到static静态方法上是给Class类上锁，可以对类的所有对象实例起作用，而synchronized关键字加到非static静态方法上是给对象上锁，这2个锁不是同一个锁。synchronized(class)代码块的作用其实和synchronized static方法的作用一样。我们需要注意的是，synchronized(ClassName)与synchronized(ClassName的实例)，线程各自获取各自的锁，不会有等待。 注意:我们在将任何数据类型作为同步锁时，需要观察，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，就是异步的。 volatile关键字volatile的主要作用是使变量在多个线程间可见。简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动。同时关键字synchronized也可以同样的完成volatile关键字可见性的功能。(happens-before) ThreadLocal类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。 类Threadlocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入Threadlocal类中进行保存的。 公平锁与非公平锁公平与非公平锁：锁Lock分为”公平锁”和”非公平锁”，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果就是不公平的了。默认情况下，ReentrantLock类使用的是非公平锁。 ReentrantReadWriteLock类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用它可以加快运行效率。 读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的线程Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。 简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ReadWriteLock &#123; private int readThreadCounter = 0; // 正在读取的线程数（0个或多个） private int waitingWriteCounter = 0; // 等待写入的线程数（0个或多个） private int writeThreadCounter = 0; // 正在写入的线程数（0个或1个） private boolean writeFlag = true; // 是否对写入优先（默认为是） // 读取加锁 public synchronized void readLock() throws InterruptedException &#123; // 若存在正在写入的线程，或当写入优先时存在等待写入的线程，则将当前线程设置为等待状态 while (writeThreadCounter &gt; 0 || (writeFlag &amp;&amp; waitingWriteCounter &gt; 0)) &#123; wait(); &#125; // 使正在读取的线程数加一 readThreadCounter++; &#125; // 读取解锁 public synchronized void readUnlock() &#123; // 使正在读取的线程数减一 readThreadCounter--; // 读取结束，对写入优先 writeFlag = true; // 通知所有处于 wait 状态的线程 notifyAll(); &#125; // 写入加锁 public synchronized void writeLock() throws InterruptedException &#123; // 使等待写入的线程数加一 waitingWriteCounter++; try &#123; // 若存在正在读取的线程，或存在正在写入的线程，则将当前线程设置为等待状态 while (readThreadCounter &gt; 0 || writeThreadCounter &gt; 0) &#123; wait(); &#125; &#125; finally &#123; // 使等待写入的线程数减一 waitingWriteCounter--; &#125; // 使正在写入的线程数加一 writeThreadCounter++; &#125; // 写入解锁 public synchronized void writeUnlock() &#123; // 使正在写入的线程数减一 writeThreadCounter--; // 写入结束，对读取优先 writeFlag = false; // 通知所有处于等待状态的线程 notifyAll(); &#125;&#125; 锁优化 减少锁持有时间 可以使用同步代码块来代替同步方法。这样既可以减少锁持有的时间。 减少锁粒度 要在并发场景中使用Map的时候，记得使用ConcurrentHashMap来代替HashTable和HashMap。 锁分离 普通锁（如syncronized）会导致读阻塞写、写也会阻塞读，同时读读与写写之间也会进行阻塞，可以想办法将读操作和写操作分离开。 锁粗化 有些情况下我们希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。 锁消除 锁消除是Java虚拟机在JIT编译是，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。","categories":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/categories/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"术语","slug":"术语","date":"2018-04-09T05:53:41.000Z","updated":"2018-04-20T13:25:15.175Z","comments":true,"path":"2018/04/09/术语/","link":"","permalink":"https://hsb786.github.io/2018/04/09/术语/","excerpt":"happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 需要注意的是，上面提到的两个操作可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作可见","text":"happens-before在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 需要注意的是，上面提到的两个操作可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作可见 happends-before规则 程序顺序规则： 单个线程中的每个操作，happens-before于该线程中的任意后续操作 监视器锁规则： 对一个锁的解锁，happens-before于随后对这个锁的加锁 volatile变量规则： 对一个volatile变量的写，happends-before于任意后续对这个volatile变量的读 传递性： 如果A happeens-before B，且 B happeend-before C，那么A happeens-before C join规则： 如果线程A执行操作ThreadB.join()成功返回，那么线程B中的任意操作happeens-before与线程A从ThreadB.join()操作成功返回 fail-fastfail-fast机制是java集合(Collection)中的一种错误机制。当多个线程对同一集合的内容进行操作时，就可能会产生fail-fast事件。 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件 要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常 当使用fail-fast iterator对Collection或对Map进行操作过程中尝试直接修改Collection/Map的内容时，即使是在单线程下运行，java.util.ConcurrentModificationException异常也将抛出 Iterator是工作在一个独立的线程，并且拥有一个mutex锁。Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来对象发生变化时，这个索引表的内容不会同步该表，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照fail-fast原则Iterator会马上抛出ConsurrentModificationException异常。 所以Iterator在工作的时候是不允许被迭代的对象被改变的。但你可以使用Iterator本身的方法remove()来删除对象，Iteraror.remove()方法会在删除当前迭代对象的同时维护索引的一致性。 fail-safe 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 数据库三大范式 1NF：字段不可再分 2NF：主键依赖，一张表里的数据，必须是跟主键相关的 3NF：任意两个表不能出现重复的非主键字段 设计模式六大原则单一职责(Single Responsibility Principle)：一个类只负责一个功能领域中的相应职责 开闭(Open-Closed Principle)：对扩展开放，对修改关闭 里氏替换(Liskov Subsitution Principle)：子类能出现在基类出现的地方 依赖倒置(Dependency Inversion Principle)：针对接口编程，而不是针对实现类编程 接口隔离(Interface Segregation Principle)：使用多个专门的接口，而不使用单一的总接口 迪米特(Law of Demeter)：一个类尽可能少的与其它类发生相互作用 分布式领域CAP理论Consistency(一致性)：数据一致更新，所有数据变动都是同步的 Availability(可用性)：好的响应性能 Partition tolerance(分区容忍性)：可靠性 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 强一致性,弱一致性,最终一致性强一致性 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。 弱一致性 系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。 最终一致性 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。 假唤醒(spurious wake up)Linux中帮助中提到的：在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。 结果是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。这种效应成为”虚假唤醒”(spurious wakeup) 虽然虚假唤醒在pthread_cond_wait函数中可以解决，为了发生概率很低的情况而降低边缘条件（fringe condition）效率是不值得的，纠正这个问题会降低对所有基于它的所有更高级的同步操作的并发度。所以pthread_cond_wait的实现上没有去解决它。 所以通常的标准解决办法是这样的：将条件的判断从if 改为while pthread_cond_wait中的while()不仅仅在等待条件变量前检查条件变量，实际上在等待条件变量后也检查条件变量。 这样对condition进行多做一次判断，即可避免“虚假唤醒”. 这就是为什么在pthread_cond_wait()前要加一个while循环来判断条件是否为假的原因。 PO(persistant object) 持久对象在 o/r 映射的时候出现的概念，如果没有 o/r 映射，没有这个概念存在了。通常对应数据模型 ( 数据库 ), 本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的 java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。一般和数据中的表结构对应。 TO(Transfer Object) ，数据传输对象在应用程序不同 tie( 关系 ) 之间传输的对象 DTO（Data Transfer Object）数据传输对象这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 VO(view object) 值对象视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 BO(business object) 业务对象从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。 POJO(plain ordinary java object) 简单无规则 java 对象纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法！。 DAO(data access object) 数据访问对象是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作 设计模式分类设计模式分为三种类型，共23种。 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 23种设计模式简单介绍Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。 Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。 Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。 Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。 Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。 State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 创建型模式创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 CAS(Compare and Swap)CAS有3个操作数——内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 ABA问题比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。","categories":[{"name":"术语","slug":"术语","permalink":"https://hsb786.github.io/categories/术语/"}],"tags":[{"name":"长期更新","slug":"长期更新","permalink":"https://hsb786.github.io/tags/长期更新/"},{"name":"术语","slug":"术语","permalink":"https://hsb786.github.io/tags/术语/"}]},{"title":"记录一些容易忘记的东西","slug":"记录一些容易忘记的东西","date":"2018-04-09T00:42:41.000Z","updated":"2018-04-20T13:26:09.837Z","comments":true,"path":"2018/04/09/记录一些容易忘记的东西/","link":"","permalink":"https://hsb786.github.io/2018/04/09/记录一些容易忘记的东西/","excerpt":"接口不可以实现接口，可以继承多个接口 抽象类可以继承具体类 static不能被重写，重写是运行时动态绑定的 static变量发生在静态解析阶段，此时已经将字段的符号引用转换成了内存引用，将它与对应的类关联在了一起","text":"接口不可以实现接口，可以继承多个接口 抽象类可以继承具体类 static不能被重写，重写是运行时动态绑定的 static变量发生在静态解析阶段，此时已经将字段的符号引用转换成了内存引用，将它与对应的类关联在了一起子类构造方法默认会寻找父类无参构造方法，若没有，编译不通过 关于抽象类JDK 1.8以前，抽象类的方法默认访问权限为protectedJDK 1.8时，抽象类的方法默认访问权限变为default 关于接口JDK 1.8以前，接口中的方法必须是public的JDK 1.8时，接口中的方法可以是default，还可以是staticJDK 1.9时，接口中的方法可以是private的 volatile 禁止指令重排序： 添加内存屏障，保证前面已经完成，后面都没开始（happens-before） 内部类访问外部类 外部类.this.成员XX 重载静态绑定，根据参数的静态类型而不是实际类型作为判断依据的 java的8中基本类型，除了float和double之外，其它6种都实现了常量池 boolean类型不允许进行任何类型的转换处理 java7以后，常量池被放入到堆空间中。导致intern()函数的功能不同。intern()检查常量池是否存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用 ArrayList 默认容量 10 HashMap 16 newInstance 低效率，只能调用无参构造。将new这个方式分解为两步： 首先调用class的加载方式加载某个类，然后实例化 HashSet底层借用HashMap，利用HashMap中key不重复的特性 12345private static final Object PRESENT=new Object(); public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 字符只有在内存中才会形成，其它都是以字节的方式进行的 强引用： Object obj=new Object()，只要引用还在，就不会被回收软引用： 内存不够才会被回收弱引用： 下一次垃圾收集器工作时会被回收。虚引用： 随时可能被回收，目的是能在这个对象被回收时收到一个系统通知 内加载器： JVM动态加载所需的类。 委托、可见、单一。双亲委派，交给父加载器；父加载器加载的类子加载器都能看到；一个类只能被一个加载一次 每个对象有两个队列： 就绪队列、阻塞队列 ReentrantLock结合Condition可以有选择性地进行通知，在调度上更加灵活 指令重排序： 编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段 null可以强制转换为任何java类类型；其返回值还是null，可以调用static方法 基本类型与包装类比较；包装类拆箱，进行值比较 子类，也叫导出类、派生类 Math.round() +0.5Math.ceil() 向上取整Math.floor() 向下取整 类变量有默认值，局部变量是没有默认值的 wait，sleep都必须进行异常捕获 IllegalMonitorStateException 抛出该异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器，然而本身没有指定的监视器的线程。 也就是当前的线程不是此对象监视器的所有者。当前线程要锁定该对象之后，才能用锁定的对象执行这些方法，这里需要用到synchronized关键字，锁定哪个对象就用哪个对象来执行notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException异常。 Java的跨平台特性是指它的字节码可以在多个平台上运行 getMethods 返回Method对象数组，包括当前类及父类所有public方法getDeclaredMethod 方法Method对象数组，包括当前类的所有方法。不包括父类。 java用来运行一个.class文件 javadoc用来生成api文档 jar用来生成jar包 javac用来把.java文件编译为.class文件 notify调用后，要等同步语句块执行完才释放锁；wait不是。 public static int parseInt(String s) throws NumberFormatException {} Integer.parseInt 返回int 类型 getClass() 返回的是实际类 关于try和finally 首先执行try里的return，但是有finally语句还要执行，于是先执行return后面的语句，把要返回的值保存到局部变量。 执行finally语句的内容，其中有return语句，这时就会忽略try中的return，直接返回。 返回值问题，可以认为try（或者catch）中的return语句的返回值放入线程栈的顶部：如果返回值是基本类型则顶部存放的就是值，如果是引用类型，则顶部存放的是引用。finally中的return语句可以修改引用所对应的对象，无法修改基本类型。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"},{"name":"长期更新","slug":"长期更新","permalink":"https://hsb786.github.io/tags/长期更新/"}]},{"title":"区别","slug":"区别","date":"2018-04-08T23:48:41.000Z","updated":"2018-04-20T13:22:06.264Z","comments":true,"path":"2018/04/09/区别/","link":"","permalink":"https://hsb786.github.io/2018/04/09/区别/","excerpt":"sleep和wait区别 sleep是Thread类的static方法； wait是Object类的方法 sleep睡眠时保持对象锁； wait释放锁 sleep可以放在任何地方； wait必须放在synchronized block中，否则会在runtime时扔出IllegalMonitorStateExcetion异常","text":"sleep和wait区别 sleep是Thread类的static方法； wait是Object类的方法 sleep睡眠时保持对象锁； wait释放锁 sleep可以放在任何地方； wait必须放在synchronized block中，否则会在runtime时扔出IllegalMonitorStateExcetion异常 synchronized和volatile区别 volatile是线程同步的轻量级实现，性能比synchronized好 volatile只能修饰变量； synchronized可修饰方法和代码块 volatile能保证数据可见性，不保证原子性； synchronized可以保证原子性，也可以间接保证可见性。synchronized会将私有内存和公共内存中的数据进行同步 volatile解决的是变量在多个线程间的可见性； synchronized解决的是多个线程访问资源的同步性 内部类在类中定义一个类(私有内部类，静态内部类)在方法中定义一个类(局部内部类，匿名内部类) 私有内部类编译器做的手脚 在内部类中创建了包可见构造器，从而使外部类获得了创建权限 在外部类中创建了访问私有变量的静态方法，从而使内部类获得了范围权限 静态内部类只能访问其外部类的静态成员 局部内部类没有修饰符，局部内部类只能范围该方法中的局部变量，并且这些局部变量一定要是final修饰的常量或者隐含是final的(java8) 匿名内部类不能抽象；仅能被使用一次；不能存在静态成员变量和方法 只有静态内部类可以访问静态成员变量 Session和Cookie的区别 Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 客户端传JSESSIONID，服务端就可以通过这个ID，来将存储到服务端的数据取出 Servlet和Filter的区别 Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对响应的数据进行后处理。 强、软、弱、虚引用强引用 Object obj=new Object()，只要引用还在，就不会被回收软引用 内存不够才会被回收弱引用 下一次垃圾收集器工作时会被回收。虚引用 随时可能被回收，目的是能在这个对象被回收时收到一个系统通知。 垃圾回收期是一个优先级较低的线程，并不一定能迅速发现弱引用对象 HashMap和Hashtable的区别先吐槽一下Hashtable的命名，为啥t要小写 Hashtable是线程安全的； HashMap不是 Hashtable不允许有null的KV； HashMap允许 Hashtable继承Dictionary类； HashMap继承AbstractMap HashMap有一个子类LinkedHashMap，对这个类对象进行迭代时，它的顺序是有序的。可以轻易的将LinkedHashMap转换成HashMap； Hashtable不好实现 相同点：都实现了Map接口 join和synchronized的区别join在内部使用wait()方法进行等待；synchronized使用的是对象监视器原理作为同步 join和sleep的区别join底层调用wait方法，执行到wait释放锁sleep在睡眠时不释放锁 JDK动态代理和CGLIB代理的区别 JDK动态动态代理是利用反射机制生存一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类 CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。 JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。 重载和重写的区别重载： 方法有同样的名称，但是参数列表不同 重写：在java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于它们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法 区别 重载 重写 编译期概念，遵循“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法 运行期概念，遵循“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法 方法签名必须不同 方法签名必须一样 返回类型可以不同 返回类型必须相同 无限制 更好的访问，不能抛出更广泛的异常（遵循里式替换原则） 组合与继承的区别和联系在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；) 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法） 继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。） 组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。 优缺点对比 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 如何选择 继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。&lt;&lt;java编程思想&gt;&gt; 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。&lt;> Compareable和ComparatorComparable：一个实现了Comparable接口的类，可以让其自身的对象和其它对象进行比较。也就是说，同一个类的对象之间要想比较，对应的类就要实现Compareable接口，并实现compareTo()方法。 Comparator：不改变原有的类。通过定义一个类实现Comparator接口，重写compare()方法。 Comparator通常用于排序。Java中的Collectinos和Arrays都包括排序的sort方法，该方法可以接受一个Comparator的实例(比较器)来进行排序；new TreeSet&lt;&gt;(new Comparator()) getAttribute和getParameter的区别ServletRequest接口中提供了getAttribute和getParameter两个方法，都是用于获取参数（属性）值的，那么这两个方法有什么区别呢？或者说Attribute和Parameter的区别是什么呢？ 来源不同 参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的； 属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的. 操作不同 参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取； 属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute() 数据类型不同 参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。 属性（attribute）的值可以是任意一个Object类型。 forward和include的区别void forward(ServletRequest request, ServletResponse response) – 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。 void include(ServletRequest request, ServletResponse response) – 把另一个资源的内容包含到当前响应中。 如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。 用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"hash","slug":"hash","date":"2018-04-08T13:23:41.000Z","updated":"2018-04-20T13:16:15.814Z","comments":true,"path":"2018/04/08/hash/","link":"","permalink":"https://hsb786.github.io/2018/04/08/hash/","excerpt":"Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。","text":"Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。 常见的Hash函数有以下几个： 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种： 开放定址法： 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出区 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 参考 全网把Map中的hash()分析的最透彻的文章，别无二家。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"事务","slug":"事务","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-20T13:25:03.009Z","comments":true,"path":"2018/04/08/事务/","link":"","permalink":"https://hsb786.github.io/2018/04/08/事务/","excerpt":"事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。在计算机术语中，事务通常就是指数据库事务。","text":"事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（unit）。在计算机术语中，事务通常就是指数据库事务。 概念一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包括有以下两个目的 为数据库提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离的方法，以防止彼此的操作互相干扰。 当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。 但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。 特性并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 原子性是基础，隔离性是手段，持久性是目的，最重要的是一致性 脏读，不可重复读，幻读Dirty Read（脏读）：又称无效数据的读出。指一个事务对数据进行了修改，还没有提交到数据库中，另外一个事务访问并使用了该数据。由于这个数据还没有提交，所以另外一个事务读到的这个数据是脏数据。 时间 事务A（存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 查询余额（1000 元） T4 取出 1000 元（余额 0 元） T5 查询余额（0 元） T6 撤销事务（余额恢复为 1000 元） T7 存入 500 元（余额 500 元） T8 提交事务 Unrepeatable Read（不可重复读）：一个事务范围内对两个相同的查询却返回了不同数据。这是因为其它事务修改的提交而引起的。 时间 事务A（存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 查询余额（1000 元） T4 查询余额（1000 元） T5 取出 1000 元（余额 0 元) T6 提交事务 T7 查询余额（0 元) Phantom Read（幻读）：指当事务不是独立执行时发生的一种现象。例如第一个事务涉及到表中全部数据行的修改，另一个事务添加了一行新数据，那么执行第一个事务后，发现表中还有没有被修改的数据行。 时间 事务 A（统计总存款） 事物B（取款） T1 开始事务 T2 开始事务 T3 统计总存款（10000 元） T4 存入 100 元 T5 提交事务 T6 统计总存款（10100 元） 银行工作人员，每次统计总存款，都看到不一样的结果。不过这也确实也挺正常的，总存款增多了，肯定是这个时候有人在存钱。但是如果银行系统真的这样设计，那算是玩完了。这同样也是事务没有隔离所造成的，但对于大多数应用系统而言，这似乎也是正常的，可以理解，也是允许的。银行里那些恶心的那些系统，要求非常严密，统计的时候，甚至会将所有的其他操作给隔离开，这种隔离级别就算非常高了（估计要到 SERIALIZABLE 级别了）。 归纳 脏读：事务 A 读取了事务 B 未提交的数据，并在这个基础上又做了其他操作。 不可重复读：事务 A 读取了事务 B 已提交的更改数据。 幻读：事务 A 读取了事务 B 已提交的新增数据。 第一条是坚决抵制的，后两条在大多数情况下可不作考虑。 隔离级别 未提交读(Read uncommitted)：一个事务可以读取另一个事务未提交的数据 提交读(Read committed)：在一个事务修改数据过程中，其它事务不能读该数据 数据库锁情况 事务对当前读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级排他锁，直到事务结束才释放。 可重复读(Repeatable reads)：解决不可重复读的问题 数据库锁情况 事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放 事务在更新某数据的瞬间，必须先对其加行级排他锁，直到事务结束才释放 序列化(Serializable)：最高的隔离级别 数据库锁情况 事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放 事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放 事务隔离级别 脏读 不可重复读 幻读 READ_UNCOMMITTED 允许 允许 允许 READ_COMMITTED 禁止 允许 允许 REPEATABLE_READ 禁止 禁止 允许 SERIALIZABLE 禁止 禁止 禁止 隔离级别越高，同时在并发性上也越低 我们知道 JDBC 只是连接 Java 程序与数据库的桥梁而已，那么数据库又是怎样隔离事务的呢？其实它就是“锁”这个东西。当插入数据时，就锁定表，这叫“锁表”；当更新数据时，就锁定行，这叫“锁行”。 除了 JDBC 给我们提供的事务隔离级别这种解决方案以外，还有哪些解决方案可以完善事务管理功能呢？ 不妨看看 Spring 的解决方案吧，其实它是对 JDBC 的一个补充或扩展。它提供了一个非常重要的功能，就是：事务传播行为（Transaction Propagation Behavior）。 事务传播行为（Transaction Propagation Behavior） PROPAGATION_REQUIRED RROPAGATION_REQUIRES_NEW PROPAGATION_NESTED PROPAGATION_SUPPORTS PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_MANDATORY 首先要明确的是，事务是从哪里来？传播到哪里去？答案是，从方法 A 传播到方法 B。Spring 解决的只是方法之间的事务传播，那情况就多了，比如: 方法 A 有事务，方法 B 也有事务。 方法 A 有事务，方法 B 没有事务。 方法 A 没有事务，方法 B 有事务。 方法 A 没有事务，方法 B 也没有事务。 假设事务从方法 A 传播到方法 B，您需要面对方法 B，问自己一个问题： 方法 A 有事务吗？ 如果没有，就新建一个事务；如果有，就加入当前事务。这就是 PROPAGATION_REQUIRED，它也是 Spring 提供的默认事务传播行为，适合绝大多数情况。 如果没有，就新建一个事务；如果有，就将当前事务挂起。这就是 RROPAGATION_REQUIRES_NEW，意思就是创建了一个新事务，它和原来的事务没有任何关系了。 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。这就是 PROPAGATION_NESTED，也就是传说中的“嵌套事务”了，所嵌套的子事务与主事务之间是有关联的（当主事务提交或回滚，子事务也会提交或回滚）。 如果没有，就以非事务方式执行；如果有，就使用当前事务。这就是 PROPAGATION_SUPPORTS，这种方式非常随意，没有就没有，有就有，有点无所谓的态度，反正我是支持你的。 如果没有，就以非事务方式执行；如果有，就将当前事务挂起。这就是 PROPAGATION_NOT_SUPPORTED，这种方式非常强硬，没有就没有，有我也不支持你，把你挂起来，不鸟你。 如果没有，就以非事务方式执行；如果有，就抛出异常。这就是 PROPAGATION_NEVER，这种方式更猛，没有就没有，有了反而报错，确实够牛的，它说：我从不支持事务！ 如果没有，就抛出异常；如果有，就使用当前事务。这就是 PROPAGATION_MANDATORY，这种方式可以说是牛逼中的牛逼了，没有事务直接就报错，确实够狠的，它说：我必须要有事务！ Spring 给我们带来了事务传播行为，这确实是一个非常强大而又实用的功能。除此以外，也提供了一些小的附加功能，比如： 事务超时（Transaction Timeout）：为了解决事务时间太长，消耗太多的资源，所以故意给事务设置一个最大时常，如果超过了，就回滚事务。 只读事务（Readonly Transaction）：为了忽略那些不需要事务的方法，比如读取数据，这样可以有效地提高一些性能。 锁的分类按锁级别划分：共享锁(Share Lock) 又称读锁，是读取操作创建的锁。其它用户可以并发读取数据，但任何事务都不能对数据进行修改，直到已释放所有共享锁 如果事务T对数据A加上共享锁后，则其它事务只能对A再加共享锁，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据 用法 select … LOCK IN SHARE MODE， 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其它线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据 排他锁(eXclusive Lock) 又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。获取排他锁的事务既能读数据，又能修改数据 用法 select … FOR UPDATE 当没有其它线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞 按锁的粒度划分行级锁 对当前操作的行进行加锁。加锁粒度最小，但加锁的开销最大。行级锁分为共享锁和排他锁 特点 开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁 特点 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 Innodb中的行锁与表锁 InnoDB行锁是通过给索引上的索引项加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 行级锁与死锁 在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。 当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。 常见的三种解决死锁的方法 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率 按使用方式划分悲观锁 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 在数据库中，悲观锁的流程如下： 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 优点与不足 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 悲观锁，就是总觉得有刁民想害朕，每次访问数据的时候都觉得会有别人修改它，所以每次拿数据时都会上锁，确保在自己使用的过程中不会被他人访问。乐观锁就是很单纯，心态好，所以每次拿数据的时候都不会上锁，只是在更新数据的时候去判断该数据是否被别人修改过。(阿姨真有意思) 大多数的关系数据库写入操作都是基于悲观锁，缺点在于如果持有锁的客户端运行的很慢，那么等待解锁的客户端被阻塞的时间就越长。Redis的事务是基于乐观锁的机制，不会在执行WATCH命令时对数据进行加锁，只是会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端。乐观锁适用于读多写少的情况，因为在写操作比较频繁的时候，会不断地retry，从而降低性能。 参考 数据库 面试总结 Transaction 那点事儿","categories":[{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/categories/sql/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"},{"name":"sql","slug":"sql","permalink":"https://hsb786.github.io/tags/sql/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-20T13:19:31.593Z","comments":true,"path":"2018/04/08/SpringMVC/","link":"","permalink":"https://hsb786.github.io/2018/04/08/SpringMVC/","excerpt":"SpringMVC工作流程SpringMVC是一种基于Servelt的技术，它提供了控制器DispatchServlet和相关组件，这些SpringMVC的组件一起协调工作，完成对web请求的相应。","text":"SpringMVC工作流程SpringMVC是一种基于Servelt的技术，它提供了控制器DispatchServlet和相关组件，这些SpringMVC的组件一起协调工作，完成对web请求的相应。 客户端发出一个HTTP请求，Web服务器接收到这个请求。服务器检查HTTP请求的路径，如果匹配DispatchServelt的请求映射路径(web.xml中指定)，则Web容器将该请求转交给对应的DispatchServlet处理 DispatchServlet接收到这个请求后，将根据请求的信息以及HandlerMapping配置找到处理请求的处理器（Handler）。HandlerMapping可以简单理解为统一资源标识符URL域与处理器Handler之间的关系。 找到对应的处理器之后，通过HandlerAdapter对Handler进行封装，再以同一的适配器接口调用Handler。因为为了更加灵活的编码和AOP增强功能，SpringMVC会给处理器加入拦截器，这样就可以在处理器执行前后加入执行前后加入自己的代码，于是就构成了一个处理器的执行链，所以SpringMVC提供了处理器适配器HandlerAdapter，帮助我们运行相应的处理器以及我们添加进去的拦截器。 处理器完成了请求的业务逻辑之后将返回一个ModelAndView对象给DIspatcherServlet，这里ModelAndView包含了视图的逻辑名和模型数据信息。 得到了ModelAndView之后，DispatchServlet借助ViewResolver视图解析器将逻辑试图转换为真实视图。 通过ViewResolver视图解析器得到了真实视图后，DispatServlet使用这个真实视图对象对ModelAndView中的模型数据进行渲染。 最终DispatchServlet将渲染过后的视图对象返回给请求的客户端，客户端得到的响应可能是一个普通的HTML页面，也可能是一个JSON串，甚至是一张图片等等不同的视图模型。 另一个说法 DispatcherServlet是什么它是Spring MVC的核心。每个由Spring MVC处理的请求都要经过DispatcherServlet。一般而言，它是前端控制器模式的实现，为应用提供一个统一入口。DispatcherServlet是连接Java与Spring的桥梁，处理所有传入的请求。并且与其他声明在web.xml中的Servlet一样，也是通过一个URL pattern将每个请求映射到DispatcherServlet。DispatcherServlet负责将请求委派给Spring MVC中其他的组处件理，比如注有@Controller或@RestController的Controller类，HandlerMappers（处理映射），View Resolvers(视图解析器)等等。 尽管，请求映射是由 @ResquestMapping 注解完成的，但实际上是由 DispatcherServlet 将请求委派给相应的 Controller 来处理的。 DispatcherServlet如何处理请求正如上面所说，DispatcherServlet 被用来处理所有传入的请求，并将它们路由到不同的 Controller 来进行进一步处理。它决定了由哪个 Controller 处理请求。 DispatcherServlet 使用处理器映射来将传入的请求路由到处理器。默认情况下，使用 BeanNameUrlHandlerMapping 和 由 @RequestMapping 注解驱动的DefaultAnnotationHandlerMapping。 为了找到正确的方法来处理请求，它会扫描所有声明了 @Controller 注解的类，并且通过 @RequestMapping 注解找到负责处理该请求的方法。@RequestMapping 注解可以通过路径来映射请求(比如: @RequestMapping(“path”)), 也可以通过 HTTP 方法(比如: @RequestMapping(“path”, method=RequestMethod.GET)), 也可以通过请求参数(比如: @RequestMapping(“path””, method=RequestMethod.POST, params=”param1”)),还可以通过 HTTP 请求头(比如: @RequestMapping(“path”, header=”content-type=text/*”))。我们也可以在类级别声明 @RequestMapping 注解来过滤传入的请求。 在请求处理之后，Controller 会将逻辑视图的名字和 model 返回给 DispatcherServlet。之后利用视图解析器定位到真正的 View 以便渲染结果。我们可以指定使用的视图解析器，默认情况下，DispatcherServlet 使用 InternalResourceViewResolver来将逻辑视图的名字转换成真正的视图，比如 JSP。 选定视图之后，DispatcherServlet 会将数据模型与视图相结合，并将结果返回给客户端。并不是任何时候都需要视图，比如一个 RESTful 的 web 服务就不需要，它们的处理方法会利用 @ResponseBody 注解直接将请求结果返回给客户端。可以看REST with Spring course了解更多关于如何使用 Spring MVC 开发和测试 RESTful 服务的知识。 总结 DispatcherServlet 是 Spring MVC 应用中主要的控制器。所有的请求都会先经由 DispatcherServlet 处理，再由 Controller (声明有 @Controller 注解的类) 处理。 DispatcherServlet 是前端控制器模式的实现。前端控制器就是个用来处理网站所有请求的控制器。 就像其他的 Servlet， DispatcherServlet 也是声明和配置在 web.xml 文件中的： 1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; DispatcherServlet 继承自 HttpServlet 基类。Servlet 引擎(比如 Tomcat) 创建该类的实例，并且调用它不同的方法，比如：init(), service(), destroy()。 DispatcherServlet 为 Spring MVC 应用提供统一入口，处理所有的请求。 DispatcherServlet 也完全与 Spring IoC 容器集成，可以使用 Spring 框架的每一个特性，比如依赖注入。 当 DispatcherServlet 被配置为 load-on-startup = 1,意味着该 servlet 会在启动时由容器创建，而不是在请求到达时。这样做会降低第一次请求的响应时间，因为DispatcherServlet 会在启动时做大量工作，包括扫描和查找所有的 Controller 和 RequestMapping。 在 DispatcherServlet 初始化期间，Spring 框架会在 WEB-INF 文件夹中查找名为 [servlet-name]-servlet.xml 的文件，并创建相应的 bean。比如，如果 servlet 像上面 web.xml 文件中配置的一样，名为 “SpringMVC”，那么会查找 “SpringMVC-Servlet.xml”的文件。如果全局作用域中有相同名字的bean，会被覆盖。可以用 servlet 初始化参数 contextConfigLocation更改配置文件的位置。 在 Spring MVC 框架中，每个 DispatcherServlet 都有它自己的 WebApplicationContext ，并且继承了根 WebApplicationContext 中定义的所有 bean。这些继承的 bean 在 servlet 指定的作用域中可以被重载，也可以在其指定作用域中定义新的 bean。 Spring MVC 中的 DispatcherServlet也允许返回 Servlet API 定义的 last-modification-date。为了决定请求最后修改时间，DispatcherServlet会先查找合适的 handler mapping，然后检测处理器是否实现了 LastModified 接口。如果实现了，就调用接口的 getLastModified(request) 方法，并将该值返回给客户端。 以上就是关于 DispatcherSerlvet 的内容。正如上面所讲，DispacherServlet 是 Spring MVC 的骨干，是主要的控制器，用来将不同的 HTTP 请求路由当相应的 Controller。它是前端控制器设计模式的实现，并且为应用提供单一入口。可以在 web.xml 中配置 DispatcherServlet，但建议将 load-on-startup 设置为 1。这样容器会在启动时加载该 Serlvet 而不是请求到达时。这样能减少第一个请求的响应时间。 参考 Spring-MVC框架入门 【译】Spring MVC 中的 DispatcherServlet","categories":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hsb786.github.io/tags/Spring/"}]},{"title":"值传递和引用传递","slug":"值传递和引用传递","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-20T13:23:39.531Z","comments":true,"path":"2018/04/08/值传递和引用传递/","link":"","permalink":"https://hsb786.github.io/2018/04/08/值传递和引用传递/","excerpt":"值传递 指在调用函数时将实际参数复制一份传递到函数中，那么在函数中对参数所进行的修改，将不会影响到实际参数。 引用传递 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。","text":"值传递 指在调用函数时将实际参数复制一份传递到函数中，那么在函数中对参数所进行的修改，将不会影响到实际参数。 引用传递 指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。求值策略 | 求值时间 | 求值方式 | 根本区别—|—|—|—值传递 | 调用前 | 值的结果（原值的副本）| 会创建副本引用传递 | 调用前 | 原值（原始对象，无副本）| 不创建副本 值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份到形参 java只有值传递，不存在引用传递 java在传递引用类型数据时，把实际参数的内存地址复制了一份，传递给了形参","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"防止重复发送 Ajax 请求的解决方案","slug":"防止重复发送 Ajax 请求的解决方案","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-20T13:21:17.374Z","comments":true,"path":"2018/04/08/防止重复发送 Ajax 请求的解决方案/","link":"","permalink":"https://hsb786.github.io/2018/04/08/防止重复发送 Ajax 请求的解决方案/","excerpt":"连续点击多个按钮，可能导致先请求的数据后显示出来。 解决方案 1. 将ajax请求的async设置为false 2. 利用jquery ajaxPrefilter中断请求 3. 加遮罩框","text":"连续点击多个按钮，可能导致先请求的数据后显示出来。 解决方案 1. 将ajax请求的async设置为false 2. 利用jquery ajaxPrefilter中断请求 3. 加遮罩框12345678910111213141516171819var pendingRequests = &#123;&#125;;$.ajaxPrefilter(function( options, originalOptions, jqXHR ) &#123; var key = options.url; console.log(key); if (!pendingRequests[key]) &#123; pendingRequests[key] = jqXHR; &#125;else&#123; //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 &#125; var complete = options.complete; options.complete = function(jqXHR, textStatus) &#123; pendingRequests[key] = null; if ($.isFunction(complete)) &#123; complete.apply(this, arguments); &#125; &#125;;&#125;); 核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清楚，这就保证了在任一时刻只能有一个同样的请求发送 局限性：仅对jquery的ajax有作用 参考 防止重复发送 Ajax 请求的解决方案","categories":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://hsb786.github.io/tags/前端/"}]},{"title":"一些小技巧","slug":"一些小技巧","date":"2018-04-08T09:58:41.000Z","updated":"2018-04-20T13:23:11.472Z","comments":true,"path":"2018/04/08/一些小技巧/","link":"","permalink":"https://hsb786.github.io/2018/04/08/一些小技巧/","excerpt":"位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快 X % 2^n = X &amp; (2^n-1)","text":"位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快 X % 2^n = X &amp; (2^n-1) 判段一个数组是否包含某个值12Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(arr)); return set.contains(targetValue); 效率慢，要将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其它操作。 可以使用Apache Commons类库中提供的ArrayUtils类的contains方法contains内部调用indexOf方法 123456789101112131415161718192021222324252627282930public static boolean contains(Object[] array, Object objectToFind) &#123; return indexOf(array, objectToFind) != INDEX_NOT_FOUND;&#125;public static int indexOf(Object[] array, Object objectToFind) &#123; return indexOf(array, objectToFind, 0);&#125;public static int indexOf(Object[] array, Object objectToFind, int startIndex) &#123; if (array == null) &#123; return INDEX_NOT_FOUND; &#125; if (startIndex &lt; 0) &#123; startIndex = 0; &#125; if (objectToFind == null) &#123; for (int i = startIndex; i &lt; array.length; i++) &#123; if (array[i] == null) &#123; return i; &#125; &#125; &#125; else if (array.getClass().getComponentType().isInstance(objectToFind)) &#123; for (int i = startIndex; i &lt; array.length; i++) &#123; if (objectToFind.equals(array[i])) &#123; return i; &#125; &#125; &#125; return INDEX_NOT_FOUND;&#125; 整数二进制表示中1的个数 123456int count=0;while(n!=0) &#123; //将二进制表示中的最低位的1变为0 n=n&amp;(n-1); count++;&#125; NaN A constant holding a Not-a-Number (NaN) value of type public static final double NaN = 0.0d /0.0; Java中的Double和Float都有isNaN。判断一个数是不是NaN，通过v!=v的方式。 NaN是唯一与自己不相等的值，NaN与任何值都不相等。","categories":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/categories/爪哇/"}],"tags":[{"name":"爪哇","slug":"爪哇","permalink":"https://hsb786.github.io/tags/爪哇/"}]},{"title":"Java虚拟机是如何执行线程同步的","slug":"Java虚拟机是如何执行线程同步的","date":"2018-04-08T09:48:41.000Z","updated":"2018-04-20T13:24:46.656Z","comments":true,"path":"2018/04/08/Java虚拟机是如何执行线程同步的/","link":"","permalink":"https://hsb786.github.io/2018/04/08/Java虚拟机是如何执行线程同步的/","excerpt":"线程和共享数据 在JVM中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其它线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。 在JVM中，堆内存是所有线程共享的。对象在堆中。 还有一部分数据保存JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象引用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。","text":"线程和共享数据 在JVM中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其它线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。 在JVM中，堆内存是所有线程共享的。对象在堆中。 还有一部分数据保存JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象引用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。 对象和类的锁 JMM中有两块区域可以被所有线程共享 堆，存放着所有对象方法区，存放着静态变量 那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果 为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。但线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其它申请锁的线程。 类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个java.lang.Class对象，当你锁住一个类的时候，其实锁住的是其对应的Class对象 监视器（Monitors） 锁其实是通过监视器实现的，监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。 每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，它是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。 当线程离开代码块时，无论如何离开，都会释放所关联对象的锁 多次加锁 同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为1，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其它线程便可以获得锁。 同步 在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。 参考 Java虚拟机是如何执行线程同步的","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hsb786.github.io/categories/JVM/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hsb786.github.io/tags/多线程/"}]},{"title":"lombok","slug":"lombok","date":"2018-04-08T08:23:41.000Z","updated":"2018-04-20T13:18:36.359Z","comments":true,"path":"2018/04/08/lombok/","link":"","permalink":"https://hsb786.github.io/2018/04/08/lombok/","excerpt":"通过使用@Data注解自动帮你生成getters,setters,toString(),equals(),hashCode()方法 @AllArgsConstructor 全参构造函数 @NoArgsConstructor 无参构造函数","text":"通过使用@Data注解自动帮你生成getters,setters,toString(),equals(),hashCode()方法 @AllArgsConstructor 全参构造函数 @NoArgsConstructor 无参构造函数","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"VSCode快捷键","slug":"VSCode快捷键","date":"2018-04-08T07:58:41.000Z","updated":"2018-04-20T13:20:01.055Z","comments":true,"path":"2018/04/08/VSCode快捷键/","link":"","permalink":"https://hsb786.github.io/2018/04/08/VSCode快捷键/","excerpt":"","text":"命令 语义 ctrl B 侧边栏显/隐 ctrl shift E 资源管理器 ctrl tab 文件切换 F1或ctrl shift p 命令窗口 ctrl , 用户设置","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"git命令","slug":"gitCommand","date":"2018-04-08T07:42:41.000Z","updated":"2018-04-20T13:16:09.817Z","comments":true,"path":"2018/04/08/gitCommand/","link":"","permalink":"https://hsb786.github.io/2018/04/08/gitCommand/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]},{"title":"markdown","slug":"markdown","date":"2018-04-08T04:31:41.000Z","updated":"2018-04-20T13:18:44.008Z","comments":true,"path":"2018/04/08/markdown/","link":"","permalink":"https://hsb786.github.io/2018/04/08/markdown/","excerpt":"Cmd Markdown 简明语法手册标签： Cmd-Markdown","text":"Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票","categories":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://hsb786.github.io/tags/工具/"}]}]}