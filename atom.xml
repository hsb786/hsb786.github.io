<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-16T11:53:59.308Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP</title>
    <link href="https://hsb786.github.io/2018/04/16/HTTP/"/>
    <id>https://hsb786.github.io/2018/04/16/HTTP/</id>
    <published>2018-04-16T10:43:52.000Z</published>
    <updated>2018-04-16T11:53:59.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？</p><p>还能怎么办，学啊。</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>百度百科上的解释</p><blockquote><p>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。<br><a id="more"></a></p></blockquote><p>TCP/IP协议族就采用了分层的思想，自上而下分成了四层： 应用层，传输层，网络层，链路层，每一层的协议只约定了特定的功能，HTTP就位于应用层。利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。一次HTTP请求的典型过程如下图所示</p><p><img src="/images/HTTP01.jpg" alt=""></p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><blockquote><p>URI是Uniform Resource Identifier的缩写，是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。</p></blockquote><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://</span><br><span class="line">ftp://</span><br></pre></td></tr></table></figure></p><p>我们比较熟悉的URL（<code>Uniform Resource Locator</code>，统一资源定位符）表示资源在互联网上的地址，它其实是URI的一个子集，因为URI仅仅表示「标识」， 标识的类型有很多，比如ISBN号码，电话号码，邮箱，网页链接地址等，而URL则把概念缩小到了「地址」。 由于URI在绝大多数场景下都是以URL的形式存在，大家一般都说URL居多，这也没什么问题，但是在心里要清楚URI和URL还是有所区别的。</p><h2 id="HTTP协议内容"><a href="#HTTP协议内容" class="headerlink" title="HTTP协议内容"></a>HTTP协议内容</h2><p>接下来的内容基于HTTP 1.1版本。</p><h3 id="请求-amp-响应报文结构"><a href="#请求-amp-响应报文结构" class="headerlink" title="请求 &amp; 响应报文结构"></a>请求 &amp; 响应报文结构</h3><blockquote><p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出， 最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p></blockquote><p><img src="/images/HTTP02.jpg" alt=""></p><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 如下是一个HTTP请求和响应报文的实例</p><p><img src="/images/HTTP03.jpg" alt=""></p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><blockquote><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 数字中的第一位指定了响应类别，后两位无分类。</p></blockquote><p>状态码主要类型一览：</p><p><img src="/images/HTTP04.jpg" alt=""></p><h3 id="首部-amp-实体"><a href="#首部-amp-实体" class="headerlink" title="首部 &amp; 实体"></a>首部 &amp; 实体</h3><blockquote><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p></blockquote><p>HTTP首部字段由首部字段名和字段值构成的，中间用冒号“:”分隔。比如：<code>Content-Type: text/html</code>。 HTTP实体是HTTP请求和响应传输的主体内容，根据场景不同可能是表单参数，HTML文本，JSON文本，二进制流等。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。</p></blockquote><blockquote><p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p></blockquote><p><img src="/images/HTTP05.png" alt=""></p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>GET和POST最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</p><p>W3school的解答</p><table><thead><tr><th>方法</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><p>这个对比只是给出了一些现象上的区别</p><hr><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 </p><p>如果你用GET服务，在request body中存了数据，不同服务器的处理方式是不同的，有些服务器会读出数据，有些服务器直接忽略。所以，虽然GET可以带request body，但不能保证一定能被接受到。</p><h2 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h2><blockquote><p>征求意见稿（英语：Request For Comments，缩写为RFC），是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件，以编号排定。目前RFC文件是由互联网协会（ISOC）赞助发行。</p></blockquote><p>简单理解RFC就是互联网的规范，我们通常所说的「协议」就是以RFC的形式存在，而现行的HTTP/1.1规范的RFC有如下几个： RFC7230， RFC7231， RFC7232， RFC7233， RFC7234， RFC7235。 其中RFC7231里的Section 4. Request Methods涉及到了几个HTTP方法，接下来仔细阅读这一章节。</p><blockquote><p>The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.</p></blockquote><p>semantic[语义]，语法与语义的区别：</p><blockquote><p>一种语言是合法句子的集合。什么样的句子是合法的呢？可以从两方面来判断：语法和语义。语法是和文法结构有关，然而语义是和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。</p></blockquote><p>对于HTTP请求来说，语法是指请求响应的格式，比如请求第一行必须是 方法名 URI 协议/版本 这样的格式。</p><p>语义则定义了这一类型的请求具有什么样的性质。比如GET的语义就是「获取资源」，POST的语义是「处理资源」，那么在具体实现这两个方法时，就必须考虑其语义，做出符合其语义的行为。</p><p>当然在符合语法的前提下实现违背语义的行为也是可以做到的，比如使用GET方法修改用户信息，POST获取资源列表，这样就只能说这个请求是「合法」的，但不是「符合语义」的。 </p><p>RFC7231里紧接着定义了HTTP方法的几个特性：</p><blockquote><p>Safe - 安全<br>这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此RFC定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。<br>但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用GET修改用户信息的情况。<br>引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。</p><p>Idempotent - 幂等<br>幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。<br>引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。</p><p>Cacheable - 可缓存性<br>顾名思义就是一个方法是否可以被缓存，此RFC里GET，HEAD和某些情况下的POST都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持GET和HEAD。</p></blockquote><p>在这三个特性里一直在强调同一个事情，那就是协议不等于实现：协议规定安全在实现里不一定安全，协议规定幂等在实现里不一定幂等，协议规定可缓存在实现里不一定可缓存。</p><h3 id="语义之争"><a href="#语义之争" class="headerlink" title="语义之争"></a>语义之争</h3><p>GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-Control Header的约束）,GET方法的报文主体没有任何语义。</p><p>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://baike.baidu.com/item/TCP%2FIP协议/212915?fr=aladdin&amp;fromid=214077&amp;fromtitle=tcp%2Fip" target="_blank" rel="noopener">TCP/IP协议 百度百科</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别 </a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/01/26/图解HTTP-读书笔记/" target="_blank" rel="noopener">图解HTTP-读书笔记</a></p><p><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？&lt;/p&gt;
&lt;p&gt;还能怎么办，学啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;百度百科上的解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://hsb786.github.io/2018/04/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/16/单例模式/</id>
    <published>2018-04-16T05:35:59.000Z</published>
    <updated>2018-04-16T10:24:50.310Z</updated>
    
    <content type="html"><![CDATA[<p>定义：单例对象的类必须保证只有一个实例存在<br>场景：希望在整个系统中只能出现某个类的一个实例</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>懒汉式：指全局的单例实例在第一次被使用时构建</li><li>饿汉式：指全局的单例实例在类装载时构建</li></ul><p>日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。<br><a id="more"></a></p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Single &#123;</span><br><span class="line">    private static volatile Single instance;</span><br><span class="line">    private Single() &#123;&#125;</span><br><span class="line">    public static Single getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Single.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instance = new Single()；这个语句在JVM中，实际执行的原子语句包括：</p><ol><li>给Single分配内存</li><li>调用Single的构造函数完成初始化，返回类实例</li><li>将instance指向之前分配的完成初始化的内存</li></ol><p>编译器在不改变单线程程序语义的前提下，可以对指令重排序。1-2-3可能会变成1-3-2</p><p>导致的结果可能就是，线程B执行到1- 3 , 已经将instance引用指向了分配的内存，但是并没有执行初始化操作，所以这个时候instance并不等于null，但是没有被初始化。然后，线程B让出CPU，线程A开始执行，判断if(instance==null)，由于instance不等于null，于是线程A就直接返回这个instance，但是这个对象是线程B没有初始化的对象。</p><p>so，加上volatile修饰后，就可以禁止指令重排，遵循happens-before原则。保证B线程对instance的修改happens-before于A线程对instance的读。</p><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">         return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前一种方法只要Single类被加载了，那么instance就会被实例化。而这种方式是Singleton类被加载了，instance不一定被实例化。因为SingletonHoler类没有被主动使用，只在外部类的Singleton的getInstance()中被调用时才加载，从而实例化Instance，这样就可以启动延迟加载。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/15/单例模式/" target="_blank" rel="noopener">单例模式</a></p><p><a href="http://www.hollischuang.com/archives/1373" target="_blank" rel="noopener">设计模式（二）——单例模式</a></p><p><a href="http://www.hollischuang.com/archives/205" target="_blank" rel="noopener">[转+注]单例模式的七种写法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：单例对象的类必须保证只有一个实例存在&lt;br&gt;场景：希望在整个系统中只能出现某个类的一个实例&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;懒汉式：指全局的单例实例在第一次被使用时构建&lt;/li&gt;
&lt;li&gt;饿汉式：指全局的单例实例在类装载时构建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Integer</title>
    <link href="https://hsb786.github.io/2018/04/16/Integer/"/>
    <id>https://hsb786.github.io/2018/04/16/Integer/</id>
    <published>2018-04-16T05:09:49.000Z</published>
    <updated>2018-04-16T05:24:55.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>public final class Integer extends Number implements Comparable&lt;Integer&gt;</code></pre><ol><li>Integer不能被继承</li><li>Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较</li><li>Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值</li></ol><a id="more"></a><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code>private final int value;</code></pre><p>value属性就是Integer对象中保存的int值</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i=new Integer(1);</span><br><span class="line">i=2;</span><br></pre></td></tr></table></figure><p>反编译之后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(1);</span><br><span class="line">i = Integer.valueOf(2);</span><br></pre></td></tr></table></figure><p>编译器会把<code>i=2</code>转换成<code>i=Integer.valueOf(2)</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，IntegerCache.low=-128，IntegerCache.high=127（除非显示声明java.lang.Integer.IntegerCache.high的值），Integer中有一段静态代码块，该部分内容会在Integer类被加载的时候就执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line">    * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line">    *</span><br><span class="line">    * The cache is initialized on first usage.  The size of the cache</span><br><span class="line">    * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="line">    * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line">    * may be set and saved in the private system properties in the</span><br><span class="line">    * sun.misc.VM class.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，当Integer被加载时，就新建了-128到127的所有数字并存放在Integer数组cache中。</p><p>再回到valueOf代码，可以得出结论。当调用valueOf方法时，如果参数的值在-127到128之间，则直接从缓存中返回一个已经存在的对象。如果参数的值不在这个范围内，则new一个Integer对象返回。</p><p>所以，当把一个int变量转成Integer的时候（或者新建一个Integer的时候），建议使用valueOf方法来代替构造函数。或者直接使用Integer i = 100;编译器会转成Integer s = Integer.valueOf(100);</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1058" target="_blank" rel="noopener">Java 源码学习系列（三）——Integer</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定义&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public final class Integer extends Number implements Comparable&amp;lt;Integer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;Integer不能被继承&lt;/li&gt;
&lt;li&gt;Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较&lt;/li&gt;
&lt;li&gt;Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="https://hsb786.github.io/2018/04/16/String/"/>
    <id>https://hsb786.github.io/2018/04/16/String/</id>
    <published>2018-04-16T04:35:57.000Z</published>
    <updated>2018-04-16T05:10:19.587Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过<code>StringBuilder</code>的<code>append()</code>方法来实现的，字符串的转换通过<code>toString</code>方法实现。<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence{}</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code>private final char value[];</code></pre><p>这是一个字符数组，并且是final类型，它用于存储字符串内容，从final这个关键字中我们可以看出，String的内容一旦被初始化了是不能被改变的。</p><pre><code>private int hash;</code></pre><p>缓存字符串的hashCode，默认值为0</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="1-使用字符数组、字符串构造一个String"><a href="#1-使用字符数组、字符串构造一个String" class="headerlink" title="1. 使用字符数组、字符串构造一个String"></a>1. 使用字符数组、字符串构造一个String</h3><p>但我们使用字符数组创建String的时候，会用到<code>Arrays.copyOf</code>方法和<code>Arrays.copyOfRange</code>方法。这两个方法是将原有的字符数组中的内容逐一复制到String中的字符数组中。同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将<code>源String</code>中的<code>value</code>和<code>hash</code>两个属性直接赋值给<code>目标String</code>。因为String是不可变的，所以不用担心改变<code>源String</code>的值会影响到<code>目标String</code>的值</p><h3 id="2-使用字节数组构造一个String"><a href="#2-使用字节数组构造一个String" class="headerlink" title="2.使用字节数组构造一个String"></a>2.使用字节数组构造一个String</h3><p>在Java中，String实例中保存有一个<code>char[]</code>字符数组，<code>char[]</code>字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。<code>String(byte[] bytes, Charset charset)</code>是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，构造成新的String。</p><h3 id="3-使用StringBuffer和StringBuider构造一个String"><a href="#3-使用StringBuffer和StringBuider构造一个String" class="headerlink" title="3.使用StringBuffer和StringBuider构造一个String"></a>3.使用StringBuffer和StringBuider构造一个String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String(StringBuffer buffer) &#123;</span><br><span class="line">    synchronized(buffer) &#123;</span><br><span class="line">        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String(StringBuilder builder) &#123;</span><br><span class="line">    this.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很少用到，当我们有了StringBuffer或者StringBuilfer对象之后可以直接使用他们的toString方法来得到String。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    // Create a copy, don&apos;t share the array</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br></pre></td></tr></table></figure><h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><p>java7以后，常量池被放入到堆空间中。导致intern()函数的功能不同。intern()检查常量池是否存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/99" target="_blank" rel="noopener">Java 7 源码学习系列（一）——String</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过&lt;code&gt;StringBuilder&lt;/code&gt;的&lt;code&gt;append()&lt;/code&gt;方法来实现的，字符串的转换通过&lt;code&gt;toString&lt;/code&gt;方法实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>enum</title>
    <link href="https://hsb786.github.io/2018/04/16/enum/"/>
    <id>https://hsb786.github.io/2018/04/16/enum/</id>
    <published>2018-04-16T03:47:49.000Z</published>
    <updated>2018-04-16T04:32:59.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类</p></blockquote><a id="more"></a><pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable</code></pre><p><img src="/images/enum01.png" alt=""></p><p><strong>Enum类无法被继承</strong></p><p>定义一个Color枚举</p><pre><code>enum Color {RED, GREEN, YELLOW}</code></pre><p>反编译后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class EnumTest.Color extends java.lang.Enum&lt;EnumTest.Color&gt; &#123;</span><br><span class="line">  public static final EnumTest.Color RED;</span><br><span class="line">  public static final EnumTest.Color GREEN;</span><br><span class="line">  public static final EnumTest.Color YELLOW;</span><br><span class="line">  private static final EnumTest.Color[] ENUM$VALUES;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  private EnumTest.Color(java.lang.String, int);</span><br><span class="line">  public static EnumTest.Color[] values();</span><br><span class="line">  public static EnumTest.Color valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从反编译之后的代码中，我们发现，编译器不让我们继承Enum，但是当我们使用enum关键字定义一个枚举的时候，他会帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。</p><hr><p>Enum实现了Serializable和Comparable接口，进行比较时只有同类型的enum才能进行比较，要想实现不同类型的enum之间的比较，只能重写compareTo方法</p><p><strong>Enum&lt;E extends Enum&lt;E>></strong></p><p>一个Enum只接受一个Enum或者他的子类作为参数</p><p><strong>compartTo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int compareTo(E o) &#123;</span><br><span class="line">        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">        Enum&lt;E&gt; self = this;</span><br><span class="line">        if (self.getClass() != other.getClass() &amp;&amp; // optimization</span><br><span class="line">            self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">            throw new ClassCastException();</span><br><span class="line">        return self.ordinal - other.ordinal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Java使用Enum&lt;E extends Enum<e>&gt;声明Enum，并且在compareTo的中使用E作为参数。这两个条件限制Color.RED只能和Color定义出来的枚举进行比较</e></p><p><strong>成员变量</strong><br>在Enum中，有两个成员变量，一个是名字(name)，一个是序号(ordinal)。序号是一个枚举常量，表示在枚举中的位置，从0开始，依次递增。</p><p><strong>构造函数</strong><br>Enum是一个抽象类，不能被实例化，但是他也有构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Enum(String name，int ordinal)&#123;</span><br><span class="line">      this.name=name;</span><br><span class="line">      this.ordinal=ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/92" target="_blank" rel="noopener">Java 7 源码学习系列（二）——Enum</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>javap</title>
    <link href="https://hsb786.github.io/2018/04/15/javap/"/>
    <id>https://hsb786.github.io/2018/04/15/javap/</id>
    <published>2018-04-15T11:11:13.000Z</published>
    <updated>2018-04-15T11:48:20.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line">private volatile int n;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sub() &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap T01 输出T01的public域及方法</p><p><img src="/images/javap01.png" alt=""></p><p>javap -c T01 列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用</p><p><img src="/images/javap02.png" alt=""></p><p>javap -p T01 输出所有类和成员</p><p><img src="/images/javap03.png" alt=""></p><p>javap -v T01 输出栈大小，方法参数的个数</p><p><img src="/images/javap04.png" alt=""></p><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-help 帮助</span><br><span class="line">-l 输出行和变量的表</span><br><span class="line">-public 只输出public方法和域</span><br><span class="line">-protected 只输出public和protected类和成员</span><br><span class="line">-package 只输出包，public和protected类和成员，这是默认的</span><br><span class="line">-p -private 输出所有类和成员</span><br><span class="line">-s 输出内部类型签名</span><br><span class="line">-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，</span><br><span class="line">-verbose 输出栈大小，方法参数的个数</span><br><span class="line">-constants 输出静态final常量</span><br></pre></td></tr></table></figure><h3 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h3><table><thead><tr><th>major version</th><th>java版本</th></tr></thead><tbody><tr><td>46</td><td>2</td></tr><tr><td>47</td><td>3</td></tr><tr><td>48</td><td>4</td></tr><tr><td>49</td><td>5</td></tr><tr><td>50</td><td>6</td></tr><tr><td>51</td><td>7</td></tr><tr><td>52</td><td>8</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://hsb786.github.io/2018/04/14/Proxy/"/>
    <id>https://hsb786.github.io/2018/04/14/Proxy/</id>
    <published>2018-04-14T08:14:06.000Z</published>
    <updated>2018-04-14T11:25:27.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>通过<code>java.lang.reflect.Proxy</code>类以及<code>java.lang.reflect.InvocationHandler</code>接口来实现动态代理</p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p>InvocationHandler接口的唯一方法：</p><p><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code></p><ul><li>proxy:    代理类实例</li><li>method:   方法</li><li>args:     方法入参</li></ul><a id="more"></a><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>public static Object newProxyInstance Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p><ul><li>loader： ClassLoader，定义由哪个ClassLoader对象类对生成的代理对象进行加载</li><li>interfaces：该实现类的所有接口</li><li>h：调用处理程序，表示当这个动态代理对象在调用方法时，会关联到哪一个InvocationHandler对象上</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hello &#123;</span><br><span class="line">void say(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义被代理的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl implements Hello &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void say(String name) &#123;</span><br><span class="line">System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。</span><br><span class="line"> * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。</span><br><span class="line"> * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    //目标对象，被代理接口的实现类</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public DynamicProxy(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * @param proxy 代理类实例</span><br><span class="line"> * @param method 方法</span><br><span class="line"> * @param args 方法入参</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description: 获取代理对象</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy() &#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClientProxy &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new HelloImpl();</span><br><span class="line">DynamicProxy dynamicProxy = new DynamicProxy(hello);</span><br><span class="line">Hello helloProxy = dynamicProxy.getProxy();</span><br><span class="line">helloProxy.say(&quot;hh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">        Before</span><br><span class="line">        Hello hh</span><br><span class="line">        After</span><br></pre></td></tr></table></figure></p><p>用DynamicProxy类去包装HelloImpl实例，然后再调用Proxy类的工厂方法newProxyInstance()去动态地创建一个Hello接口的代理类，调用这个代理类的say()方法。</p><p>被代理方法的调用都是通过InvocationHadler的invoke来实现的。</p><p>Proxy.newProxyInstance这个方法的第二个参数，我们给这个代理对象提供了一组什么接口，那么这个代理对象就会实现了这组接口，这个时候我们可以将这个代理对象强制转化为这组接口中的任意一个。</p><p>Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p><p>动态代理，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，代理类也要变。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有用武之地了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；在实现的过程中，通过传入目标对象（被代理的对象）来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。</li><li>通过Proxy.newProxyInstance来动态创建代理类</li><li>通过代理对象调用目标方法，实际上是通过InvocationHandler实现类的invoke()方法调用</li></ol><p>能否代理没有接口的类?</p><p>CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。</p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CGLibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123;</span><br><span class="line">return (T) Enhancer.create(cls, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。</p><p>与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGLibProxy cgLibProxy = new CGLibProxy();</span><br><span class="line">HelloImpl helloProxy2 = cgLibProxy.getProxy(HelloImpl.class);</span><br><span class="line">helloProxy2.say(&quot;cg&quot;);</span><br></pre></td></tr></table></figure><p>与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象</p><h2 id="JDK动态代理和CGLIB代理生成的区别"><a href="#JDK动态代理和CGLIB代理生成的区别" class="headerlink" title="JDK动态代理和CGLIB代理生成的区别"></a>JDK动态代理和CGLIB代理生成的区别</h2><ol><li>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</li><li>CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</li><li>JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。</li></ol><p>在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159788" target="_blank" rel="noopener">Proxy 那点事儿 </a></p><p><a href="https://lujunqiu.github.io/2017/12/07/动态代理/" target="_blank" rel="noopener">动态代理</a></p><p><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java的动态代理机制详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt;类以及&lt;code&gt;java.lang.reflect.InvocationHandler&lt;/code&gt;接口来实现动态代理&lt;/p&gt;
&lt;h2 id=&quot;InvocationHandler&quot;&gt;&lt;a href=&quot;#InvocationHandler&quot; class=&quot;headerlink&quot; title=&quot;InvocationHandler&quot;&gt;&lt;/a&gt;InvocationHandler&lt;/h2&gt;&lt;p&gt;InvocationHandler接口的唯一方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy:    代理类实例&lt;/li&gt;
&lt;li&gt;method:   方法&lt;/li&gt;
&lt;li&gt;args:     方法入参&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://hsb786.github.io/2018/04/14/ThreadLocal/"/>
    <id>https://hsb786.github.io/2018/04/14/ThreadLocal/</id>
    <published>2018-04-14T07:06:57.000Z</published>
    <updated>2018-04-14T07:55:17.544Z</updated>
    
    <content type="html"><![CDATA[<p>早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。</p><a id="more"></a><p>ThreadLocal常用方法：</p><ol><li>public void set(T value)：将值放入线程局部变量中</li><li>public T get()：从线程局部变量中获取值</li><li>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</li><li>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </li></ol><p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。 </p><h2 id="ThreadLocal简单实现"><a href="#ThreadLocal简单实现" class="headerlink" title="ThreadLocal简单实现"></a>ThreadLocal简单实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, T&gt; container = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;());</span><br><span class="line"></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        container.put(Thread.currentThread(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        T value = container.get(thread);</span><br><span class="line">        if (value == null &amp;&amp; !container.containsKey(thread)) &#123;</span><br><span class="line">            value = initialValue();</span><br><span class="line">            container.put(thread, value);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        container.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected T initialValue() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-具体有哪些使用案例呢？"><a href="#ThreadLocal-具体有哪些使用案例呢？" class="headerlink" title="ThreadLocal 具体有哪些使用案例呢？"></a>ThreadLocal 具体有哪些使用案例呢？</h2><p>通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。(每个线程应该拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接)</p><p> 注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！ </p><hr><p> <em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159489" target="_blank" rel="noopener">ThreadLocal 那点事儿</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IOC-实现原理（转载）</title>
    <link href="https://hsb786.github.io/2018/04/14/IOC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/14/IOC-实现原理（转载）/</id>
    <published>2018-04-14T05:22:40.000Z</published>
    <updated>2018-04-14T07:54:10.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部</p></blockquote><p> IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。<br><a id="more"></a><br>从实例出发，先看看以下 Action 代码。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public class ProductAction extends BaseAction &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Request(&quot;GET:/product/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getProductById(long productId) &#123;</span><br><span class="line">        if (productId == 0) &#123;</span><br><span class="line">            return new Result(ERROR_PARAM);</span><br><span class="line">        &#125;</span><br><span class="line">        Product product = productService.getProduct(productId);</span><br><span class="line">        if (product != null) &#123;</span><br><span class="line">            return new Result(OK, product);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Result(ERROR_DATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上使用了两个自定义注解：@Bean 与 @Inject。<br>在 ProductAction 类上标注了 @Bean 注解，表示该类会交给“容器”处理，以便加入依赖注入框架。</p><p>在 produceService 字段上标注了 @Inject 注解，表示该字段将会被注入进来，而无需 new ProductServiceImpl()，实际上 new 这件事情不是我们做的，而是框架做的，也就是说控制权正好反过来了，所以“依赖注入（DI）”也称作“控制反转（IoC）”。</p><p>那么，应该如何实现依赖注入框架呢？首先还是看看下面的 BeanHelper 类吧。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 遍历 Bean Map</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 获取该接口所有的实现类</span><br><span class="line">                            List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                            if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                // 获取第一个实现类</span><br><span class="line">                                Class&lt;?&gt; implementClass = implementClassList.get(0);</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                beanField.setAccessible(true); // 必须使该字段可访问</span><br><span class="line">                                beanField.set(beanInstance, implementInstance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，依赖注入其实分为两个步骤：1. 通过反射创建实例；2. 获取需要注入的接口实现类并将其赋值给该接口。以上代码中的两个 for 循环就是干这两件事情的。  </p><p>依赖注入框架实现完毕！ </p><p>大家上面看到的 BeanHelper 类，其实兼任了两种职责：1.初始化所有的 Bean 类；2.实现依赖注入。</p><p>这违法了设计模式中的“单一责任原则”，所有有必要将其重构一下，现在的 BeanHelper 类更加苗条了，只是负责初始化 Bean 类而已。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line"></span><br><span class="line">    // Bean 类 =&gt; Bean 实例</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，依赖注入功能放哪里呢？我搞了一个 IOCHelper，用这个类来实现 IOC 功能。代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class IOCHelper &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean 类</span><br><span class="line">            Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 判断接口上是否标注了 @Impl 注解</span><br><span class="line">                            Class&lt;?&gt; implementClass = null;</span><br><span class="line">                            if (interfaceClass.isAnnotationPresent(Impl.class)) &#123;</span><br><span class="line">                                // 获取强制指定的实现类</span><br><span class="line">                                implementClass = interfaceClass.getAnnotation(Impl.class).value();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                // 获取该接口所有的实现类</span><br><span class="line">                                List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                                if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                    // 获取第一个实现类</span><br><span class="line">                                    implementClass = implementClassList.get(0);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 若存在实现类，则执行以下代码</span><br><span class="line">                            if (implementClass != null) &#123;</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                if (implementInstance != null) &#123;</span><br><span class="line">                                    beanField.setAccessible(true); // 取消类型安全检测（可提高反射性能）</span><br><span class="line">                                    beanField.set(beanInstance, implementInstance); // beanInstance 是普通实例，或 CGLib 动态代理实例（不能使 JDK 动态代理实例）</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见，IOCHelper 是依赖于 BeanHelper 的。这样分离，还有一个好处，就是方便实现 ServiceHelper 与 AOPHelper。也就是说，首先通过 BeanHelper 初始化所有的 Bean 类，然后依次初始化 ServiceHelper、IOCHelper、AOPHelper，这个顺序不能搞错。因为在 ServcieHelper 中，对 Servcie 实现类进行了动态代理，所有保证了 IOC 注入进来的是代理类，而并非目标类。 </p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/158992" target="_blank" rel="noopener">IOC 实现原理 </a></p><p><a href="https://my.oschina.net/flashsword/blog/192551" target="_blank" rel="noopener">1000行代码读懂Spring（一）- 实现一个基本的IoC容器 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://hsb786.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Servlet（转载）</title>
    <link href="https://hsb786.github.io/2018/04/14/Servlet%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/14/Servlet（转载）/</id>
    <published>2018-04-14T04:35:27.000Z</published>
    <updated>2018-04-14T05:14:16.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet概述"><a href="#Servlet概述" class="headerlink" title="Servlet概述"></a>Servlet概述</h2><p>Servlet是在Java中创建web应用程序的J2ee 服务端技术。<code>javax.servlet</code> 和 <code>javax.servlet.http</code>包中提供了编写servlet的接口和类。</p><p>所有的servlet都要实现<code>javax.servlet.Servlet</code>接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的<code>GenericServlet</code>类。<code>HttpServlet</code>类中提供了用于处理http请求的<code>doGet()</code>和 <code>doPost()</code>等方法。<br><a id="more"></a><br>多数情况下，web应用程序都使用http协议，所以，我们多数时候都通过继承<code>HttpServlet</code>类来实现自己的Servlet。</p><h2 id="Servlet-API的层次结构"><a href="#Servlet-API的层次结构" class="headerlink" title="Servlet API的层次结构"></a>Servlet API的层次结构</h2><p><code>javax.servlet.Servlet</code>是Servlet Api的最上层接口。还有一些其他的接口和类是我们在使用servlet的时候需要关注的。在Servlet 3.0规范中，建议使用的注解我们也需要了解。</p><p><img src="/images/Servlet-Hierarchy.png" alt="servlet API层次结构"></p><h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>javax.servlet.Servlet<code></code> 是Servlet Api的最上层接口，Servlet接口定义了一系列servlet的生命周期方法（init、service、destory等）。所有的Servlet类都需要继承这个接口。该接口中定义了以下方法：</p><p><code>public abstract void init(ServletConfig paramServletConfig) throws ServletException</code> – 该方法由servlet容器调用，用于初始化servlet以及servlet配置参数。在init()方法执行之前，servlet是无法处理用户请求的。在servlet生命周期中该方法只会被调用一次，他会使servlet类不同区别于普通的java对象。我们可以扩展该方法来初始化资源，如数据库连接、socket连接等。</p><p><code>public abstract ServletConfig getServletConfig()</code> – 该方法返回一个servlet配置对象，其中包含servlet中所有初始化参数和启动配置。我们可以用这个方法来获取servlet的初始化参数，这些参数一般被定义在web.xml或servlet 3的注解中。后面会介绍ServletConfig接口。</p><p><code>public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</code> – 该方法负责处理客户端请求。当servlet容器收到客户端请求时，它会创建一个新线程并执行service()方法，并把request 和 response作为参数传递给该方法。servlet通常运行在多线程环境中，所以开发人员应该使用同步来保证访问共享资源的线程安全性问题。</p><p><code>public abstract String getServletInfo()</code> – 这个方法返回包含servlet信息的字符串，比如它的作者、版本和版权。返回的字符串应该是纯文本，不能有标记符号。</p><p><code>public abstract void destroy()</code> – 这个方法在整个servlet生命周期中只会被调用一次来关闭所有资源。有点像Java中的finalize方法。</p><h2 id="ServletConfig-接口"><a href="#ServletConfig-接口" class="headerlink" title="ServletConfig 接口"></a>ServletConfig 接口</h2><p><code>javax.servlet.ServletConfig</code>用于给servlet传递配置信息（译者注：描述Servlet本身的相关配置信息）。每个servlet都有属于它自己的ServletConfig对象，该对象由servlet容器负责实例化。可以在web.xml中提供初始化参数，当然在servlet3.0中可以使用注解。我们可以使用<code>getServletConfig()</code>方法来获取ServletConfig的对象。</p><p>ServletConfig接口中主要方法：</p><p><code>public abstract ServletContext getServletContext()</code> – 该方法返回servlet的ServletContext对象。在下一节中我们将介绍ServletContext接口。</p><p><code>public abstract Enumeration getInitParameterNames()</code> – 该方法返回servlet中所有初始化参数的名字的枚举。如果没有初始化参数定义，该方法将返回空枚举。</p><p><code>public abstract String getInitParameter(String paramString)</code> – 这种方法可以通过名字来获取特定的初始化参数值。如果参数的名称不存在，则返回null。</p><h2 id="ServletContext-接口"><a href="#ServletContext-接口" class="headerlink" title="ServletContext 接口"></a>ServletContext 接口</h2><p><code>javax.servlet.ServletContext</code>接口用于描述应用程序的相关信息。ServletContext是一个独立的对象，可用于web应用程序中所有的servlet。当我们想要一些初始化的参数可用于web应用程序中多个或全部servlet时，我们可以使用ServletContext对象并且在web.xml中使用&lt; context-param&gt;标签定义参数。我们可以通过ServletConfig 中的 <code>getServletContext()</code>方法得到ServletContext对象。</p><p>ServletContext接口中的主要方法：</p><p><code>public abstract ServletContext getContext(String uripath)</code> – 这个方法返回指定的uripath的ServletContext对象，如果uripath不可用或不可见则返回null。</p><p><code>public abstract URL getResource(String path) throws MalformedURLException</code> – 返回的一个代表某个资源的URL对象。资源可以是本地文件系统、远程文件系统、数据库，甚至是不知道如何获取资源的具体细节的远程网络站点。</p><p><code>public abstract InputStream getResourceAsStream(String path)</code> – 这个方法返回给定的资源路径的一个输入流对象。如果没有找到返回null。</p><p><code>public abstract RequestDispatcher getRequestDispatcher(String urlpath)</code> – 这个方法一般被用于获得对于另外一个servlet的引用。获取到RequestDispatcher对象之后，就可以通过他把一个请求转发出去(forward或者include)。</p><p><code>public abstract void log(String msg)</code> – 该方法用于把指定的消息字符串写入servlet日志文件中。</p><p><code>public abstract Object getAttribute(String name)</code> – 按照指定的name返回对象属性。可以使用<code>public abstract Enumeration getAttributeNames()</code>活的所有对象属性的枚举。</p><p><code>public abstract void setAttribute(String paramString, Object paramObject)</code> – 该方法用于在应用的范围内设置属性。该属性可以被可以访问当前ServletContext的所有servle获取到。可以使用<code>public abstract void removeAttribute(String paramString)</code>删除一个属性。</p><p><code>String getInitParameter(String name)</code> – 该方法用于返回在web.xml中定义的初始化参数的值。如果指定的name在web.xml中并没有匹配到，则返回null。可以使用<code>Enumeration getInitParameterNames()</code>得到所有初始化参数的名称的枚举。</p><p>boolean setInitParameter(String paramString1, String paramString2)<code></code> – 可以使用该方法设置应用中的初始化参数。</p><h2 id="ServletRequest-接口"><a href="#ServletRequest-接口" class="headerlink" title="ServletRequest 接口"></a>ServletRequest 接口</h2><p>ServletRequest接口是用来向servlet提供客户端请求信息。每一个客户端请求到达Servlet容器的时候，他都会创建一个ServletRequest对象，并将其传递对应的servlet的service()方法。</p><p>ServletRequest接口中的主要方法：</p><p><code>Object getAttribute(String name)</code> – 返回指定的参数名对应的属性值。如果对应的参数不存在则返回null。我们可以使用<code>getAttributeNames()</code>方法来获取请求中的所有属性名称的枚举。接口中同样提供了设置值和删除值的方法。</p><p><code>String getParameter(String name)</code> – 以字符串的形式返回请求参数值。我们可以使用getParameterNames()方法来获取请求参数名称的枚举。</p><p><code>String getServerName()</code> – 返回服务器的主机名</p><p><code>int getServerPort()</code> – 返回服务器监听的端口号。</p><p>ServletRequest的子接口HttpServletRequest中还包含了一些和session、cookies等相关的方法。</p><blockquote><p>译者注：该接口中提供了getAttribute和getParameter两个方法，都是用于获取参数（属性）值的，那么这两个方法有什么区别呢？或者说Attribute和Parameter的区别是什么呢？</p><p>答：</p><p>来源不同</p><blockquote><p>   参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的；</p><p>   属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的.</p></blockquote><p>操作不同</p><blockquote><p>   参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取；</p><p>   属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute()</p></blockquote><p>数据类型不同</p><blockquote><p>   参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。</p><p>   属性（attribute）的值可以是任意一个Object类型。</p></blockquote></blockquote><h2 id="ServletResponse-接口"><a href="#ServletResponse-接口" class="headerlink" title="ServletResponse 接口"></a>ServletResponse 接口</h2><p>servlet使用ServletResponse向客户端发送响应。和每ServletRequest类似，一个客户端请求到达Servlet容器的时候，他都会创建一个ServletResponse对象，并将其传递对应的servlet的service()方法。最终，该response对象用于给客户端生成html响应。</p><p>ServletResponse接口中的主要方法：</p><p><code>void addCookie(Cookie cookie)</code> – 向响应中添加cookie</p><p><code>void addHeader(String name, String value)</code>– 设置响应头</p><p><code>String encodeURL(java.lang.String url)</code> – 通过重写Url的方式支持session，在Url中增加sessionId，如果不需要重写，直接返回该url</p><p><code>String getHeader(String name)</code> – 返回指定的头信息。</p><p><code>void sendRedirect(String location)</code>–重定向到指定的地址</p><p><code>void setStatus(int sc)</code> – 设置响应的状态码</p><h2 id="RequestDispatcher-接口"><a href="#RequestDispatcher-接口" class="headerlink" title="RequestDispatcher 接口"></a>RequestDispatcher 接口</h2><p>RequestDispatcher 接口用于把一个请求转发给同一个servlet上下文中的其他的资源（Html、jsp、servlet）来处理。也可以用它来把另一个资源的内容包含到响应中。此接口用于同一个servlet上下文中的servlet相互沟通。</p><p>RequestDispatcher 接口的主要方法： <code>void forward(ServletRequest request, ServletResponse response)</code> – 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。</p><p><code>void include(ServletRequest request, ServletResponse response)</code> – 把另一个资源的内容包含到当前响应中。</p><blockquote><p>译者注：forward和include的区别：</p><p>如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。</p><p>用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。</p></blockquote><p>在servlet中可以使用<code>getRequestDispatcher(String path)</code>来获取一个RequestDispatcher。路径必须以/开头，并且是针对于当前context的根路径的相对地址。</p><h2 id="GenericServlet-类"><a href="#GenericServlet-类" class="headerlink" title="GenericServlet 类"></a>GenericServlet 类</h2><p>GenericServlet是一个实现类Servlet, ServletConfig 和 Serializable 的抽象类。他提供了Servlet生命周期中的主要方法以及ServletConfig中的方法的默认实现。当我们定义自己的servlet的时候，只要继承了该方法，我们只需要重写我们关注的方法就可以了，其他的不关注的方法都可以使用其默认实现。该类中定义的大部分方法都是让用户更放方便的使用Servlet和ServletConfig接口中定义的常用方法。</p><p>GenericServlet 类中有一个重要的方法——无参数的init方法。如果我们必须在处理请求之前初始化一些资源，那么可以重写该方法。</p><h2 id="HTTPServlet-类"><a href="#HTTPServlet-类" class="headerlink" title="HTTPServlet 类"></a>HTTPServlet 类</h2><p>HTTPServlet 类是GenericServlet类的子类，主要为基于HTTP创建的web应用程序提供了一些支持。其中定义了一些可重写HTTP方法。</p><p><code>doGet()</code>, 用于处理get请求 <code>doPost()</code>, 用于处理post请求 <code>doPut()</code>, 用于处理put请求 <code>doDelete()</code>, 用于处理delete请求</p><h2 id="Servlets属性（Attributes）"><a href="#Servlets属性（Attributes）" class="headerlink" title="Servlets属性（Attributes）"></a>Servlets属性（Attributes）</h2><p>Servlet属性用于servlet之间的沟通，可以在web应用程序中设置、获取甚至删除属性值。servlet属性有三种范围：request、session、application</p><p>ServletRequest， HttpSession 和 ServletContext接口为request、session和application范围提供了get/set/remove的方法。</p><h2 id="Servlet-3中的注解"><a href="#Servlet-3中的注解" class="headerlink" title="Servlet 3中的注解"></a>Servlet 3中的注解</h2><p>在servlet 3之前，所以的servlet映射和初始化参数都是定义在web.xml文件中的，随着应用中的servlet数量增多，这种方式就很难维护。</p><p>servlet 3中使用支持使用java注解来定义servlet、filter、listener以及初始化参数。</p><p>servlet 3 中主要的注解：</p><p><code>WebServlet</code> – 可以在servlet类中使用该注解来定义初始化参数、loadOnStartup的值、description信息和url匹配模式(pattern)等。该注解的属性中 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存。该注释声明的类必须继承HttpServlet。</p><p><code>WebInitParam</code> – 该注解用于给servlet 或者 filter定义初始化参数（包括name,value和description）。可以在 WebFilter 或者 WebServlet中使用该注解。</p><p><code>WebFilter</code> – 该注解用于声明一个servlet过滤器。使用该注解声明的类必须实现javax.servlet.Filter接口。</p><p><code>WebListener</code> – 该注解用于声明一个事件监听器。</p><hr><p><em>参考</em></p><p><a href="http://www.hollischuang.com/archives/1219" target="_blank" rel="noopener">[译]Java Servlet初级知识</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Servlet概述&quot;&gt;&lt;a href=&quot;#Servlet概述&quot; class=&quot;headerlink&quot; title=&quot;Servlet概述&quot;&gt;&lt;/a&gt;Servlet概述&lt;/h2&gt;&lt;p&gt;Servlet是在Java中创建web应用程序的J2ee 服务端技术。&lt;code&gt;javax.servlet&lt;/code&gt; 和 &lt;code&gt;javax.servlet.http&lt;/code&gt;包中提供了编写servlet的接口和类。&lt;/p&gt;
&lt;p&gt;所有的servlet都要实现&lt;code&gt;javax.servlet.Servlet&lt;/code&gt;接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的&lt;code&gt;GenericServlet&lt;/code&gt;类。&lt;code&gt;HttpServlet&lt;/code&gt;类中提供了用于处理http请求的&lt;code&gt;doGet()&lt;/code&gt;和 &lt;code&gt;doPost()&lt;/code&gt;等方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何重置一个ArrayList--clear vs removeAll （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%AF%91-%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE%E4%B8%80%E4%B8%AAArrayList-clear-vs-removeAll/"/>
    <id>https://hsb786.github.io/2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/</id>
    <published>2018-04-13T07:55:17.000Z</published>
    <updated>2018-04-13T08:01:13.361Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置<code>clear</code>或<code>removeAll</code>。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现<code>java.lang.OutOfMemoryError: Java Heap Space</code>。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。<br><a id="more"></a></p><h2 id="Clear-vs-RemoveAll-Collection-c"><a href="#Clear-vs-RemoveAll-Collection-c" class="headerlink" title="Clear() vs RemoveAll(Collection c)"></a>Clear() vs RemoveAll(Collection c)</h2><p>为了更好的比较这两个方法，阅读他们源码是很重要的。可以在<code>java.utils.ArrayList</code>类中找到clear()方法，不过为了方便我将它引入到了这里。下面的代码来自JDK 1.7.0_40版本。如果你想要学习更多的有关性能监控和调优的知识，我强烈建议阅读Scott Oaks写的Java Performance the Definitive Guide,它包含了java 7和一点java 8。下面是clear()的代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Removes all of the elements from this list.The list will </span><br><span class="line"> * be empty after this call returns. </span><br><span class="line"> */ </span><br><span class="line"> public void clear() &#123; </span><br><span class="line"> modCount++; // clear to let GC do its work </span><br><span class="line"> for (int i = 0; i &lt; size; i++) </span><br><span class="line"> elementData[i] = null; </span><br><span class="line"> size = 0; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>大家可以看出，clear()在循环遍历ArrayList，并且将每一个元素都置为null，使它们在没有被外部引用的情况下可以被垃圾回收。相似的，我们可以在<code>java.util.AbstractCollection</code>类中查看removeAll(Collention c)的代码，下面是代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">//判断对象是否为null</span><br><span class="line">      Objects.requireNonNull(c);</span><br><span class="line">      boolean modified = false;</span><br><span class="line">      Iterator&lt;?&gt; it = iterator();</span><br><span class="line">      while (it.hasNext()) &#123;</span><br><span class="line">          if (c.contains(it.next())) &#123;</span><br><span class="line">              it.remove();</span><br><span class="line">              modified = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return modified;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  这个方法会检查迭代器顺序返回的每个元素是否包含在特定的集合中。如果存在，调用迭代器的remove方法将它从集合中移除。因为会用到contains方法，removeAll的复杂度是O(n^2)。所以在想要重置一个大的ArrayList时，这种方法是绝对不可取的。下面我们比较一下两者在重置一个包含100K个元素时的性能差异。</p><h2 id="删除一个包含100k个元素的列表中的所有元素"><a href="#删除一个包含100k个元素的列表中的所有元素" class="headerlink" title="删除一个包含100k个元素的列表中的所有元素"></a>删除一个包含100k个元素的列表中的所有元素</h2><p>  我本来想在例子中尝试重置一个包含10M个元素的列表，不过在超过半个小时等待removeAll()结束后，我决定将元素的数量降为100K。在这种情况下，两个方法的差距也是很明显的。removeAll()比clear()多花费了10000倍的时间。事实上，在API中clear()和removeAll(Collection c)这两个方法的目的是不同的。clear()方法是为了通过删除所有元素而重置列表，而removeAll(Collection c)是为了从集合中删除某些存在于另一个提供的集合中的元素，并不是为了从集合中移除所有元素。所以如果你的目的是删除所有元素，用clear(),如果你的目的是删除某些存在于另一集合的元素，那么选择removeAll(Collection c)方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList; </span><br><span class="line">/**</span><br><span class="line"> * Java Program to remove all elements from list in Java and comparing </span><br><span class="line"> * performance of clearn() and removeAll() method. </span><br><span class="line"> * * @author Javin Paul </span><br><span class="line"> */ </span><br><span class="line"> public class ArrayListResetTest &#123; </span><br><span class="line"> </span><br><span class="line"> private static final int SIZE = 100_000; </span><br><span class="line"> public static void main(String args[]) &#123; </span><br><span class="line"> </span><br><span class="line"> // Two ArrayList for clear and removeAll </span><br><span class="line"> ArrayList numbers = new ArrayList(SIZE); </span><br><span class="line"> ArrayList integers = new ArrayList(SIZE); </span><br><span class="line"> // Initialize ArrayList with 10M integers </span><br><span class="line"> for (int i = 0; i &amp;lt; SIZE; i++) &#123; </span><br><span class="line"> numbers.add(new Integer(i)); </span><br><span class="line"> integers.add(new Integer(i)); </span><br><span class="line"> &#125; </span><br><span class="line"> // Empty ArrayList using clear method </span><br><span class="line"> long startTime = System.nanoTime(); </span><br><span class="line"> numbers.clear(); </span><br><span class="line"> long elapsed = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by clear to empty ArrayList of 1M elements (ns): &quot; + elapsed); </span><br><span class="line"> // Reset ArrayList using removeAll method </span><br><span class="line"> startTime = System.nanoTime(); </span><br><span class="line"> integers.removeAll(integers); </span><br><span class="line"> long time = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by removeAll to reset ArrayList of 1M elements (ns): &quot; + time); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> Output: </span><br><span class="line"> Time taken by clear to empty ArrayList of 100000 elements (ns): 889619 </span><br><span class="line"> Time taken by removeAll to reset ArrayList of 100000 elements (ns): 36633112126</span><br></pre></td></tr></table></figure><p>  由于程序使用了两个arrayList存储Integers，所以在运行时要确保有足够的内存，尤其是你想比较在列表存有1M个元素时，两种方法的性能差异。另外，由于使用了在数字中加入下划线的特性，所以需要java7来运行。如果没有JDK7，也可以移除SIZE常量中的下划线。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/10/26/译-如何重置一个ArrayList-clear-vs-removeAll/" target="_blank" rel="noopener"> 【译】如何重置一个ArrayList–clear vs removeAll </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置&lt;code&gt;clear&lt;/code&gt;或&lt;code&gt;removeAll&lt;/code&gt;。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现&lt;code&gt;java.lang.OutOfMemoryError: Java Heap Space&lt;/code&gt;。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>【译】以生产者消费者为例阐述如何使用wait，notify和notifyAll （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%AF%91-%E4%BB%A5%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BA%E4%BE%8B%E9%98%90%E8%BF%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wait%EF%BC%8Cnotify%E5%92%8CnotifyAll/"/>
    <id>https://hsb786.github.io/2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/</id>
    <published>2018-04-13T07:34:36.000Z</published>
    <updated>2018-04-13T07:49:23.236Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:<code>Producer</code>(生产者)和<code>Consumer</code>(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。<br><a id="more"></a></p><h2 id="在代码中展示如何使用wait和notify"><a href="#在代码中展示如何使用wait和notify" class="headerlink" title="在代码中展示如何使用wait和notify"></a>在代码中展示如何使用wait和notify</h2><p>尽管wait和notify是相当基础的概念，并且他们定义在<code>Object</code>类中，但要想在代码中使用他们并非易事。你可以在面试中让面试者通过手写代码解决Producer者和Consumer者问题来验证，我相信大多数人都会犯在错误的地方同步，没有在正确的对象上调用wait之类的错。讲真，这些常常会困惑许多程序员。第一个困惑点来自怎样调用wait方法，因为wait方法并不是定义在Thread类中，所以不能简单的Thread.wait()。而许多Java开发者习惯于Thread.sleep(),所以常常错误的想用同样的方式调用wait。实际上，wait()方法需要在一个被两个线程共享的对象上调用，例如在Producer者和消费Consumer的问题中，两个线程共享对象是一个队列。第二个困惑点来自wait方法应该在同步块还是同步方法中调用？如果使用同步块，那么哪个对象应该放到同步块中？这个对象和你想要获得锁的对象应该是同一个。在我们的例子中，这个对象就是两个线程共享的队列。</p><h2 id="在循环中使用wait和notify，而不是If代码块中"><a href="#在循环中使用wait和notify，而不是If代码块中" class="headerlink" title="在循环中使用wait和notify，而不是If代码块中"></a>在循环中使用wait和notify，而不是If代码块中</h2><p>在你已经了解需要在一个共享的对象上调用wait方法后，接下来就是学会避免许多java开发者犯的错—在If代码块中调用wait而不是while循环中。因为需要在一定的条件下调用wait，比如Producer线程要在队列满了的情况下调用wait，所以第一反应都是使用If语句。但是，在If代码块中调用wait会产生<code>bug</code>，因为线程存在一定的可能在等待条件没有改变的情况下<a href="https://hsb786.github.io/2018/04/09/术语/">假唤醒(spurious wake up)</a>。所以如果没有使用循环在线程唤醒后检查等待条件，可能会造成尝试在已经满了的队列中插入元素或者在空了的队列中取元素。这就是为什么我们要在while循环中调用wait而不是if。</p><h2 id="Java中使用wait-notify-notifyAll-的例子"><a href="#Java中使用wait-notify-notifyAll-的例子" class="headerlink" title="Java中使用wait(),notify(),notifyAll()的例子"></a>Java中使用wait(),notify(),notifyAll()的例子</h2><p>下面是在Java中使用wait(),notify(),notifyAll()的例子。在这个程序中，有两个线程(PRODUCTOR和CONSUMER)，用继承了Thread类的Producer和Consumer类实现。Prodcuer和Consumer的业务逻辑写在他们各自的run()方法中。并且实现一个LinkedList，当做共享队列。Producer在一个死循环中不断在队列中插入随机数，直到队列满了。我们会检查while(queue.size == maxSize),需要注意的是在检查之前需要给队列加上同步锁以保证在检查时没有另一个线程修改队列。如果队列满了，PRODUCER线程就会休眠，直到CONSUMER消费了队列中的元素并且调用notify()方法通知PRODUCER线程。<code>wait和notify都是在共享的对象(我们的例子中是队列)上调用的</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.Random;</span><br><span class="line">/**</span><br><span class="line"> * Simple Java program to demonstrate How to use wait, notify and notifyAll()</span><br><span class="line"> * method in Java by solving producer consumer problem.</span><br><span class="line"> *</span><br><span class="line"> * @author Javin Paul</span><br><span class="line"> */</span><br><span class="line">public class MultipleThread &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        System.out.println(&quot;How to use wait and notify method in Java&quot;);</span><br><span class="line">        System.out.println(&quot;Solving Producer Consumper Problem&quot;);</span><br><span class="line">        Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class="line">        int maxSize = 10;</span><br><span class="line">        Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);</span><br><span class="line">        Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Producer Thread will keep producing values for Consumer</span><br><span class="line"> * to consumer. It will use wait() method when Queue is full</span><br><span class="line"> * and use notify() method to send notification to Consumer</span><br><span class="line"> * Thread.</span><br><span class="line"> * @author WINDOWS 8</span><br><span class="line"> * */</span><br><span class="line">class Producer extends Thread &#123;</span><br><span class="line">    private Queue&lt;Integer&gt; queue;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                while (queue.size() == maxSize) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Random random = new Random();</span><br><span class="line">                int i = random.nextInt();</span><br><span class="line">                System.out.println(&quot;Producing value : &quot; + i);</span><br><span class="line">                queue.add(i);</span><br><span class="line">                queue.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Consumer Thread will consumer values form shared queue.</span><br><span class="line"> * It will also use wait() method to wait if queue is</span><br><span class="line"> * empty. It will also use notify method to send * notification to producer thread after consuming values</span><br><span class="line"> * from queue.</span><br><span class="line"> * @author WINDOWS 8</span><br><span class="line"> **/</span><br><span class="line">class Consumer extends Thread &#123;</span><br><span class="line">    private Queue&lt;Integer&gt; queue;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                while (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; System.out.println(&quot;Consuming value : &quot; + queue.remove());</span><br><span class="line">                queue.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output </span><br><span class="line">How to use wait and notify method in Java </span><br><span class="line">Solving Producer Consumper Problem </span><br><span class="line">Queue is empty,Consumer thread is waiting for producer thread to put something in queue </span><br><span class="line">Producing value : -1692411980 </span><br><span class="line">Producing value : 285310787 </span><br><span class="line">Producing value : -1045894970 </span><br><span class="line">Producing value : 2140997307 </span><br><span class="line">Producing value : 1379699468 </span><br><span class="line">Producing value : 912077154 </span><br><span class="line">Producing value : -1635438928 </span><br><span class="line">Producing value : -500696499 </span><br><span class="line">Producing value : -1985700664 </span><br><span class="line">Producing value : 961945684 </span><br><span class="line">Queue is full, Producer thread waiting for consumer to take something from queue Consuming value : -1692411980 </span><br><span class="line">Consuming value : 285310787 </span><br><span class="line">Consuming value : -1045894970 </span><br><span class="line">Consuming value : 2140997307 </span><br><span class="line">Consuming value : 1379699468 </span><br><span class="line">Consuming value : 912077154 </span><br><span class="line">Consuming value : -1635438928 </span><br><span class="line">Consuming value : -500696499 </span><br><span class="line">Consuming value : -1985700664 </span><br><span class="line">Consuming value : 961945684 </span><br><span class="line">Queue is empty,Consumer thread is waiting for producer thread to put something in queue</span><br></pre></td></tr></table></figure><h2 id="使用wait，notify，notifyAll需要注意的"><a href="#使用wait，notify，notifyAll需要注意的" class="headerlink" title="使用wait，notify，notifyAll需要注意的"></a>使用wait，notify，notifyAll需要注意的</h2><ul><li>在Java中可以使用wait，notify，notifyAll完成多线程(不仅仅是两个线程)的内部通信。</li><li>在同步方法或同步块中使用wait，notify，notifyAll，否则JVM会抛出IllegalMonitorStateException</li><li>在循环中调用wait，notify。</li><li>在线程共享的对象上调用wait</li><li>偏向选择notifyAll，而不是notify</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:&lt;code&gt;Producer&lt;/code&gt;(生产者)和&lt;code&gt;Consumer&lt;/code&gt;(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【译】Java8中的扩展(default/extension)方法 （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/Java-8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95-Default-Defender-Extension-%E6%96%B9%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/</id>
    <published>2018-04-13T07:14:18.000Z</published>
    <updated>2018-04-13T07:24:37.104Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8允许开发者使用<code>default</code>和<code>static</code>两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。<br><a id="more"></a></p><h2 id="Default方法的例子"><a href="#Default方法的例子" class="headerlink" title="Default方法的例子"></a>Default方法的例子</h2><p>Java 8让我们可以通过default关键字为接口添加非抽象的方法。这一特性也被称作Extension(扩展)方法。下面是第一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Multiplication&#123; </span><br><span class="line">    </span><br><span class="line">    int multiply(int a, int b); </span><br><span class="line">    </span><br><span class="line">    default int square(int a)&#123; </span><br><span class="line">        return multiply(a, a); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了抽象方法multiply()之外，接口Multiplication还包含一个default方法square()。任何实现Multiplication接口的类只需实现抽象方法multiply，default方法square()可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Multiplication product = new Multiplication()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int multiply(int x, int y)&#123;</span><br><span class="line">        return x*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    int square = product.square(2);</span><br><span class="line">    int multiplication = product.multiply(2, 3);</span><br></pre></td></tr></table></figure><p>product是个匿名类。这段代码有点啰嗦了，用了6行实现一个简单地乘法的功能。我们可以利用lambda表达式来简化一下代码，lambda表达式也是Java 8中新引入的。因为我们的接口只包含一个抽象方法，而且lambda表达式也是SAM(Single Abstract method单一抽象方法)类型的。我们可以用lambda表达式来替代匿名类将代码简化成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiplication lambda = (x, y) -&gt; x*y; </span><br><span class="line">int product = lambda.multiply(3, 4); </span><br><span class="line">int square = lambda.square(4);</span><br></pre></td></tr></table></figure></p><p>以上就是在接口中使用default方法的例子。现在，你可以毫无顾虑的在旧的接口中扩展新的方法，只要这些方法是default或static的就不用担心会破坏接口的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**Java Program to demonstrate use of default method in Java 8. </span><br><span class="line"> * You can define non-abstract method by using default keyword, and more </span><br><span class="line"> * than one default method is permitted, which allows you to ship default skeletal </span><br><span class="line"> * implementation on interface itself. </span><br><span class="line"> * @author Javin Paul</span><br><span class="line"> */ </span><br><span class="line"> public class Java8DefaultMethodDemo&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String args[]) &#123; </span><br><span class="line">    // Implementing interface using Anonymous class </span><br><span class="line">    Multiplication product = new Multiplication()&#123; </span><br><span class="line">        @Override public int multiply(int x, int y)&#123; </span><br><span class="line">            return x*y; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">        int squareOfTwo = product.square(2); </span><br><span class="line">        int cubeOfTwo = product.cube(2); </span><br><span class="line">        System.out.println(&quot;Square of Two : &quot; + squareOfTwo); </span><br><span class="line">        System.out.println(&quot;Cube of Two : &quot; + cubeOfTwo); </span><br><span class="line">        // Since Multiplication has only one abstract method, it can </span><br><span class="line">        // also be implemented using lambda expression in Java 8 </span><br><span class="line">        Multiplication lambda = (x, y) -&gt; x*y; </span><br><span class="line">        int squareOfThree = lambda.square(3); </span><br><span class="line">        int cubeOfThree = lambda.cube(3); </span><br><span class="line">        System.out.println(&quot;Square of Three : &quot; + squareOfThree); </span><br><span class="line">        System.out.println(&quot;Cube of Three : &quot; + cubeOfThree);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">   interface Multiplication&#123; </span><br><span class="line">        int multiply(int a, int b);</span><br><span class="line">        default int square(int a)&#123; </span><br><span class="line">            return multiply(a, a); </span><br><span class="line">        &#125; </span><br><span class="line">        default int cube(int a)&#123; </span><br><span class="line">            return multiply(multiply(a, a), a); </span><br><span class="line">        &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       Output :  Square of Two : 4 </span><br><span class="line">                 Cube of Two : 8 </span><br><span class="line">                 Square of Three : 9 </span><br><span class="line">                 Cube of Three : 27</span><br></pre></td></tr></table></figure><p>这是个很好的关于如何使用default方法在接口中方便的添加方法的例子。也展示了如何避免一个额外的帮助类，比如Collections类。它仅仅提供了一些用于Collection的工具方法，而现在我们可以直接在Collection中定义这些方法。在上面的例子中，我们有一个包含一个抽象方法multiply(a,b)的接口Multiplication，接口还包括两个依赖于multiply(a,b)方法的非抽象方法square(a)和cube(b)。接口的实现类只需要实现multiply(a,b)方法，就可以直接使用square(a)和cube(b)方法了。</p><h2 id="default方法的关键点"><a href="#default方法的关键点" class="headerlink" title="default方法的关键点"></a>default方法的关键点</h2><ul><li>在Java8中你可以在接口中添加default方法</li><li>default方法的出现使得接口和抽象类的不同变得模糊。所以，当在面试中被问到这个问题，别忘了提一下，以前只能通过抽象类实现的事情，现在也可以通过default方法实现了。</li><li>default并不是一个新的关键字，在JDK1.1中就是保留关键字</li><li>接口中default方法的数量没有限制</li><li>如果接口C继承了接口A和B，如果A和B中拥有一样的default方法，编译器在编译过程中会报错。为了避免歧义，这在Java 8中是不允许的。所以当default方法有冲突时，是不可以多继承的</li><li>在JDK1.8中有许多关于default方法的例子，比如forEach方法。也可以查看java.util.Map中新添的putIfAbsent方法，在JDK1.8之前，我们只能ConcurrentMap来使用它。</li></ul><p>以上就是default方法。不得不说，这是一个巨大的突破，使我们可以更好更方便的使用接口。了解CurrentMap的putIfAbsent方法可以帮助我们更好的记住default方法。在JDK1.7中，putIfAbsent方法并不存在于Map接口中，所以为了使用putIfAbsent方法，必须将Map接口指向的ConcurrentMap对象强制转换成ConcurrentMap。但Java 8引入扩展方法之后，Map接口中也有了putIfAbsent方法。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/11/01/Java-8中的扩展-Default-Defender-Extension-方法/" target="_blank" rel="noopener">【译】Java8中的扩展(default/extension)方法 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8允许开发者使用&lt;code&gt;default&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何在java中使用ConcurrentHashMap（转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8ConcurrentHashMap/"/>
    <id>https://hsb786.github.io/2018/04/13/【译】如何在java中使用ConcurrentHashMap/</id>
    <published>2018-04-13T06:41:41.000Z</published>
    <updated>2018-04-13T07:26:36.082Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap(简称<code>CHM</code>)是在Java 1.5作为<code>Hashtable</code>的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。<br><a id="more"></a></p><h2 id="Java中ConcurrentHashMap的实现"><a href="#Java中ConcurrentHashMap的实现" class="headerlink" title="Java中ConcurrentHashMap的实现"></a>Java中ConcurrentHashMap的实现</h2><p>CHM引入了分割，并提供了HashTable支持的所有的功能。在CHM中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(<code>concurrency level</code>)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。</p><p>另一个重要点是在迭代遍历CHM时，keySet返回的iterator是<a href="https://hsb786.github.io/2018/04/09/术语/">弱一致</a>和<a href="(https://hsb786.github.io/2018/04/09/术语/">fail-safe</a>的，可能不会返回某些最近的改变，并且在遍历过程中，如果已经遍历的数组上的内容变化了，不会抛出ConcurrentModificationExceptoin的异常。</p><p>CHM默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，CHM还使用了ReentrantLock来对segments加锁。</p><h2 id="Java中ConcurrentHashMap-putifAbsent方法的例子"><a href="#Java中ConcurrentHashMap-putifAbsent方法的例子" class="headerlink" title="Java中ConcurrentHashMap putifAbsent方法的例子"></a>Java中ConcurrentHashMap putifAbsent方法的例子</h2><p>很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized(map)&#123;</span><br><span class="line">  if (map.get(key) == null)&#123;</span><br><span class="line">      return map.put(key, value);</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">      return map.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码在HashMap和HashTable中是好用的，但在CHM中是有出错的风险的。这是因为CHM在put操作时并没有对整个Map加锁，所以一个线程正在put(k,v)的时候，另一个线程调用get(k)会得到null，这就会造成一个线程put的值会被另一个线程put的值所覆盖。当然，你可以将代码封装到synchronized代码块中，这样虽然线程安全了，但会使你的代码变成了单线程。CHM提供的putIfAbsent(key,value)方法原子性的实现了同样的功能，同时避免了上面的线程竞争的风险。</p><h2 id="什么时候使用ConcurrentHashMap"><a href="#什么时候使用ConcurrentHashMap" class="headerlink" title="什么时候使用ConcurrentHashMap"></a>什么时候使用ConcurrentHashMap</h2><p>CHM适用于读者数量超过写者时，当写者数量大于等于读者时，CHM的性能是低于Hashtable和synchronized Map的。这是因为当锁住了整个Map时，读操作要等待对同一部分执行写操作的线程结束。CHM适用于做cache,在程序启动时初始化，之后可以被多个请求线程访问。正如Javadoc说明的那样，CHM是HashTable一个很好的替代，但要记住，CHM的比HashTable的同步性稍弱。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们知道了什么是ConcurrentHashMap和什么时候该用ConcurrentHashMap，下面我们来复习一下CHM的一些关键点。</p><ul><li>CHM允许并发的读和线程安全的更新操作</li><li>在执行写操作时，CHM只锁住部分的Map</li><li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li><li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li><li>CHM的所有操作都是线程安全</li><li>CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li><li>CHM不允许null的键值</li><li>可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/11/06/【译】如何在java中使用ConcurrentHashMap/" target="_blank" rel="noopener">【译】如何在java中使用ConcurrentHashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap(简称&lt;code&gt;CHM&lt;/code&gt;)是在Java 1.5作为&lt;code&gt;Hashtable&lt;/code&gt;的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>jvm-GC（转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/jvm-GC/"/>
    <id>https://hsb786.github.io/2018/04/13/jvm-GC/</id>
    <published>2018-04-13T06:10:31.000Z</published>
    <updated>2018-04-13T12:08:44.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字约定"><a href="#关键字约定" class="headerlink" title="关键字约定"></a>关键字约定</h2><ul><li>Young generation –&gt;新生代</li><li>Tenured / Old Generation –&gt;老年代</li><li>Perm Area –&gt;永久代</li></ul><h2 id="重要的东东"><a href="#重要的东东" class="headerlink" title="重要的东东"></a>重要的东东</h2><ul><li>在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。</li><li>GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。</li><li>GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。</li><li>在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。</li><li>在从内存回收一个对象之前会调用对象的finalize()方法。</li><li>作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。</li><li>System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。</li><li>如果堆没有内存创建新的对象了，会抛出<code>OutOfMemoryError</code>。<a id="more"></a><h2 id="GC针对什么对象？"><a href="#GC针对什么对象？" class="headerlink" title="GC针对什么对象？"></a>GC针对什么对象？</h2></li></ul><p>了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。</p><p><img src="/images/GC-Object.png" alt="GC回收对象"></p><h2 id="堆内存是如何划分的？"><a href="#堆内存是如何划分的？" class="headerlink" title="堆内存是如何划分的？"></a>堆内存是如何划分的？</h2><p>Java中对象都在堆上创建。为了GC，堆内存分为三个部分，也可以说三代，分别称为新生代，老年代和永久代。其中新生代又进一步分为Eden区，Survivor 1区和Survivor 2区(如下图)。新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代。</p><p><img src="/images/堆内存.png" alt="堆内存"></p><p>永久代有一些特殊，它用来存储类的元信息。对于GC是否发生在永久代有许多不同的看法，在我看来这取决于采用的JVM。大家可以通过创建大量的字符串来观察是发生了GC还是抛出了OutOfMemoryError。</p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><ol><li>标记清除算法<br> 分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="/images/sweep.jpg" alt=""></li><li>复制算法<br> 把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。<br><img src="/images/copy.jpg" alt=""></li><li>标记整理算法<br> 标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理。优点是不会造成内存碎片。<br><img src="/images/compact.jpg" alt=""></li></ol><h2 id="Java中垃圾回收器的类型"><a href="#Java中垃圾回收器的类型" class="headerlink" title="Java中垃圾回收器的类型"></a>Java中垃圾回收器的类型</h2><p>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p><ul><li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li><li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li><li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li><li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li><li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li><li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li></ul><h2 id="与GC有关的JVM参数"><a href="#与GC有关的JVM参数" class="headerlink" title="与GC有关的JVM参数"></a>与GC有关的JVM参数</h2><p>在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。<br>举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过-XX:NewRatio来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小<br><img src="/images/jvm-parameter.png" alt="jvm参数"></p><h2 id="Full-GC和并发垃圾回收"><a href="#Full-GC和并发垃圾回收" class="headerlink" title="Full GC和并发垃圾回收"></a>Full GC和并发垃圾回收</h2><p>并发垃圾回收器的内存回收过程是与用户线程一起并发执行的。通常情况下，并发垃圾回收器可以在用户线程运行的情况下完成大部分的回收工作，所以应用停顿时间很短。</p><p>但由于并发垃圾回收时用户线程还在运行，所以会有新的垃圾不断产生。作为担保，如果在老年代内存都被占用之前，如果并发垃圾回收器还没结束工作，那么应用会暂停，在所有用户线程停止的情况下完成回收。这种情况称作Full GC，这意味着需要调整有关并发回收的参数了。</p><p>由于Full GC很影响应用的性能，要尽量避免或减少。特别是如果对于高容量低延迟的电商系统，要尽量避免在交易时间段发生Full GC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。</li><li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li><li>永久代是否执行GC，取决于采用的JVM。</li><li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li><li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li><li>JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。</li><li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li></ul><p>以上就是关于Java中GC的一些内容。通过这篇博客，我们可以知道堆内存是如何划分的；一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；当垃圾收集器意识到需要进行GC时会触发Minor GC或Major GC，是自动的，无法强制执行。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/05/13/jvm-GC/" target="_blank" rel="noopener">【译】Java中的垃圾回收机制 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关键字约定&quot;&gt;&lt;a href=&quot;#关键字约定&quot; class=&quot;headerlink&quot; title=&quot;关键字约定&quot;&gt;&lt;/a&gt;关键字约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Young generation –&amp;gt;新生代&lt;/li&gt;
&lt;li&gt;Tenured / Old Generation –&amp;gt;老年代&lt;/li&gt;
&lt;li&gt;Perm Area –&amp;gt;永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;重要的东东&quot;&gt;&lt;a href=&quot;#重要的东东&quot; class=&quot;headerlink&quot; title=&quot;重要的东东&quot;&gt;&lt;/a&gt;重要的东东&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。&lt;/li&gt;
&lt;li&gt;GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。&lt;/li&gt;
&lt;li&gt;GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。&lt;/li&gt;
&lt;li&gt;在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。&lt;/li&gt;
&lt;li&gt;在从内存回收一个对象之前会调用对象的finalize()方法。&lt;/li&gt;
&lt;li&gt;作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。&lt;/li&gt;
&lt;li&gt;System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。&lt;/li&gt;
&lt;li&gt;如果堆没有内存创建新的对象了，会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;。
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【译】Executor, ExecutorService 和 Executors 间的不同 （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/"/>
    <id>https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/</id>
    <published>2018-04-13T05:21:41.000Z</published>
    <updated>2018-04-15T12:27:44.506Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.concurrent.Executor</code>, <code>java.util.concurrent.ExecutorService</code>, <code>java.util.concurrent. Executors</code> 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。<br><a id="more"></a><br>在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：FixedThreadPool(包含固定数目的线程)，CachedThreadPool(可根据需要创建新的线程)等等。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor, ExecutorService, 和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于 java.lang.Thread 类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 difference between Thread and Executor 来了解 Thread 和 Executor 间更多的不同。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用 shutDown 方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。</p><p>Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get() 方法获得执行结果。需要注意的是，Future.get() 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。</p><p>通过 ExecutorService.submit() 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 cancel() 方法用来取消执行 pending 中的任务。</p><p>ExecutorService 部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">void shutdown();</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。</p><p>Executors 部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Executors &#123;</span><br><span class="line">    public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面详细看一下三者的区别：</p><h2 id="Executor-vs-ExecutorService-vs-Executors"><a href="#Executor-vs-ExecutorService-vs-Executors" class="headerlink" title="Executor vs ExecutorService vs Executors"></a>Executor vs ExecutorService vs Executors</h2><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。</li><li>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。</li><li>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</li><li>Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表列出了 Executor 和 ExecutorService 的区别：</p><table><thead><tr><th>Executor</th><th>ExecutorService</th></tr></thead><tbody><tr><td>Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td>ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td>提供execute()方法用来提交任务</td><td>提供submit()方法用来提交任务</td></tr><tr><td>execute()方法无返回值</td><td>submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td>不能取消任务</td><td>可以通过Future.cancel()取消pending中的任务</td></tr><tr><td>没有提供和关闭线程池有关的方法</td><td>提供了关闭线程池的方法</td></tr></tbody></table><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2017/03/17/difference-between-executor-executorService/" target="_blank" rel="noopener">【译】Executor, ExecutorService 和 Executors 间的不同 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.concurrent.Executor&lt;/code&gt;, &lt;code&gt;java.util.concurrent.ExecutorService&lt;/code&gt;, &lt;code&gt;java.util.concurrent. Executors&lt;/code&gt; 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>vscode-database</title>
    <link href="https://hsb786.github.io/2018/04/13/vscode-database/"/>
    <id>https://hsb786.github.io/2018/04/13/vscode-database/</id>
    <published>2018-04-13T03:55:59.000Z</published>
    <updated>2018-04-13T04:23:59.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近发现了一个很好用的vscode插件, vscode-database</strong></p><p>迷上了vscode</p><p><img src="/images/vscode-database.png" alt=""><br><a id="more"></a><br><img src="/images/vscode_mysql.png" alt=""></p><p><strong>快捷键</strong></p><table><thead><tr><th>命令</th><th>语义</th></tr></thead><tbody><tr><td>ctrl q</td><td>querySQL</td></tr><tr><td>ctrl shift e</td><td>Run selected text as SQL query    </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近发现了一个很好用的vscode插件, vscode-database&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迷上了vscode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vscode-database.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://hsb786.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>触发器</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://hsb786.github.io/2018/04/13/触发器/</id>
    <published>2018-04-13T03:43:11.000Z</published>
    <updated>2018-04-13T04:38:27.314Z</updated>
    
    <content type="html"><![CDATA[<p>对某一个表的某种操作，触发某种条件，从而执行的一段程序</p><p>new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。</p><p>old：旧数据，数据库里原先有的数据<br><a id="more"></a></p><p>说明：在把userjob(用户岗位关联表)中的success(审批状态)更新为true时，自动在成绩表中出入数据；否则说明没有审批没有通过，把成绩表中对应的数据删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER `insertScore` AFTER UPDATE ON `userjob` FOR EACH ROW if new.success=true then</span><br><span class="line">insert into score(id) values(new.id);</span><br><span class="line">else delete from score where id=new.id;</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p><p>说明：在删除userjob(用户岗位关联表)的数据时，自动删除成绩表对应中的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER `deleteScore` BEFORE DELETE ON `userjob` FOR EACH ROW if old.success=true then</span><br><span class="line">delete from score where id=old.id;</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对某一个表的某种操作，触发某种条件，从而执行的一段程序&lt;/p&gt;
&lt;p&gt;new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。&lt;/p&gt;
&lt;p&gt;old：旧数据，数据库里原先有的数据&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="https://hsb786.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://hsb786.github.io/2018/04/12/%E7%B4%A2%E5%BC%95/"/>
    <id>https://hsb786.github.io/2018/04/12/索引/</id>
    <published>2018-04-12T12:56:19.000Z</published>
    <updated>2018-04-15T12:21:35.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构</p><p>排好序的快速查找数据结构</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。<br><a id="more"></a></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引对数据进行排序，降低数据排序的成本，降低了消耗</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引列也是要占空间的</li><li>虽然索引列大大提高了查询速度，同时会降低更新表的速度。因为更新表时，还要保存一下索引文件每次更新添加了索引列的字段</li></ul><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul><li>主键自动建立唯一索引            （不需要自己建）</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引    （自动建立）</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组的字段</li></ul><h3 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h3><ul><li>表记录太小</li><li>经常增删改的表</li><li>某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;索引（Index）是帮助MySQL高效获取数据的数据结构&lt;/p&gt;
&lt;p&gt;排好序的快速查找数据结构&lt;/p&gt;
&lt;p&gt;在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="https://hsb786.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="https://hsb786.github.io/2018/04/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://hsb786.github.io/2018/04/12/Java虚拟机/</id>
    <published>2018-04-12T12:01:50.000Z</published>
    <updated>2018-04-14T12:37:13.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。<br><a id="more"></a></p><h2 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h2><p>JVM并不是专为Java所实现的。实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。</p><p>JVM通过执行Java bytecode可以使java代码在不改变的情况下运行在各种硬件之上，因此实现Java平台无关性</p><p><strong>JVM = 类加载器 Class Loader + 执行引擎 Execution Engine + 运行时数据区域 Runtime Data Area</strong></p><p>首先Java源代码文件被Java编译器编译为字节码文件，然后JVM中的类加载器加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM中的运行时数据区（内存）会用来存储程序执行期间需要用到的数据和相关信息。</p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>ClassLoader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它并不负责这个类文件能否执行，而这个是执行引擎负责的。</p><h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><p>执行字节码，或者执行本地方法</p><h3 id="Runtime-DataArea"><a href="#Runtime-DataArea" class="headerlink" title="Runtime DataArea"></a>Runtime DataArea</h3><p>指JVM在运行期间，其对JVM内存空间的划分和分配。</p><p><img src="/images/java虚拟机.png" alt=""></p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。</p><p>当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。</p><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ol><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。</p><p>和JVM栈一样，也会抛出StackOverflowError和OutOfMemoryError异常</p><h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p><p>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   </p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。</p><p>由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，但java7已经把常量池转移到堆里面了。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/ns_code/article/details/17565503" target="_blank" rel="noopener">【深入Java虚拟机】之一：Java内存区域与内存溢出</a></p><p><a href="https://yemengying.com/2015/11/12/读书笔记-深入理解Java虚拟机1/" target="_blank" rel="noopener">读书笔记-深入理解Java虚拟机1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存区域&quot;&gt;&lt;a href=&quot;#内存区域&quot; class=&quot;headerlink&quot; title=&quot;内存区域&quot;&gt;&lt;/a&gt;内存区域&lt;/h2&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
</feed>
