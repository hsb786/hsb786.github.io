<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-05-07T03:30:29.909Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java语法糖【深入理解Java虚拟机】</title>
    <link href="https://hsb786.github.io/2018/05/05/Java%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/05/Java语法糖【深入理解Java虚拟机】/</id>
    <published>2018-05-05T07:06:23.000Z</published>
    <updated>2018-05-07T03:30:29.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>语法糖可以看做是编译器实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们所迷惑</p></blockquote><a id="more"></a><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><p>泛型是JDK1.5的一项新增特性，它的本质是参数化类型（Parametersized Type）的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别为泛型类、泛型接口和泛型方法。</p><p>在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现泛型类型泛化。Object转换成任何对象都是有可能的，但是正因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。<strong>在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期间。</strong></p><p><strong>Java语言的泛型只在程序源码中存在，在编译后的字节码文件中，已经替换为原来的原生类型（Raw Type，也成为裸类型）了，并且在相应的地方插入了强制转型代码</strong>。Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为伪泛型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;Hello&quot;, &quot;you&quot;);</span><br><span class="line">System.out.println(map.get(&quot;Hello&quot;));</span><br></pre></td></tr></table></figure><p>反编译后的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Map map=new HashMap();    书本上的答案,java7</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap();</span><br><span class="line">//奇怪，我用jad反编译后，前面&lt;&gt;没有擦除，后面&lt;&gt;擦除了，难道是因为用的是java8的原因吗？</span><br><span class="line">map.put(&quot;Hello&quot;, &quot;you&quot;);</span><br><span class="line">//强制转型</span><br><span class="line">System.out.println((String)map.get(&quot;Hello&quot;));</span><br></pre></td></tr></table></figure></p><p><strong>当泛型遇见重载1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void method(List&lt;String&gt; list) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method(List&lt;Integer&gt; list) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译不能通过，List&lt;String>和List&lt;Integer>都变成了原生类型List&lt;E></p><p><strong>当泛型遇见重载2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String method(List&lt;String&gt; list) &#123;</span><br><span class="line">    return &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int method(List&lt;Integer&gt; list) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SUN JDK1.6的javac编译器进行编译，其它编译器仍然可能会拒绝编译这段代码</p><blockquote><p>方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名中，所以返回值不参与重载选择</p><p>但是在Class文件格式中，只要描述符不是完全一致的两个方法就可以共存。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件中</p></blockquote><h2 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=Arrays.asList(1,2,3,4);</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i:list) &#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(new Integer[] &#123; Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4) &#125;);</span><br><span class="line">int sum = 0;</span><br><span class="line">for (Iterator localIterator = list.iterator(); localIterator.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">    int i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>遍历循环把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的实现</p><p>陷阱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer a=1;</span><br><span class="line">Integer b=2;</span><br><span class="line">Integer c=3;</span><br><span class="line">Integer d=3;</span><br><span class="line">Integer e=321;</span><br><span class="line">Integer f=321;</span><br><span class="line">Long g=3L;</span><br><span class="line">System.out.println(c==d);               true</span><br><span class="line">System.out.println(e==f);                false</span><br><span class="line">System.out.println(c==(a+b));          true</span><br><span class="line">System.out.println(c.equals(a+b));    true</span><br><span class="line">System.out.println(g==(a+b));          true</span><br><span class="line">System.out.println(g.equals(a+b));    false</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(1);</span><br><span class="line">Integer b = Integer.valueOf(2);</span><br><span class="line">Integer c = Integer.valueOf(3);</span><br><span class="line">Integer d = Integer.valueOf(3);</span><br><span class="line">Integer e = Integer.valueOf(321);</span><br><span class="line">Integer f = Integer.valueOf(321);</span><br><span class="line">Long g = Long.valueOf(3L);</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">System.out.println(e == f);</span><br><span class="line">System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">System.out.println(g.longValue() == a.intValue() + b.intValue());</span><br><span class="line">System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>编译器并非一个一个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后进行编译，因此各个文件之间能够互相提供符号信息。（什么鬼？在说什么😱）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(true) &#123;</span><br><span class="line">    System.out.println(&quot;1&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    System.out.println(&quot;2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;1&quot;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;语法糖可以看做是编译器实现的一些“小把戏”，这些“小把戏”可能会使得效率“大提升”，但我们也应该去了解这些“小把戏”背后的真实世界，那样才能利用好它们，而不是被它们所迷惑&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="深入理解Java虚拟机" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化【深入理解Java虚拟机】</title>
    <link href="https://hsb786.github.io/2018/05/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/05/线程安全与锁优化【深入理解Java虚拟机】/</id>
    <published>2018-05-05T05:16:29.000Z</published>
    <updated>2018-05-07T04:31:48.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确使用。</p></blockquote><a id="more"></a><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，<strong>只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远也不会改变</strong>，永远也不会看到它在多个线程之间处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的。</p><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p><strong>1.互斥同步</strong><br>互斥同步（MutualExclusion &amp; Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方法。因此，在这4个字里，互斥是因，同步是果；互斥是方法，同步时目的。</p><p><strong>在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</strong></p><p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><p>在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter（）或setter（）方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级（Heavyweight）的操作</p><p>除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，<strong>一个表现为API层面的互斥锁（lock（）和unlock（）方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁</strong>。不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。</li></ul><p>虚拟机在未来的性能改进中会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><p><strong>2.非阻塞同步</strong><br>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。随着硬件指令集的发展，我们有了另外一个选择：<strong>基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施</strong>（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成， 这类指令常用的有：</p><ul><li>测试并设置（Test-and-Set）。</li><li>获取并增加（Fetch-and-Increment）。</li><li>交换（Swap）。</li><li>比较并交换（Compare-and-Swap，CAS）。</li><li>加载链接/条件存储（Load-Linked/Store-Conditional，LL/SC）。</li></ul><p>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p><p>在JDK  1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt（）和compareAndSwapLong（）等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了</p><p>由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe（）的代码中限制了只有启动类加载器（Bootstrap  ClassLoader）加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他的Java  API来间接使用它，如J.U.C包里面的整数原子类，其中的compareAndSet（）和getAndIncrement（）等方法都使用了Unsafe类的CAS操作。</p><p><strong>3.无同步方案</strong><br>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。<strong>同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性</strong>，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p><p><strong>可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误</strong>。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。<br>🤨什么意思？是指Lambda表达式吗？无副作用的，纯粹的函数，不应该有（对外部可见的）对象修改</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：<strong>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</strong>。</p><p>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>🙃不太好理解，其实就是ThreadLocal，<strong>为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="深入理解Java虚拟机" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程【深入理解Java虚拟机】</title>
    <link href="https://hsb786.github.io/2018/05/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%90%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/05/Java内存模型与线程【深入理解Java虚拟机】/</id>
    <published>2018-05-05T04:00:23.000Z</published>
    <updated>2018-05-05T05:17:00.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来<strong>硬件发展从追求处理器频率到追求多核心并行处理的发展过程</strong>。</p></blockquote><a id="more"></a><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让高速运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。</p><p>缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共献同一主内存（Main Memory）。当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议。<br><img src="/images/高速缓存.png" alt="处理器、高速缓存、主内存间的交互关系"></p><p>除了增加高速缓存之外，为了使得处理器内部的运算单位能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out of Order Execution）优化，处理器会在计算之后将乱序执行的结果进行重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序是一致的。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java虚拟机规划中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="/images/工作内存.png" alt="线程、主内存、工作内存三者的交互关系"></p><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制</p><p>当一个变量定义为volatile之后，它将具备两种特性，第一是<strong>保证此变量对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。第二是<strong>禁止指令重排序优化</strong>，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序是一致的</p><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即虚拟机实现选择可以不保证64位数据类型的原子性，这点就是所谓的long和double的非原子性协定（Nonatomic Treatment of double and long Variables）</p><p>Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64为数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p><strong>原子性（Atomicity）</strong>：基本数据类型的访问读写是具备原子性的（例外就是long和double是非原子性协定）</p><p><strong>可见性（Visibility）</strong>：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p><p><strong>有序性（Ordering）</strong>：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来&lt;strong&gt;硬件发展从追求处理器频率到追求多核心并行处理的发展过程&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="深入理解Java虚拟机" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>函数式的思考【Java8实战】</title>
    <link href="https://hsb786.github.io/2018/05/02/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83%E3%80%90Java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/02/函数式的思考【Java8实战】/</id>
    <published>2018-05-02T11:28:31.000Z</published>
    <updated>2018-05-07T04:35:12.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果，那么我么称其为<strong>纯粹的</strong>或者<strong>无副作用的</strong></p></blockquote><a id="more"></a><p><strong>副作用就是函数的效果已经超出了函数自身的范畴</strong>：</p><ul><li>除了构造器内的初始化操作，对类中数据结构的任何修改，包括字段的赋值操作（setter方法）</li><li>抛出一个异常</li><li>进行输入/输出操作，比如向一个文件写数据</li></ul><p>从另一个角度来看“无副作用”的话，我们就应该考虑不可变对象。不可变对象是这样一种对象，<strong>它们一旦完成初始化就不会被任何方法修改状态</strong>。这意味着一旦一个不可变对象初始化完毕，它永远不会进入到一个无法预期的状态。你可以放心地共享它，无需保留任何副本，并且由于它们不会被修改，还是线程安全的。</p><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><p>一般通过编程实现一个系统，有两种思考方式。一种专注于如何实现，比如：“首先做这个，紧接着更新那个，然后…….”。这种“如何做”风格的编程有时候我们也称之为“命令式”编程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transaction mostExpensive = transactions.get(0); </span><br><span class="line">if(mostExpensive == null) </span><br><span class="line">    throw new IllegalArgumentException(&quot;Empty list of transactions&quot;) </span><br><span class="line">for(Transaction t: transactions.subList(1, transactions.size()))&#123; </span><br><span class="line">    if(t.getValue() &gt; mostExpensive.getValue())&#123; </span><br><span class="line">        mostExpensive = t; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种方式则更加关注要做什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Transaction&gt; mostExpensive = </span><br><span class="line">    transactions.stream() </span><br><span class="line">                .max(comparing(Transaction::getValue));</span><br></pre></td></tr></table></figure></p><p>这个查询把最终如何实现的细节留给了函数库。我们把这种思想称之为内部迭代。它的巨大优势在于你的查询语句现在读起来就像是问题陈述，由于采用了这种方法，我们马上就能理解它的功能，比理解一系列的命令要简洁得多</p><p>采用“要做什么”风格的编程通常被称为声明式编程。<strong>你指定规则，给出了希望实现的目标，让系统来决定如何实现这个目标。</strong>它带来的好处非常明显，用这种方式编写的代码更加接近问题陈述。</p><p><strong>函数式编程具体实现了前面介绍的声明式编程和无副作用计算</strong>。这两个思想能帮助我们更容易地构建和维护系统</p><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p><strong>它是一种使用函数进行编程的方式</strong><br><img src="/images/java8-07.png" alt="带有副作用的方法"></p><p>在函数式编程的上下文中，一个“函数”对应于一个数学函数：<strong>它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用</strong>。你可以把它看成一个黑盒，它接收输入并产生一些输出<br><img src="/images/java8-08.png" alt="一个没有任何副作用的函数"></p><p>当谈论“函数式”时，我们想说的其实是“像数学函数那样——没有副作用”</p><h2 id="函数式Java编程"><a href="#函数式Java编程" class="headerlink" title="函数式Java编程"></a>函数式Java编程</h2><p>函数式Java编程编程实战中，你是无法用Java语言以纯粹的函数式来完成一个程序的。比如，Java的I/O模型就包含了带副作用的方法（调用Scanner.nextLine就有副作用，它会从一个文件中读取一行，通常情况两次调用的结果完全不同）。不过，你还是有可能为你系统的核心组件编写接近纯粹函数式的实现。<strong>在Java语言中，如果你希望编写函数式的程序，首先需要做的是确保没有人能觉察到你代码的副作用，这也是函数式的含义</strong>。假设这样一个函数或者方法，它没有副作用，进入方法体执行时会对一个字段的值加一，退出方法体之前会对该字段减一。对一个单线程的程序而言，这个方法是没有副作用的，可以看作函数式的实现。换个角度而言，如果另一个线程可以查看该字段的值——或者更糟糕的情况，该方法会同时被多个线程并发调用——那么这个方法就不能称之为函数式的实现了。当然，你可以用加锁的方式对方法的方法体进行封装，掩盖这一问题，你甚至可以再次声称该方法符合函数式的约定。但是，这样做之后，你就失去了在你的多核处理器的两个核上并发执行两个方法调用的能力。它的副作用对程序可能是不可见的，不过对于程序员你而言是可见的，因为程序运行的速度变慢了！</p><p>我们的准则是，<strong>被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的对象都应该是不可修改的对象。</strong>通过这种规定，我们期望所有的字段都为final类型，所有的引用类型字段都指向不可变对象。</p><p>我们前述的准则是不完备的，要成为真正的函数式程序还有一个附加条件，不过它在最初时不太为大家所重视。<strong>要被称为函数式，函数或者方法不应该抛出任何异常</strong>。关于这一点，有一个极为简单而又极为教条的解释：<strong>你不应该抛出异常，因为一旦抛出异常，就意味着结果被终止了；不再像我们之前讨论的黑盒模式那样，由return返回一个恰当的结果值</strong>。不过，这一规则似乎又和我们实际的数学使用有冲突：虽然合法的数学函数为每个合法的参数值返回一个确定的结果，很多通用的数学操作在严格意义上称之为局部函数式（partial function）可能更为妥当。这种函数对于某些输入值，甚至是大多数的输入值都返回一个确定的结果；不过对另一些输入值，它的结果是未定义的，甚至不返回任何结果。这其中一个典型的例子是除法和开平方运算，如果除法的第二操作数是0，或者开平方的参数为负数就会发生这样的情况。以Java那样抛出一个异常的方式对这些情况进行建模看起来非常自然。这里存在着一定的争执，有的作者认为抛出代表严重错误的异常是可以接受的，但是捕获异常是一种非函数式的控制流，因为这种操作违背了我们在黑盒模型中定义的“传递参数，返回结果”的规则，引出了代表异常处理的第三支箭头<br><img src="/images/java8-09.png" alt="抛出一个异常的方法"></p><p>那么，如果不使用异常，你该如何对除法这样的函数进行建模呢？答案是请使用Optional<t>类型：你应该避免让sqrt使用double sqrt(double)这样的函数签名，因为这种方式可能抛出异常；与之相反我们推荐你使用Optional<double> sqrt(double)——这种方式下，函数要么返回一个值表示调用成功，要么返回一个对象，表明其无法进行指定的操作。当然，这意味着调用者需要检查方法返回的是否为一个空的Optional对象。这件事听起来代价不小，依据我们之前对函数式编程和纯粹的函数式编程的比较，从实际操作的角度出发，你可以选择在本地局部地使用异常，避免通过接口将结果暴露给其他方法，这种方式既取得了函数式的优点，又不会过度膨胀代码。</double></t></p><p>最后，作为函数式的程序，<strong>你的函数或方法调用的库函数如果有副作用，你必须设法隐藏它们的非函数式行为，否则就不能调用这些方法</strong></p><h2 id="引用透明性"><a href="#引用透明性" class="headerlink" title="引用透明性"></a>引用透明性</h2><p>“没有可感知的副作用”（不改变对调用者可见的变量、不进行IO、不抛出异常）的这些限制都隐含着引用透明性。<strong>如果一个函数只要传递同样的参数值，总是返回同样的结果，那这个函数就是引用透明的。</strong>String.replace方法就是引用透明的，因为像”raoul”.replace(‘r’, ‘R’)这样的调用总是返回同样的结果（replace方法返回一个新的字符串，用小写的r替换掉所有大写的R），而不是更新它的this对象，所以它可以被看成函数式的。</p><p>引用透明性是理解程序的一个重要属性。它还包含了对代价昂贵或者需长时间计算才能得到结果的变量值的优化（通过保存机制而不是重复计算），我们通常将其称为记忆化或者缓存。</p><h2 id="面向对象的编程和函数式编程的对比"><a href="#面向对象的编程和函数式编程的对比" class="headerlink" title="面向对象的编程和函数式编程的对比"></a>面向对象的编程和函数式编程的对比</h2><ul><li>极端的面向对象：任何事物都是对象，程序要么通过更新字段完成操作，要么调用对与它相关的对象进行更新的方法</li><li>引用透明的函数式编程：方法不应该有（对外部可见的）对象修改</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>从长远看，减少共享的可变数据结构能帮助你降低维护和调试程序的代价</li><li>函数式编程支持无副作用的方法和声明式编程</li><li>函数式方法可以由它的输入参数及输出结果进行判断</li><li>如果一个函数使用相同的参数值调用，总是返回相同的结果，那么它是引用透明的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果，那么我么称其为&lt;strong&gt;纯粹的&lt;/strong&gt;或者&lt;strong&gt;无副作用的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>默认方法【Java8实战】</title>
    <link href="https://hsb786.github.io/2018/05/02/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E3%80%90Java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/02/默认方法【Java8实战】/</id>
    <published>2018-05-02T10:27:47.000Z</published>
    <updated>2018-05-07T04:36:50.639Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java8中的接口现在支持在声明方法的同时提供实现</p></blockquote><a id="more"></a><ul><li>Java8允许在接口内声明静态方法</li><li>Java8引入了一个新功能，叫默认方法，通过默认方法，你可以指定接口方法的默认实现</li></ul><p><img src="/images/java8-05.png" alt="向接口添加方法"></p><p>向接口添加方法是诸多问题的罪恶之源；一旦接口发生变化，实现这些接口的类往往也需要更新，提供新添方法的实现才能适配接口的变化。如果你对接口以及它所有相关的实现有完全的控制，这可能不是个大问题。但是这种情况是极少的。这就是引入默认方法的目的：它让类可以自动地继承接口的一个默认实现。</p><h3 id="静态方法及接口"><a href="#静态方法及接口" class="headerlink" title="静态方法及接口"></a>静态方法及接口</h3><p> <strong>同时定义接口以及工具辅助类（companion class）是Java语言常用的一种模式，工具类定义了与接口实例协作的很多静态方法。比如，Collections就是处理Collect对象的辅助类</strong>。由于静态方法可以存在于接口内部，你代码中的这些辅助类就没有了存在的必要，你<strong>可以把这些静态方法转移到接口内部</strong>。为了保证向后的兼容性，这些类依然会存在与Java应用程序的接口之中。</p><h3 id="不同类型的兼容性：二进制、源代码和函数行为"><a href="#不同类型的兼容性：二进制、源代码和函数行为" class="headerlink" title="不同类型的兼容性：二进制、源代码和函数行为"></a>不同类型的兼容性：二进制、源代码和函数行为</h3><ul><li>二进制级的兼容性：现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行。比如，为接口添加一个方法就是二进制级的兼容，这种方式下，如果新添加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误</li><li>源代码级的兼容性：引入变化之后，现有的程序依然能成功编译通过。比如，向接口添加新的方法就不是源码级的兼容，因为遗留代码并没有实现新引入的方法，所以它们无法顺利通过编译</li><li>函数行为级的兼容性：变更发生之后，程序接受同样的输入能得到同样的结果。比如，为接口添加新的方法就是函数行为兼容的，因为新添加的方法在程序中并未被调用（抑或该接口在实现中被覆盖了）</li></ul><h2 id="默认方法的使用模式"><a href="#默认方法的使用模式" class="headerlink" title="默认方法的使用模式"></a>默认方法的使用模式</h2><h3 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h3><p>类实现了接口，不过却刻意地将一些方法的实现留白。我们以Iterator接口为例来说。Iterator接口定义了hasNext、next，还定义了remove方法。Java 8之前，由于用户通常不会使用该方法，remove方法常被忽略。因此，实现Interator接口的类通常会为remove方法放置一个空的实现，这些都是些毫无用处的模板代码。采用默认方法之后，你可以为这种类型的方法提供一个默认的实现，这样实体类就无需在自己的实现中显式地提供一个空方法。比如，在Java  8中，Iterator接口就为remove方法提供了一个默认实现，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Iterator&lt;T&gt; &#123; </span><br><span class="line">    boolean hasNext(); </span><br><span class="line">    T next(); </span><br><span class="line">    default void remove() &#123; </span><br><span class="line">    throw new UnsupportedOperationException(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这种方式，你可以减少无效的模块代码。实现Iterator接口的每一个类都不需要再声明一个空的remove方法了，因为它现在已经有一个默认的实现</p><h3 id="行为的多继承"><a href="#行为的多继承" class="headerlink" title="行为的多继承"></a>行为的多继承</h3><p>让类从多个来源重用代码<br><img src="/images/java8-06.png" alt="单继承和多继承的比较"></p><blockquote><p>继承不应该成为你一谈到代码复用就试图倚靠的万精油。比如，从一个拥有100个方法及字段的类进行继承就不是个好主意，因为这其实会引入不必要的复杂性。你完全可以使用代理有效地规避这种窘境，即创建一个方法通过该类的成员变量直接调用该类的方法。这就是为什么有的时候我们发现有些类被刻意地声明为final类型：<strong>声明为final的类不能被其他的类继承，避免发生这样的反模式，防止核心代码的功能被污染</strong>。注意，有的时候声明为final的类都会有其不同的原因，比如，String类被声明为final，因为我们不希望有人对这样的核心功能产生干扰。</p></blockquote><h2 id="解决冲突的规则"><a href="#解决冲突的规则" class="headerlink" title="解决冲突的规则"></a>解决冲突的规则</h2><p>随着默认方法在Java8中引入，有可能出现一个类继承了多个方法而它们使用的却是同样的函数签名。通过三条规则可以进行判断：</p><ul><li><strong>类中的方法优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级</strong></li><li>如果无法依据第一条进行判断，<strong>那么子接口的优先级最高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口</strong>，即如果B继承了A，那么B就比A更加具体</li><li>最后，如果还是无法判断，继承了多个接口的类必须通过显示覆盖和调用期望的方法，<strong>显示地选择使用哪一个默认方法的实现</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Java8中的接口可以通过默认方法和静态方法提供实现</li><li>默认方法的开头以关键字default修饰，方法体与常规的类方法相同</li><li>向发布的接口添加抽象方法不是源码兼容的</li><li>默认方法的出现能帮助库的设计者以后向兼容的方式演进API</li><li>默认方法可以用于创建可选方法和行为的多继承</li><li>类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法</li><li>两个默认方法都同样具体时，你需要在类中覆盖该方法，显示地选择使用哪个接口中提供的方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java8中的接口现在支持在声明方法的同时提供实现&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>重构【Java8实战】</title>
    <link href="https://hsb786.github.io/2018/05/02/%E9%87%8D%E6%9E%84%E3%80%90Java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/05/02/重构【Java8实战】/</id>
    <published>2018-05-02T07:11:48.000Z</published>
    <updated>2018-05-02T10:26:53.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用Java8的各种特性更有效地改善代码质量</p></blockquote><a id="more"></a><h2 id="从匿名类到Lambda表达式的转换"><a href="#从匿名类到Lambda表达式的转换" class="headerlink" title="从匿名类到Lambda表达式的转换"></a>从匿名类到Lambda表达式的转换</h2><p>匿名类极其繁琐且容易出错；采用Lambda表达式之后，你的代码会更简洁，可读性更好<br><img src="/images/java8-01.png" alt=""></p><p>但是某些情况下，将匿名类转换成Lambda表达式可能是一个比较复杂的过程。首先，匿名类和Lambda表达式中的this和super的含义是不同的。<strong>在匿名类中，this代表的是类自身，但是在Lambda中，它代表的是包含类</strong>。其次，匿名类可以屏蔽包含类的常量，而Lambda表达式不能（它们会导致编译错误）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 10; </span><br><span class="line">Runnable r1 = () -&gt; &#123; </span><br><span class="line">    //编译错误</span><br><span class="line">    int a = 2;   </span><br><span class="line">    System.out.println(a); </span><br><span class="line">&#125;; </span><br><span class="line">Runnable r2 = new Runnable()&#123; </span><br><span class="line">    public void run()&#123; </span><br><span class="line">        //一切正常</span><br><span class="line">        int a = 2;  </span><br><span class="line">        System.out.println(a); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，在涉及重载的上下文里，将匿名类转换为Lambda表达式可能导致最终的代码更加晦涩。<strong>实际上，匿名类的类型是在初始化时确定的，而Lambda的类型</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//定义一个函数式接口</span><br><span class="line">interface Task&#123; </span><br><span class="line">    public void execute(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public static void doSomething(Runnable r)&#123; r.run(); &#125; </span><br><span class="line">public static void doSomething(Task a)&#123; a.execute(); &#125; </span><br><span class="line"></span><br><span class="line">//使用匿名类实现的Task，一切正常</span><br><span class="line">doSomething(new Task() &#123; </span><br><span class="line">    public void execute() &#123; </span><br><span class="line">        System.out.println(&quot;Danger danger!!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">//使用Lambda表达式时，doSome-thing(Runnable)和doSomething(Task)都匹配该类型</span><br><span class="line">doSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));  </span><br><span class="line"></span><br><span class="line">//你可以对Task尝试使用显式的类型转换来解决这种模棱两可的情况：</span><br><span class="line">doSomething((Task)() -&gt; System.out.println(&quot;Danger danger!!&quot;));</span><br></pre></td></tr></table></figure></p><h2 id="使用Lambda重构面向对象的设计模式"><a href="#使用Lambda重构面向对象的设计模式" class="headerlink" title="使用Lambda重构面向对象的设计模式"></a>使用Lambda重构面向对象的设计模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>策略模式代表了解决一类算法的通用解决方案，你可以在运行时选择使用哪种方案</strong></p><p>策略模式包含三部分内容</p><ul><li>一个代表某个算法的接口（它是策略模式的接口）。</li><li>一个或多个该接口的具体实现，它们代表了算法的多种实现（比如，实体类Concrete- StrategyA或者ConcreteStrategyB）。</li><li>一个或多个使用策略对象的客户。<br><img src="/images/java8-02.png" alt=""></li></ul><p>我们假设你希望验证输入的内容是否根据标准进行了恰当的格式化（比如只包含小写字母或数字）。你可以从定义一个验证文本（以String的形式表示）的接口入手<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ValidationStrategy &#123; </span><br><span class="line">    boolean execute(String s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其次，你定义了该接口的一个或多个具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IsAllLowerCase implements ValidationStrategy &#123; </span><br><span class="line">    public boolean execute(String s)&#123; </span><br><span class="line">        return s.matches(&quot;[a-z]+&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public class IsNumeric implements ValidationStrategy &#123; </span><br><span class="line">    public boolean execute(String s)&#123; </span><br><span class="line">        return s.matches(&quot;\\d+&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，你就可以在你的程序中使用这些略有差异的验证策略了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Validator&#123; </span><br><span class="line">    private final ValidationStrategy strategy; </span><br><span class="line">    public Validator(ValidationStrategy v)&#123; </span><br><span class="line">        this.strategy = v; </span><br><span class="line">    &#125; </span><br><span class="line">    public boolean validate(String s)&#123; </span><br><span class="line">        return strategy.execute(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Validator numericValidator = new Validator(new IsNumeric()); </span><br><span class="line">boolean b1 = numericValidator.validate(&quot;aaaa&quot;);  </span><br><span class="line">Validator lowerCaseValidator = new Validator(new IsAllLowerCase ()); </span><br><span class="line">boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;);</span><br></pre></td></tr></table></figure></p><p>ValidationStrategy是一个函数接口了（除此之外，它还与Predicate<string>具有同样的函数描述）。这意味着我们不需要声明新的类来实现不同的策略，通过直接传递Lambda表达式就能达到同样的目的，并且还更简洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Validator numericValidator = </span><br><span class="line">    new Validator((String s) -&gt; s.matches(&quot;[a-z]+&quot;));  </span><br><span class="line">boolean b1 = numericValidator.validate(&quot;aaaa&quot;);  </span><br><span class="line">Validator lowerCaseValidator = </span><br><span class="line">    new Validator((String s) -&gt; s.matches(&quot;\\d+&quot;));  </span><br><span class="line">boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;);</span><br></pre></td></tr></table></figure></string></p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>如果你需要采用某个算法的框架，同时又希望有一定的灵活度，能对它的某些部分进行改进，那么采用模板方法设计模式是比较通用的方案。<br>定义：<strong>规定一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</strong></p><p>假设你需要编写一个简单的在线银行应用。通常，  用户需要输入一个用户账户，之后应用才能从银行的数据库中得到用户的详细信息，最终完成一些让用户满意的操作。不同分行的在线银行应用让客户满意的方式可能还略有不同，比如给客户的账户发放红利，或者仅仅是少发送一些推广文件。你可能通过下面的抽象类方式来实现在线银行应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class OnlineBanking &#123; </span><br><span class="line">    public void processCustomer(int id)&#123; </span><br><span class="line">        Customer c = Database.getCustomerWithId(id); </span><br><span class="line">        makeCustomerHappy(c); </span><br><span class="line">    &#125; </span><br><span class="line">    abstract void makeCustomerHappy(Customer c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processCustomer方法搭建了在线银行算法的框架：获取客户提供的ID，然后提供服务让用户满意。不同的支行可以通过继承OnlineBanking类，对该方法提供差异化的实现。</p><p>使用Lambda表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void processCustomer(int id, Consumer&lt;Customer&gt; makeCustomerHappy)&#123; </span><br><span class="line">    Customer c = Database.getCustomerWithId(id); </span><br><span class="line">    makeCustomerHappy.accept(c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，你可以很方便地通过传递Lambda表达式，直接插入不同的行为，不再需要继承OnlineBanking类了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new OnlineBankingLambda().processCustomer(1337, (Customer c) -&gt; </span><br><span class="line">    System.out.println(&quot;Hello &quot; + c.getName());</span><br></pre></td></tr></table></figure></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式是一种比较常见的方案，某些事件发生时（比如状态转变），如果一个对象（通常我们称之为主题）需要自动地通知其他多个对（称为观察者），就会采用该方案</p><p><img src="/images/java8-03.png" alt=""></p><p>你需要为Twitter这样的应用设计并实现一个定制化的通知系统。想法很简单：好几家报纸机构，比如《纽约时报》《卫报》以及《世界报》都订阅了新闻，他们希望当接收的新闻中包含他们感兴趣的关键字时，能得到特别通知。</p><p>首先，你需要一个观察者接口，它将不同的观察者聚合在一起。它仅有一个名为notify的方法，一旦接收到一条新的新闻，该方法就会被调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Observer &#123; </span><br><span class="line">    void notify(String tweet); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，你可以声明不同的观察者（比如，这里是三家不同的报纸机构），依据新闻中不同的关键字分别定义不同的行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class NYTimes implements Observer&#123; </span><br><span class="line">    public void notify(String tweet) &#123; </span><br><span class="line">        if(tweet != null &amp;&amp; tweet.contains(&quot;money&quot;))&#123; </span><br><span class="line">            System.out.println(&quot;Breaking news in NY! &quot; + tweet); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">class Guardian implements Observer&#123; </span><br><span class="line">    public void notify(String tweet) &#123; </span><br><span class="line">        if(tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;))&#123; </span><br><span class="line">            System.out.println(&quot;Yet another news in London... &quot; + tweet); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">class LeMonde implements Observer&#123; </span><br><span class="line">    public void notify(String tweet) &#123; </span><br><span class="line">        if(tweet != null &amp;&amp; tweet.contains(&quot;wine&quot;))&#123; </span><br><span class="line">            System.out.println(&quot;Today cheese, wine and news! &quot; + tweet); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Subject&#123; </span><br><span class="line">    void registerObserver(Observer o); </span><br><span class="line">    void notifyObservers(String tweet); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subject使用registerObserver方法可以注册一个新的观察者，使用notifyObservers方法通知它的观察者一个新闻的到来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Feed implements Subject&#123; </span><br><span class="line">    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); </span><br><span class="line">    public void registerObserver(Observer o) &#123; </span><br><span class="line">        this.observers.add(o); </span><br><span class="line">    &#125; </span><br><span class="line">    public void notifyObservers(String tweet) &#123; </span><br><span class="line">        observers.forEach(o -&gt; o.notify(tweet)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Feed类在内部维护了一个观察者列表，一条新闻到达时，它就进行通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Feed f = new Feed(); </span><br><span class="line">f.registerObserver(new NYTimes()); </span><br><span class="line">f.registerObserver(new Guardian()); </span><br><span class="line">f.registerObserver(new LeMonde()); </span><br><span class="line">f.notifyObservers(&quot;The queen said her favourite book is Java 8 in Action!&quot;);</span><br></pre></td></tr></table></figure></p><p>Observer接口的所有实现类都提供了一个方法：notify。新闻到达时，它们都只是对同一段代码封装执行。Lambda表达式的设计初衷就是要消除这样的僵化代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f.registerObserver((String tweet) -&gt; &#123; </span><br><span class="line">    if(tweet != null &amp;&amp; tweet.contains(&quot;money&quot;))&#123; </span><br><span class="line">        System.out.println(&quot;Breaking news in NY! &quot; + tweet); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line">f.registerObserver((String tweet) -&gt; &#123; </span><br><span class="line">    if(tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;))&#123; </span><br><span class="line">        System.out.println(&quot;Yet another news in London... &quot; + tweet); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>那么，是否我们随时随地都可以使用Lambda表达式呢？答案是否定的！我们前文介绍的例子中，Lambda适配得很好，那是因为需要执行的动作都很简单，因此才能很方便地消除僵化代码。但是，观察者的逻辑有可能十分复杂，它们可能还持有状态，抑或定义了多个方法，诸如此类。在这些情形下，你还是应该继续使用类的方式。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式是一种创建处理对象序列（比如操作序列）的通用方案。<strong>一个处理对象可能需要在完成一些工作之后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下一个处理对象，以此类推</strong>。</p><p><img src="/images/java8-04.png" alt=""><br>这就是之前介绍的模板方法设计模式。handle方法提供了如何进行工作处理的框架。不同的处理对象可以通过继承ProcessingObject类，提供handleWork方法来进行创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ProcessingObject&lt;T&gt; &#123; </span><br><span class="line">    protected ProcessingObject&lt;T&gt; successor; </span><br><span class="line">    public void setSuccessor(ProcessingObject&lt;T&gt; successor)&#123; </span><br><span class="line">        this.successor = successor; </span><br><span class="line">     &#125; </span><br><span class="line">    public T handle(T input)&#123; </span><br><span class="line">        T r = handleWork(input); </span><br><span class="line">        if(successor != null)&#123; </span><br><span class="line">            return successor.handle(r); </span><br><span class="line">        &#125; </span><br><span class="line">        return r; </span><br><span class="line">    &#125; </span><br><span class="line">    abstract protected T handleWork(T input); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HeaderTextProcessing extends ProcessingObject&lt;String&gt; &#123; </span><br><span class="line">    public String handleWork(String text)&#123; </span><br><span class="line">        return &quot;From Raoul, Mario and Alan: &quot; + text; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProcessingObject&lt;String&gt; p1 = new HeaderTextProcessing(); </span><br><span class="line">ProcessingObject&lt;String&gt; p2 = new SpellCheckerProcessing(); </span><br><span class="line">p1.setSuccessor(p2);</span><br><span class="line">String result = p1.handle(&quot;Aren&apos;t labdas really sexy?!!&quot;); </span><br><span class="line">System.out.println(result); </span><br><span class="line">//打印输出“From  Raoul,  Marioand Alan: Aren&apos;t lambdas reallysexy?!!”</span><br></pre></td></tr></table></figure><p>使用Lambda表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;String&gt; headerProcessing = </span><br><span class="line">    (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;</span><br><span class="line">UnaryOperator&lt;String&gt; spellCheckerProcessing = </span><br><span class="line">    (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);  </span><br><span class="line">Function&lt;String, String&gt; pipeline = </span><br><span class="line">    headerProcessing.andThen(spellCheckerProcessing);   </span><br><span class="line">String result = pipeline.apply(&quot;Aren&apos;t labdas really sexy?!!&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>使用工厂模式，你无需向客户暴露实例化的逻辑就能完成对象的创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ProductFactory &#123; </span><br><span class="line">    public static Product createProduct(String name)&#123; </span><br><span class="line">        switch(name)&#123; </span><br><span class="line">            case &quot;loan&quot;: return new Loan(); </span><br><span class="line">            case &quot;stock&quot;: return new Stock(); </span><br><span class="line">            case &quot;bond&quot;: return new Bond(); </span><br><span class="line">            default: throw new RuntimeException(&quot;No such product &quot; + name); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贷款（Loan）、股票（Stock）和债券（Bond）都是产品（Product）的子类。createProduct方法可以通过附加的逻辑来设置每个创建的产品。但是带来的好处也显而易见，你在创建对象时不用再担心会将构造函数或者配置暴露给客户，这使得客户创建产品时更加简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Product p = ProductFactory.createProduct(&quot;loan&quot;);</span><br></pre></td></tr></table></figure></p><p>使用Lambda表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final static Map&lt;String, Supplier&lt;Product&gt;&gt; map = new HashMap&lt;&gt;(); </span><br><span class="line">static &#123; </span><br><span class="line">    map.put(&quot;loan&quot;, Loan::new); </span><br><span class="line">    map.put(&quot;stock&quot;, Stock::new); </span><br><span class="line">    map.put(&quot;bond&quot;, Bond::new); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public static Product createProduct(String name)&#123; </span><br><span class="line">    Supplier&lt;Product&gt; p = map.get(name); </span><br><span class="line">    if(p != null) return p.get(); </span><br><span class="line">    throw new IllegalArgumentException(&quot;No such product &quot; + name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用Java8的各种特性更有效地改善代码质量&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>并行流【java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/30/%E5%B9%B6%E8%A1%8C%E6%B5%81%E3%80%90java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/04/30/并行流【java8实战】/</id>
    <published>2018-04-30T13:14:14.000Z</published>
    <updated>2018-04-30T13:36:50.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</p></blockquote><a id="more"></a><p>在Java7之前，并行处理数据集合非常麻烦</p><ul><li>第一，你得明确地把包含数据的数据结构分成若干子部分</li><li>第二，你要把每个子部分分配一个独立的线程</li><li>第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来</li></ul><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><p>可以通过对收集源调用parallelStream方法来把集合转换为并行流</p><p>对顺序流调用parallel方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static long parallelSum(long n) &#123; </span><br><span class="line">    return Stream.iterate(1L, i -&gt; i + 1) </span><br><span class="line">                 .limit(n) </span><br><span class="line">                 .parallel() </span><br><span class="line">                 .reduce(0L, Long::sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/parallel01.png" alt="并行归纳操作"></p><p>请注意，在现实中，对顺序流调用parallel方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个boolean标志，表示你想让调用parallel之后进行的所有操作都并行执行。类似地，你只需要对并行流调用sequential方法就可以把它变成顺序流。请注意，你可能以为把这两个方法结合起来，就可以更细化地控制在遍历流时哪些操作要并行执行，哪些要顺序执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream.parallel() </span><br><span class="line">      .filter(...) </span><br><span class="line">      .sequential() </span><br><span class="line">      .map(...) </span><br><span class="line">      .parallel() </span><br><span class="line">      .reduce();</span><br></pre></td></tr></table></figure></p><p><strong>但最后一次paraller或sequential调用会影响整个流水线。在本例中，流水线会并发执行，因为最后调用的是它</strong></p><p><strong>并行流内部使用了默认的ForkJoinPool</strong>，它默认的线程数量就是你的处理器数量</p><h2 id="高效使用并行流"><a href="#高效使用并行流" class="headerlink" title="高效使用并行流"></a>高效使用并行流</h2><ul><li>如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事</li><li>留意装箱。自动装箱和拆箱操作会大大降低性能。Java8中有原始类型流(IntStream、LongStream、DoubleStream)来避免这种操作，但凡有可能都应该用这些流</li><li>有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用limit可能会比单个有序流（比如数据源是一个List）更高效</li><li>还要考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。</li><li>对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。</li><li>要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率比LinkedList高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂方法创建的原始类型流也可以快速分解</li><li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。</li><li>还要考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升</li></ul><p>流的数据源和可分解性</p><table><thead><tr><th>源</th><th>可分解性</th></tr></thead><tbody><tr><td>ArrayList</td><td>极佳</td></tr><tr><td>LinkedList</td><td>差</td></tr><tr><td>IntStream.range</td><td>极佳</td></tr><tr><td>Stream.iterate</td><td>差</td></tr><tr><td>HashSet</td><td>好</td></tr><tr><td>TreeSet</td><td>好</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Optional【java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/30/Optional%E3%80%90java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/04/30/Optional【java8实战】/</id>
    <published>2018-04-30T10:42:41.000Z</published>
    <updated>2018-05-07T04:43:51.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Null References: The Billion Dollar Mistake</p></blockquote><a id="more"></a><h2 id="null带来的种种问题"><a href="#null带来的种种问题" class="headerlink" title="null带来的种种问题"></a>null带来的种种问题</h2><ul><li>它是错误之源<br>  NullPointerException是目前Java程序开发中最典型的异常</li><li>它会使你的代码膨胀<br>  它让你的代码充斥着深度嵌套的null检查，代码的可读性糟糕透顶</li><li>它自身是毫无意义的<br>  null自身没有任何的语义，尤其是，它代表的是在静态类型语言中以一种错误的方式对缺少变量值的建模</li><li>它破坏了Java的哲学<br>  Java一直试图避免让程序员意识到指针的存在，唯一的例外是：null指针</li><li>它在Java的类型系统上开了个口子<br>  null并不属于任何类型，这意味着它可以被赋值给任意引用类型的变量。这会导致问题,<br>  原因是当这个变量被传递到系统中的另一个部分后，你将无法获知这个null变量最初的赋值到底是什么类型。</li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><code>java.util.Optional&lt;T&gt;</code>是一个封装Optional值的类。变量存在时，Optional类只是对类简单封装；变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回。Optional.empty()方法是一个静态工厂方法，它返回Optional类的特定单一实例。</p><p>null引用和Optional.empty()区别？<br>从语义上，没区别；从实际使用中，如果你尝试解引用一个null，一定会触发NullPointerException，不过使用Optional.empty()就完全没事，它是Optional类的一个有效对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//人</span><br><span class="line">public class Person &#123; </span><br><span class="line">    private Optional&lt;Car&gt; car;  </span><br><span class="line">    public Optional&lt;Car&gt; getCar() &#123; return car; &#125; </span><br><span class="line">&#125;</span><br><span class="line">//车</span><br><span class="line">public class Car &#123; </span><br><span class="line">    private Optional&lt;Insurance&gt; insurance;  </span><br><span class="line">    public Optional&lt;Insurance&gt; getInsurance() &#123; return insurance; &#125; </span><br><span class="line">&#125; </span><br><span class="line">//保险公司 必须有名字</span><br><span class="line">public class Insurance &#123; </span><br><span class="line">    private String name;  </span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Optional对象"><a href="#创建Optional对象" class="headerlink" title="创建Optional对象"></a>创建Optional对象</h3><ol><li><p>声明一个空的Optional</p><pre><code>Optional&lt;Car&gt; optCar = Optional.empty();</code></pre></li><li><p>依据一个非空值创建Optional</p><pre><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></pre></li></ol><p>如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问car的属性值时才返回一个错误</p><ol start="3"><li><p>可接受null的Optional</p><pre><code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code></pre></li></ol><p>如果car是null，那么得到的Optional对象就是个空对象</p><h3 id="使用map从Optional对象中提取和转换值"><a href="#使用map从Optional对象中提取和转换值" class="headerlink" title="使用map从Optional对象中提取和转换值"></a>使用map从Optional对象中提取和转换值</h3><p>比如，你可能想要从insurance公司对象中提取公司的名称。提取名称之前，你需要检查insurance对象是否为null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = null; </span><br><span class="line">if(insurance != null)&#123; </span><br><span class="line">    name = insurance.getName(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance); </span><br><span class="line">Optional&lt;String&gt; name = optInsurance.map(Insurance::getName);</span><br></pre></td></tr></table></figure><p>可以把Optional对象看成一种特殊的集合数据，它至多包含一个元素。如果Optional包含一个值，那函数就将该值作为参数传递给map，对该值进行转换。如果Optional为空，就什么也不做。<br><img src="/images/optional01.png" alt="Stream和Optional的map方法对比"></p><h3 id="使用flatMap链接Optional对象"><a href="#使用flatMap链接Optional对象" class="headerlink" title="使用flatMap链接Optional对象"></a>使用flatMap链接Optional对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; optPerson = Optional.of(person); </span><br><span class="line">Optional&lt;String&gt; name = </span><br><span class="line">    optPerson.map(Person::getCar) </span><br><span class="line">             .map(Car::getInsurance) </span><br><span class="line">             .map(Insurance::getName);</span><br></pre></td></tr></table></figure><p>无法通过编译。optPerson是Optional<person>类型的变量，调用map方法没有问题。但getCar返回的是一个Optional<car>类型的对象，这以为着map操作的结果是一个Optional&lt;Optional<car>&gt;类型的对象。因此，它对getInsurance的调用是非法的。嵌套式Optional结构<br><img src="/images/optional02.png" alt="两层的optional对象"></car></car></person></p><p>该如何解决这个问题？flatMap方法。使用流时，<strong>flatMap方法接受一个函数作为参数，这个函数的返回值是另一个流。这个方法会应用到流中的每一个元素，最终形成一个新的流的流</strong>。但是flatMap会用流的内容替换每个新生存的流。换句话说，<strong>由方法生成的各个流会被合并或者扁平化为一个单一的流</strong>。<br><img src="/images/optional03.png" alt="Stream和Optional的flatMap方法对比"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getCarInsuranceName(Optional&lt;Person&gt; person) &#123; </span><br><span class="line">    return person.flatMap(Person::getCar) </span><br><span class="line">                 .flatMap(Car::getInsurance) </span><br><span class="line">                 .map(Insurance::getName) </span><br><span class="line">                 .orElse(&quot;Unknown&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/optional04.png" alt="使用Optional解引用串接的Person/Car/Insurance"></p><p><strong>Optional无法序列化</strong></p><blockquote><p>Java语言的架构师Brian Goetz曾经非常明确地陈述过，<strong>Optional的设计初衷仅仅是要支持能返回Optional对象的语法。</strong></p></blockquote><p>由于Optional类设计时就没特别考虑将其作为类的字段使用，所以它也并未实现Serializable接口。<br>如果你一定要实现序列化的域模型，可以使用下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123; </span><br><span class="line">    private Car car; </span><br><span class="line">    public Optional&lt;Car&gt; getCarAsOptional() &#123; </span><br><span class="line">        return Optional.ofNullable(car); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="默认行为及解引用Optional对象"><a href="#默认行为及解引用Optional对象" class="headerlink" title="默认行为及解引用Optional对象"></a>默认行为及解引用Optional对象</h3><p>Optional类提供了多种方法读取Optional实例中的变量值</p><ul><li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量值，否则就抛出一个NoSuchElementException异常</li><li>orElse(T other)。它允许你在Optional对象不包含值时提供一个默认值</li><li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作，你应该考虑采用这种方式（借此提升程序的性能），或者你需要非常确定某个方法仅在Optional为空时才进行调用，也可以考虑该方式（这种情况有严格的限制条件）。</li><li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似，它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希望抛出的异常类型。</li><li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的方法，否则就不进行任何操作</li></ul><h3 id="两个Optional对象的组合"><a href="#两个Optional对象的组合" class="headerlink" title="两个Optional对象的组合"></a>两个Optional对象的组合</h3><p>假设你有这样一个方法，它接受一个Person和一个Car对象，并以此为条件对外部提供的服务进行查询，通过一些复杂的业务逻辑，试图找到满足该组合的最便宜的保险公司</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Insurance findCheapestInsurance(Person person, Car car) &#123; </span><br><span class="line">    // 不同的保险公司提供的查询服务</span><br><span class="line">    // 对比所有数据</span><br><span class="line">    return cheapestCompany; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;Insurance&gt; nullSafeFindCheapestInsurance( Optional&lt;Person&gt; person, Optional&lt;Car&gt; car) &#123; </span><br><span class="line">    if (person.isPresent() &amp;&amp; car.isPresent()) &#123; </span><br><span class="line">        return Optional.of(findCheapestInsurance(person.get(), car.get())); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        return Optional.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的具体实现和之前曾经实现的null检查太相似了</p><p>可以像使用三元操作符那样，无需任何条件判断的结构，以一行语句实现该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;Insurance&gt; nullSafeFindCheapestInsurance( Optional&lt;Person&gt; person, Optional&lt;Car&gt; car) &#123; </span><br><span class="line">    return person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p, c))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用filter剔除特定的值"><a href="#使用filter剔除特定的值" class="headerlink" title="使用filter剔除特定的值"></a>使用filter剔除特定的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; optInsurance = ...; </span><br><span class="line">optInsurance.filter(insurance -&gt; </span><br><span class="line">                        &quot;CambridgeInsurance&quot;.equals(insurance.getName())) </span><br><span class="line">            .ifPresent(x -&gt; System.out.println(&quot;ok&quot;));</span><br></pre></td></tr></table></figure><h2 id="Optional类的方法"><a href="#Optional类的方法" class="headerlink" title="Optional类的方法"></a>Optional类的方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>empty</td><td>返回一个空的Optional实例</td></tr><tr><td>filter</td><td>如果值存在并且满足提供的谓词，就返回包含该值的Optional对象；否则返回一个空的Optional对象</td></tr><tr><td>map</td><td>如果值存在，就对该值执行提供的mapping函数调用</td></tr><tr><td>flatMap</td><td>如果值存在，就对该值执行提供的mapping函数调用，返回一个新的流</td></tr><tr><td>get</td><td>如果值存在，将该值用Optional封装返回，否则抛出一个NoSuchElementExcepiton异常</td></tr><tr><td>ifPresent</td><td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td>isPresent</td><td>如果值存在就返回true，否则返回false</td></tr><tr><td>of</td><td>将指定值用Optional封装之后返回，如果该值为null，则抛出一个NullPointerException异常</td></tr><tr><td>ofNullable</td><td>将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional对象</td></tr><tr><td>orElse</td><td>如果有值则将其返回，否则返回一个默认值</td></tr><tr><td>orElseGet</td><td>如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td>orElseThrow</td><td>如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><h3 id="用Optional封装可能为null的值"><a href="#用Optional封装可能为null的值" class="headerlink" title="用Optional封装可能为null的值"></a>用Optional封装可能为null的值</h3><pre><code>Optional&lt;Object&gt; value = Optional.ofNullable(map.get(&quot;key&quot;)); </code></pre><h3 id="异常与Optional的对比"><a href="#异常与Optional的对比" class="headerlink" title="异常与Optional的对比"></a>异常与Optional的对比</h3><p>由于某种原因，函数无法返回某个值，这时除了返回null，Java API比较常见的替代做法是抛出一个异常。这种情况比较典型的例子就是使用静态方法Integer.parseInt(String)，将String转换为int。如果String无法解析到对应的整型，该方法就抛出一个NumberFormatException。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Optional&lt;Integer&gt; stringToInt(String s) &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        return Optional.of(Integer.parseInt(s));  </span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        return Optional.empty();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以将多个类似的方法封装到一个工具类中，让我们称之为OptionalUtility。通过这种方式，你以后就能直接调用OptionalUtility.stringToInt方法，将String转换为一个Optional<integer>对象，而不再需要记得你在其中封装了笨拙的try/catch的逻辑了</integer></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>null引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失</li><li>Java8中引入了一个新的类java.util.Optional<t>，对存在或缺失的变量值进行建模</t></li><li>你可以使用静态工厂方法Optional.empty、Optional.of以及Optional.ofNullable创建Optional对象</li><li>Optional类支持多种方法，比如map、flagMap、filter，它们在概念上与Stream类中对应的方法十分相似</li><li>使用Optional会迫使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Null References: The Billion Dollar Mistake&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>流【Java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/30/%E6%B5%81%E3%80%90Java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/04/30/流【Java8实战】/</id>
    <published>2018-04-30T04:02:22.000Z</published>
    <updated>2018-05-02T06:44:25.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>流是Java API的新成员，它允许你<strong>以声明性方式处理数据集合</strong>（通过查询语句来表达，而不是临时编写一个实现）</p></blockquote><a id="more"></a><p>举个栗子🎂</p><p><img src="/images/stream01.png" alt=""></p><ul><li>代码是以声明性方式写的：说明想要完成什么而不是说明如何实现一个操作</li><li>可以把几个基础操作链接起来，来表达复杂的数据处理流水线，同时保持代码清晰可读</li></ul><p>Stream API:</p><ul><li>声明性——更简洁，更易读</li><li>可复合——更灵活</li><li>可并行——性能很好</li></ul><h2 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h2><p>简短的定义就是“<strong>从支持数据处理操作的源生成的元素序列</strong>”</p><ul><li>元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList与LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。<strong>集合讲的是数据，流讲的是计算</strong>。</li><li>源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li>数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行</li></ul><p>特点：</p><ul><li>流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li><li>内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p><img src="/images/stream02.png" alt="用流来筛选菜单，找出三个高热量菜肴的名字"></p><h2 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h2><p>集合与流之间的差异就在于什么时候进行计算。<strong>集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中</strong>。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）<br>相比之下，<strong>流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的</strong>。</p><p><img src="/images/stream03.png" alt=""></p><h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a>只能遍历一次</h3><p>请注意，和迭代器类似，<strong>流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了</strong>。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样</p><h3 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h3><p><strong>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了</strong>。</p><p>外部迭代一个集合，显式地取出每个项目再加以处理。内部迭代时，项目可以透明地并行处理，或者用更优化的顺序进行处理。要是用Java过去的那种外部迭代方法，这些优化都是很困难的。这似乎有点儿鸡蛋里挑骨头，但这差不多就是Java 8引入流的理由了——Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。与此相反，<strong>一旦通过写for-each而选择了外部迭代，那你基本上就要自己管理所有的并行问题了（自己管理实际上意味着“某个良辰吉日我们会把它并行化”或“开始了关于任务和synchronized的漫长而艰苦的斗争”）</strong>。Java  8需要一个类似于Collection却没有迭代器的接口，于是就有了Stream！<br><img src="/images/stream04.png" alt="内部迭代与外部迭代"></p><h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = menu.stream()      //获得流</span><br><span class="line">                         .filter(d -&gt; d.getCalories() &gt; 300)    //中间操作</span><br><span class="line">                         .map(Dish::getName)  </span><br><span class="line">                         .limit(3)  </span><br><span class="line">                         .collect(toList());    //将Stream转换为List</span><br></pre></td></tr></table></figure><ul><li>filter、map和limit可以连成一条流水线</li><li>collect触发流水线执行并关闭它</li></ul><p><strong>可以连接起来的操作称为中间操作，关闭流的操作称为终端操作</strong></p><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>诸如filter或sorted等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。<strong>重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理</strong>——它们很懒。这是因为<strong>中间操作一般都可以合并起来，在终端操作时一次性全部处理</strong>。<br><img src="/images/stream05.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filtering pork </span><br><span class="line">mapping pork </span><br><span class="line">filtering beef </span><br><span class="line">mapping beef </span><br><span class="line">filtering chicken </span><br><span class="line">mapping chicken </span><br><span class="line">[pork, beef, chicken]</span><br></pre></td></tr></table></figure><p>你会发现，有好几种优化利用了流的延迟性质。第一，尽管很多菜的热量都高于300卡路里，但只选出了前三个！这是因为limit操作和一种称为短路的技巧。第二，尽管filter和map是两个独立的操作，但它们合并到同一次遍历中了（我们把这种技术叫作循环合并）。</p><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p><strong>终端操作会从流的流水线生成结果</strong>。其结果是任何不是流的值，比如List、Integer，甚至void。例如，在下面的流水线中，forEach是一个返回void的终端操作，它会对源中的每道菜应用一个Lambda。把System.out.println传递给forEach，并要求它打印出由menu生成的流中的每一个Dish：<br>        menu.stream().forEach(System.out::println); </p><h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>流的使用一般包括三件事：</p><ul><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul><p><strong>流的流水线背后的理念类似于构建器模式。在构建器模式中有一个调用链用来设置一套配置（对流来说这就是一个中间操作链），接着是调用built方法（对流来说就是终端操作）</strong>。</p><p>中间操作：</p><table><thead><tr><th>操作</th><th>类型</th><th>返回类型</th><th>操作参数</th><th>函数描述符</th></tr></thead><tbody><tr><td>filter</td><td>中间</td><td>Stream&lt;T></td><td>Predicate&lt;T></td><td>T -&gt; boolean</td></tr><tr><td>map</td><td>中间</td><td>Stream&lt;T></td><td>Function&lt;T,R></td><td>T -&gt; R </td></tr><tr><td>limit</td><td>中间</td><td>Stream&lt;T></td><td></td><td></td></tr><tr><td>sorted</td><td>中间</td><td>Stream&lt;T></td><td>Comparator&lt;T></td><td>(T,T) -&gt; int </td></tr><tr><td>distinct</td><td>中间</td><td>Stream&lt;T></td><td></td><td></td></tr></tbody></table><p>终端操作：</p><table><thead><tr><th>操作</th><th>类型</th><th>目的</th></tr></thead><tbody><tr><td>forEach</td><td>终端</td><td>消费流中的每个元素并对其应用Lambda。这一操作返回void</td></tr><tr><td>count</td><td>终端</td><td>返回流中元素的个数。这一操作返回long</td></tr><tr><td>collect</td><td>终端</td><td>把流归约成一个集合，比如List、Map甚至是Integer</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>流是”从支持数据处理操作的源生成的一系列元素”</li><li>流利用内部迭代： 迭代通过filter、map、sorted等操作被抽象掉了</li><li>流操作有两类： 中间操作和终端操作</li><li>filter和map等中间操作费返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果</li><li>forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果</li><li>流中的元素是按需计算的</li></ul><hr><h2 id="使用流-1"><a href="#使用流-1" class="headerlink" title="使用流"></a>使用流</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><h4 id="使用谓词筛选"><a href="#使用谓词筛选" class="headerlink" title="使用谓词筛选"></a>使用谓词筛选</h4><p>Streams接口支持filter方法。该操作费接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream() </span><br><span class="line">                                .filter(Dish::isVegetarian)  //筛选出所有素菜</span><br><span class="line">                                .collect(toList());</span><br></pre></td></tr></table></figure></p><h3 id="筛选各异的元素"><a href="#筛选各异的元素" class="headerlink" title="筛选各异的元素"></a>筛选各异的元素</h3><p>流还支持一个叫做distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); </span><br><span class="line">numbers.stream()  </span><br><span class="line">       .filter(i -&gt; i % 2 == 0) </span><br><span class="line">       .distinct() </span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="截断流"><a href="#截断流" class="headerlink" title="截断流"></a>截断流</h3><p>流支持limit(n)方法，该方法会返回一个不超过给定长度的流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = menu.stream() </span><br><span class="line">                        .filter(d -&gt; d.getCalories() &gt; 300) </span><br><span class="line">                        .limit(3) </span><br><span class="line">                        .collect(toList());</span><br></pre></td></tr></table></figure></p><h3 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h3><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</p><hr><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>从某些对象中选择信息。（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新的版本”而不是去“修改”）</p><h3 id="对流中每一个元素应用函数"><a href="#对流中每一个元素应用函数" class="headerlink" title="对流中每一个元素应用函数"></a>对流中每一个元素应用函数</h3><p>流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; dishNames = menu.stream() </span><br><span class="line">                             .map(Dish::getName) </span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure></p><h3 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h3><p>对于一张单词表，如何返回一张列表，列出里面各不相同的字符呢？例如，给定单词列表[“Hello”,”World”]，你想要返回列表[“H”,”e”,”l”, “o”,”W”,”r”,”d”]。</p><p>你可能会认为这很容易，你可以把每个单词映射成一张字符表，然后调用distinct来过滤重复的字符。第一个版本可能是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words.stream() </span><br><span class="line">     .map(word -&gt; word.split(&quot;&quot;)) </span><br><span class="line">     .distinct() </span><br><span class="line">     .collect(toList());</span><br></pre></td></tr></table></figure></p><p>这个方法的问题在于，传递给map方法的Lambda为每个单词返回了一个String[]（String列表）  。因此，map返回的流实际上是Stream&lt;String[]&gt;类型的。<br><img src="/images/stream06.png" alt="不正确地使用map找出单词列表中各不相同的字符"></p><ol><li>尝试使用map和Arrays.stream()<br><strong>Arrays.stream()可以接受一个数组并产生一个流</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words.stream() </span><br><span class="line">     .map(word -&gt; word.split(&quot;&quot;)) </span><br><span class="line">     .map(Arrays::stream)</span><br><span class="line">     .distinct() </span><br><span class="line">     .collect(toList());</span><br></pre></td></tr></table></figure></li></ol><p>当前的解决方案仍然搞不定！这是因为，你现在得到的是一个流的列表（更准确地说是Stream<string>）！的确，你先是把每个单词转换成一个字母数组，然后把每个数组变成了一个独立的流。</string></p><ol start="2"><li>使用flatMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = </span><br><span class="line">    words.stream() </span><br><span class="line">         .map(w -&gt; w.split(&quot;&quot;)) </span><br><span class="line">         .flatMap(Arrays::stream)  </span><br><span class="line">         .distinct() </span><br><span class="line">         .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。</strong>所有使用map(Arrays::steam)时生成的单个流被合并起来，即扁平化为一个流。<br><img src="/images/stream07.png" alt=" 使用flatMap找出单词列表中各不相同的字符"></p><p>总而言之，<strong>flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</strong></p><hr><h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><h4 id="检查谓词是否至少匹配一个元素"><a href="#检查谓词是否至少匹配一个元素" class="headerlink" title="检查谓词是否至少匹配一个元素"></a>检查谓词是否至少匹配一个元素</h4><p><strong>anyMatch方法“流中是否有一个元素能匹配给定的谓词”</strong>。比如，你可以用它来看看菜单里面是否有素食可选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(menu.stream().anyMatch(Dish::isVegetarian))&#123; </span><br><span class="line">    System.out.println(&quot;The menu is (somewhat) vegetarian friendly!!&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="检查谓词是否匹配所有元素"><a href="#检查谓词是否匹配所有元素" class="headerlink" title="检查谓词是否匹配所有元素"></a>检查谓词是否匹配所有元素</h4><p>allMatch方法的工作原理和anyMatch类似，但它会看看<strong>流中的元素是否都能匹配给定的谓词</strong></p><h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p>和allMatch相对的是noneMatch。它可以确保<strong>流中没有任何元素与给定的谓词匹配。</strong></p><p>anyMatch、allMatch和noneMatch这三个操作都用到了我们所谓的短路，这就是大家熟悉的Java中&amp;&amp;和||运算符短路在流中的版本。</p><blockquote><p>短路求值<br>有些操作不需要处理整个流就能得到结果</p></blockquote><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>findAny方法将返回当前流中的任意元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; dish = </span><br><span class="line">    menu.stream() </span><br><span class="line">        .filter(Dish::isVegetarian) </span><br><span class="line">        .findAny();</span><br></pre></td></tr></table></figure></p><p><strong>Optional</strong></p><p><strong>Optional&lt;T>类（java.util.Optional）是一个容器类，代表一个值存在或不存在</strong></p><ul><li>isPresent()   将在Optional包含值的时候返回true，否则返回false</li><li>ifPresent(Consumer&lt;T> block) 会在值存在的时候执行给定的代码块</li><li>T get() 会在值存在时返回值，否则抛出一个NoSuchElement异常</li><li>T orElse(T other) 会在值存在时返回值，否则返回一个默认值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu.stream() </span><br><span class="line">    .filter(Dish::isVegetarian)  </span><br><span class="line">    .findAny() </span><br><span class="line">    .ifPresent(d -&gt; System.out.println(d.getName());</span><br></pre></td></tr></table></figure></li></ul><h4 id="查找第一个元素"><a href="#查找第一个元素" class="headerlink" title="查找第一个元素"></a>查找第一个元素</h4><p>findFirst</p><p>找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>将流中所有元素反复结合起来，得到一个值。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。</p><h4 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h4><pre><code>int sum = numbers.stream() . reduce(0, (a,b) -&gt; a+b);</code></pre><p>reduce 接受两个参数：</p><ul><li>一个初始值，这里是0；</li><li>一个BinaryOperator&lt;T>来将两个元素结合起来产生一个新值，这里我们用的是lambda(a,b) -&gt; a+b</li></ul><p><img src="/images/stream08.png" alt=" 使用reduce来对流中的数字求和"></p><p>在Java8中，Integer类现在有了一个静态的sum方法来对两个数求和</p><pre><code>int sum = numbers.stream().reduce(0, Integer::sum); </code></pre><p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p><pre><code>Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b)); </code></pre><p>为什么它返回一个Optional<integer>呢？考虑流中没有任何元素的情况。reduce操作无法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在</integer></p><h4 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h4><pre><code>Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max); </code></pre><p><img src="/images/stream09.png" alt="一个归约操作——计算最大值"></p><h3 id="无状态和有状态"><a href="#无状态和有状态" class="headerlink" title="无状态和有状态"></a>无状态和有状态</h3><p>诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果，这些操作一般都是<strong>无状态的：它们没有内部状态</strong></p><p>但诸如reduce、sum、max等操作需要内部状态来积累结果，不管流中有多少元素要处理，内部状态都是有界的</p><p>相反，诸如sort或distinct等操作一开始都和filter和map差不多——都是接受一个流，再生成一个流，但有一个关键的区别：从流中排序和删除重复项时都需要知道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操作的存储要求是无界的。要是流比较大或是无限的，就可能会有问题（把质数流倒序会做什么呢？它应当返回最大的质数，但数学告诉我们它不存在）。我们把这些操作叫作有状态操作</p><p>中间操作和终端操作</p><table><thead><tr><th>操作</th><th>类型</th><th>返回类型</th><th>使用的类型/函数式接口</th><th>函数描述符</th></tr></thead><tbody><tr><td>filter</td><td>中间</td><td>Stream&lt;T></td><td>Predicate&lt;T></td><td>T -&gt; boolean</td></tr><tr><td>distinct</td><td>中间<br> (有状态-无界)</td><td>Stream&lt;T></td><td></td><td></td></tr><tr><td>skip</td><td>中间<br>(有状态-有界)</td><td>Stream&lt;T></td><td>long</td><td></td></tr><tr><td>limit</td><td>中间<br>(有状态-有界)</td><td>Stream&lt;T></td><td>long</td><td></td></tr><tr><td>map</td><td>中间</td><td>Stream&lt;T></td><td>Function&lt;T,R></td><td>T -&gt; R </td></tr><tr><td>flatMap</td><td>中间</td><td>Stream&lt;T></td><td>Function&lt;T,R></td><td>T -&gt; Stream&lt;R> </td></tr><tr><td>sorted</td><td>中间<br>(有状态-无界)</td><td>Stream&lt;T></td><td>Comparator<t></t></td><td>(T,T) -&gt; int </td></tr><tr><td>anyMatch</td><td>终端</td><td>boolean</td><td>Predicate&lt;T></td><td>T -&gt; boolean</td></tr><tr><td>noneMatch</td><td>终端</td><td>boolean</td><td>Predicate&lt;T></td><td>T -&gt; boolean</td></tr><tr><td>allMatch</td><td>终端</td><td>boolean</td><td>Predicate&lt;T></td><td>T -&gt; boolean</td></tr><tr><td>findAny</td><td>终端</td><td>Optional&lt;T></td><td></td><td></td></tr><tr><td>findFirst</td><td>终端</td><td>Optional&lt;T></td><td></td><td></td></tr><tr><td>forEach</td><td>终端</td><td>void</td><td>Consumer&lt;T></td><td>T -&gt; void</td></tr><tr><td>collect</td><td>终端</td><td>R</td><td>Collector&lt;T,A,R></td><td></td></tr><tr><td>reduce</td><td>终端<br>(有状态-有界)</td><td>Optional&lt;T></td><td>BinaryOperator&lt;T></td><td>(T,T) -&gt; T</td></tr><tr><td>count</td><td>终端</td><td>long</td><td></td><td></td></tr></tbody></table><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java8引入了三个原始类型特化流接口：InputStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到最大元素的max，求平均值average等。</p><p><strong>映射到数值流</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                           .mapToInt(Dish::getCalories)  </span><br><span class="line">                           .sum();</span><br></pre></td></tr></table></figure></p><p><strong>转换回对象流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">//每个int都会装箱成一个Integer </span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure><p><strong>默认值OptionalInt</strong><br>求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算IntStream中的最大元素，就得换个法子了，因为0是错误的结果。如何区分没有元素的流和最大值真的是0的流呢？前面我们介绍了Optional类，这是一个可以表示值存在或不存在的容器。Optional可以用Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt maxCalories = menu.stream() </span><br><span class="line">                              .mapToInt(Dish::getCalories) </span><br><span class="line">                              .max();</span><br></pre></td></tr></table></figure></p><p>现在，如果没有最大值的话，你就可以显式处理OptionalInt去定义一个默认值了：</p><pre><code>int max = maxCalories.orElse(1);  </code></pre><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>和数字打交道时，有一个常用的东西就是数值范围。比如，假设你想要生成1和100之间的所有数字。Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream evenNumbers = IntStream.rangeClosed(1, 100)</span><br><span class="line">                                 .filter(n -&gt; n % 2 == 0);</span><br><span class="line">System.out.println(evenNumbers.count());</span><br></pre></td></tr></table></figure></p><h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>可以使用静态方法Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;); </span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//使用empty得到一个空流</span><br><span class="line">Stream&lt;String&gt; emptyStream =  Stream.empty();</span><br></pre></td></tr></table></figure></p><h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><p>可以使用静态方法Arrays.stream从数组创建一个流。它接受一个数组作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] numbers = &#123;2, 3, 5, 7, 11, 13&#125;; </span><br><span class="line">int sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure></p><h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>Java中用于处理文件等I/O操作的NIO  API（非阻塞  I/O）已更新，以便利用Stream  API。java.nio.file.Files中的很多静态方Files.lines，它会返回一个由指定文件中的各行构成的字符串流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long uniqueWords = 0; </span><br><span class="line">try(Stream&lt;String&gt; lines = </span><br><span class="line">          Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset()))&#123; </span><br><span class="line">uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;)))</span><br><span class="line">                   .distinct() </span><br><span class="line">                   .count(); </span><br><span class="line">&#125;  </span><br><span class="line">catch(IOException e)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！一般来说，应该使用limit(n)来对这种流加以限制，以避免打印无穷多个值。</p><p><strong>迭代</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(0, n -&gt; n + 2) </span><br><span class="line">      .limit(10) </span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>iterate方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。这种iterate操作基本上是顺序的，因为结果取决于前一次应用。请注意，此操作将生成一个无限流——这个流没有结尾，因为值是按需计算的，可以永远计算下去。我们说这个流是无界的。正如我们前面所讨论的，这是流和集合之间的一个关键区别。</p><p><strong>生成</strong></p><p>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数的。它接受一个Supplier<t>类型的Lambda提供新的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random) </span><br><span class="line">      .limit(5) </span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure></t></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>Streams API可以表达复杂的数据处理查询。</li><li>你可以使用filter、distinct、skip和limit对流做筛选和切片。</li><li>你可以使用map和flatMap提取或转换流中的元素。</li><li>你可以使用findFirst和findAny方法查找流中的元素。你可以用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词。</li><li>这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流。</li><li>你可以利用reduce方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。</li><li>filter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。</li><li>流有三种基本的原始类型特化：IntStream、DoubleStream和LongStream。它们的操作也有相应的特化。</li><li>流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法创建。</li><li>无限流是没有固定大小的流。</li></ul><hr><h2 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h2><p>举个栗子🎂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//对交易按照货币分组</span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = </span><br><span class="line">        transactions.stream().collect(groupingBy(Transaction::getCurrency));</span><br></pre></td></tr></table></figure></p><p>函数式编程相对于指令式编程的一个主要优势：<strong>你只需要指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做”</strong>。在上一个例子里，传递给collect方法的参数是Collector接口的一个实现</p><p>对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）</p><p>Collector接口中方法的实现决定了如何对流执行归约操作；Collectors类提供了很多静态工厂方法，可以方便地创建常见收集器实例</p><h4 id="归约与汇总"><a href="#归约与汇总" class="headerlink" title="归约与汇总"></a>归约与汇总</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import static java.util.stream.Collectors.*; </span><br><span class="line">long howManyDishes = menu.stream().collect(counting()); </span><br><span class="line">//或者</span><br><span class="line">long howManyDishes = menu.stream().count();</span><br></pre></td></tr></table></figure><h4 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h4><p>Collectors.maxBy和Collectors.minBy，来计算流中的最大或最小值。这两个收集器接收一个Comparator参数来比较流中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = </span><br><span class="line">    Comparator.comparingInt(Dish::getCalories); </span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish = </span><br><span class="line">    menu.stream() </span><br><span class="line">        .collect(maxBy(dishCaloriesComparator));</span><br></pre></td></tr></table></figure><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器</p><pre><code>int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</code></pre><p>Collectors.summingLong和Collectors.summingDouble方法的作用完全一样，可以用于求和字段为long或double的情况<br><img src="/images/stream10.png" alt="summingInt收集器的累积过程"></p><p>汇总不仅仅是求和；还有Collectors.averagingInt，连同对应的averagingLong和averagingDouble可以计算数值的平均数</p><p>你可能想要得到两个或更多这样的结果，而且你希望只需一次操作就可以完成。在这种情况下，你可以使用summarizingInt工厂方法返回的收集器。例如，通过一次summarizing操作你可以就数出菜单中元素的个数，并得到菜肴热量总和、平均值、最大值和最小值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics = </span><br><span class="line">        menu.stream().collect(summarizingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure></p><p>这个收集器会把所有这些信息收集到一个叫作IntSummaryStatistics的类里，它提供了方便的取值（getter）方法来访问结果。打印menuStatisticobject会得到以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics&#123;count=9, sum=4300, min=120, </span><br><span class="line">                     average=477.777778, max=800&#125;</span><br></pre></td></tr></table></figure></p><p>同样，相应的summarizingLong和summarizingDouble工厂方法有相关的LongSummary- Statistics和DoubleSummaryStatistics类型，适用于收集的属性是原始类型long或double的情况。</p><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串，joining在内部使用了StringBuilder来把生成的字符串逐个追加起来</p><pre><code>String shortMenu = menu.stream().map(Dish::getName).collect(joining()); </code></pre><p>joining工厂方法有一个重载版本可以接受元素之间的分界符</p><pre><code>String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;); </code></pre><h4 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h4><p>事实上，我们已经讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。Collectors.reducing工厂方法是所有这些特殊情况的一般化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int totalCalories = menu.stream().collect(reducing( </span><br><span class="line">                                   0, Dish::getCalories, (i, j) -&gt; i + j));</span><br></pre></td></tr></table></figure></p><p>它需要三个参数。</p><ul><li>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。</li><li>第二个参数就是将菜肴转换成一个表示其所含热量的int。</li><li>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。</li></ul><p>同样，你可以使用下面这样单参数形式的reducing来找到热量最高的菜<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; mostCalorieDish = </span><br><span class="line">    menu.stream().collect(reducing( </span><br><span class="line">        (d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</span><br></pre></td></tr></table></figure></p><p>你可以把单参数reducing工厂方法创建的收集器看作三参数方法的特殊情况，它把流中的第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。这也意味着，要是把单参数reducing收集器传递给空流的collect方法，收集器就没有起点；它将因此而返回一个Optional<dish>对象。</dish></p><p><strong>reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约；于此相反，collect方法的设计就是要改变容器，从而累积要输出的结果</strong></p><p><img src="/images/stream11.png" alt=""></p><p><img src="/images/stream12.png" alt="计算菜单总热量的归约过程"></p><p><strong>reducing接受的参数是一个BinaryOperator&lt;t>，也就是一个BiFunction&lt;T,T,T>。这就意味着它需要的函数必须能接受两个参数，然后返回一个相同类型的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//就实际应用而言，不管是从可读性还是性能方面考虑，我们始终建议使用joining收集器。</span><br><span class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining());</span><br><span class="line"></span><br><span class="line">String shortMenu = menu.stream().map(Dish::getName)</span><br><span class="line">                                .collect( reducing     ( (s1, s2) -&gt; s1 + s2 ) ).get();</span><br><span class="line"></span><br><span class="line">String shortMenu = menu.stream()</span><br><span class="line">                                 .collect( reducing( &quot;&quot;,Dish::getName, (s1, s2) -&gt; s1 + s2 ) ); </span><br><span class="line"></span><br><span class="line">//无法编译，这里用的Lambda表达式接受的参数是两个菜，返回的却是一个字符串。</span><br><span class="line">String shortMenu = menu.stream()</span><br><span class="line">    .collect( reducing( (d1, d2) -&gt; d1.getName() + d2.getName() ) ).get();</span><br></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = </span><br><span class="line">                      menu.stream().collect(groupingBy(Dish::getType));</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">&#123;FISH=[prawns, salmon], OTHER=[french fries, rice, season fruit, pizza],  </span><br><span class="line">MEAT=[pork, beef, chicken]&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/stream13.png" alt="分组过程中对流中的项目进行分类"></p><p>分类函数不一定像方法引用那样可用，因为你想用以分类的条件可能比简单的属性访问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum CaloricLevel &#123; DIET, NORMAL, FAT &#125; </span><br><span class="line"></span><br><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect( </span><br><span class="line">        groupingBy(dish -&gt; &#123; </span><br><span class="line">               if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; </span><br><span class="line">               else if (dish.getCalories() &lt;= 700) return </span><br><span class="line">    CaloricLevel.NORMAL; </span><br><span class="line">        else return CaloricLevel.FAT; </span><br><span class="line">         &#125; ));</span><br></pre></td></tr></table></figure></p><h4 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h4><p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = </span><br><span class="line">menu.stream().collect( </span><br><span class="line">      groupingBy(Dish::getType,  </span><br><span class="line">         groupingBy(dish -&gt; &#123;  </span><br><span class="line">            if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; </span><br><span class="line">                else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;</span><br><span class="line">            else return CaloricLevel.FAT; </span><br><span class="line">          &#125; ) </span><br><span class="line">      ) </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line">&#123;MEAT=&#123;DIET=[chicken], NORMAL=[beef], FAT=[pork]&#125;,  </span><br><span class="line"> FISH=&#123;DIET=[prawns], NORMAL=[salmon]&#125;, </span><br><span class="line"> OTHER=&#123;DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/stream14.png" alt="n层嵌套映射和n维分类表之间的等价关系"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区是分组的特殊情况：<strong>由一个谓词（返回一个布尔值的函数）作为分类函数</strong>，称为分区函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = </span><br><span class="line">             menu.stream().collect(partioningBy(Dish::isVegetarian));</span><br></pre></td></tr></table></figure><h2 id="Collectors类的静态工厂方法"><a href="#Collectors类的静态工厂方法" class="headerlink" title="Collectors类的静态工厂方法"></a>Collectors类的静态工厂方法</h2><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>用于</th><th>使用示例</th></tr></thead><tbody><tr><td>toList</td><td>List<t></t></td><td>把流中所有项目收集到一个List</td><td>List<dish> dishes = menuStream.collect(toList());</dish></td></tr><tr><td>toSet</td><td>Set<t></t></td><td>把流中所有项目收集到一个Set，删除重复项</td><td>Set<dish> dishes = menuStream.collect(toSet());</dish></td></tr><tr><td>toCollection</td><td>Collection<t></t></td><td>把流中所有项目收集到给定的供应源创建的集合</td><td>Collection<dish> dishes = menuStream.collect(toCollection(), ArrayList::new); </dish></td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td><td>long howManyDishes = menuStream.collect(counting());</td></tr><tr><td>summingInt</td><td>Integer</td><td>对流中项目的一个整数属性求和</td><td>int totalCalories = menuStream.collect(summingInt(Dish::getCalories));</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中项目Integer属性的平均值</td><td>double avgCalories = menuStream.collect(averagingInt(Dish::getCalories))</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>收集关于流中项目Integer属性的统计值，例如最大、最小、总和与平均值</td><td>IntSummaryStatistics menuStatistics =  menuStream.collect(summarizingInt(Dish::getCalories));</td></tr><tr><td>joining</td><td>String</td><td>连接对流中每个项目调用toString方法所生成的字符串</td><td>String shortMenu =  menuStream.map(Dish::getName).collect(joining(“, “));</td></tr><tr><td>maxBy</td><td>Optional<t></t></td><td>一个包裹了流中按照给定比较器选出的最大元素的Optional，或如果流为空则为Optional.empty()</td><td>Optional<dish> fattest =  menuStream.collect(maxBy(comparingInt(Dish::getCalories)));</dish></td></tr><tr><td>minBy</td><td>Optional<t></t></td><td>一个包裹了流中按照给定比较器选出的最小元素的Optional，或如果流为空则为Optional.empty()</td><td>Optional<dish> lightest =  menuStream.collect(minBy(comparingInt(Dish::getCalories)));</dish></td></tr><tr><td>reducing</td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始，利用BinaryOperator与流中的元素逐个结合，从而将流归约为单个值</td><td>int totalCalories =   menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果应用转换函数</td><td>int howManyDishes =  menuStream.collect(collectingAndThen(toList(), List::size));</td></tr><tr><td>groupingBy</td><td>Map&lt;K, List<t>&gt;</t></td><td>根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果Map的键</td><td>Map&lt;Dish.Type,List<dish>&gt; dishesByType =  menuStream.collect(groupingBy(Dish::getType));</dish></td></tr><tr><td>partitioningBy</td><td>Map&lt;Boolean,List<t>&gt;</t></td><td>根据对流中每个项目应用谓词的结果来对项目进行分区</td><td>Map&lt;Boolean,List<dish>&gt; vegetarianDishes =  menuStream.collect(partitioningBy(Dish::isVegetarian));</dish></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;流是Java API的新成员，它允许你&lt;strong&gt;以声明性方式处理数据集合&lt;/strong&gt;（通过查询语句来表达，而不是临时编写一个实现）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式【Java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/29/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%90Java8%E5%AE%9E%E6%88%98%E3%80%91/"/>
    <id>https://hsb786.github.io/2018/04/29/Lambda表达式【Java8实战】/</id>
    <published>2018-04-29T05:53:37.000Z</published>
    <updated>2018-05-07T04:52:50.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。</p></blockquote><a id="more"></a><ul><li>匿名——它不像普通的方法那样有一个明确的名称</li><li>函数——Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表</li><li>传递——Lambda表达式可以作为参数传递给方法或存储在变量中</li><li>简洁——无需像匿名类那样写很多模块代码</li></ul><p>Lambda表达式有三个部分：</p><ul><li>参数列表</li><li>箭头</li><li>Lambda主体</li></ul><p>基本语法：</p><ul><li>(parameters) -&gt;  expression</li><li>(parameters) -&gt;   { statements; }</li></ul><ul><li>() -&gt; “Raoul”</li><li>() -&gt; { return “Raoul”; }<br>Lambda隐含return，你也可以显式返回语句</li></ul><p>Lambda实例：</p><table><thead><tr><th>使用案例</th><th>Lambda实例</th></tr></thead><tbody><tr><td>布尔表达式</td><td>(List<string> list) -&gt; list.isEmpty()</string></td></tr><tr><td>创建对象</td><td>() -&gt; new Apple(10)</td></tr><tr><td>消费一个对象</td><td>(Apple a) -&gt; {  System.out.println(a.getWeight());  }</td></tr><tr><td>从一个对象中选择/抽取</td><td>(String s) -&gt; s.length()</td></tr><tr><td>组合两个值</td><td>(int a,int b) -&gt; a*b</td></tr><tr><td>比较两个对象</td><td>(Apple a2,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</td></tr></tbody></table><p><strong>可以在函数式接口上使用Lambda表达式</strong></p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>函数式接口就是只定义了一个抽象方法的接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//java.util.Comparator</span><br><span class="line">public interface Comparator&lt;T&gt; &#123; </span><br><span class="line">    int compare(T o1, T o2);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//java.lang.Runnable</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">    void run(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口一个具体实现的实例）</strong>。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用Lambda</span><br><span class="line">Runnable r1 = () -&gt; System.out.println(&quot;Hello World 1&quot;);</span><br><span class="line"></span><br><span class="line">//使用匿名类</span><br><span class="line">Runnable r2 = new Runnable()&#123;  </span><br><span class="line">    public void run()&#123; </span><br><span class="line">        System.out.println(&quot;Hello World 2&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p><strong>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，我们将这种抽象方法叫做函数描述符。</strong>例如，Runnable接口可以看作一个什么也不接受什么也不返回（void）的函数的签名，因为它只有一个叫作run的抽象方法，这个方法什么也不接受，什么也不返回。</p><p><strong>Lambda表达式可以被赋给一个变量，或传递给一个接受函数式接口作为参数的方法</strong></p><p>@FunctionalInterface<br>用于表示该接口会设计成一个函数式接口。</p><h3 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h3><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p><strong>java.util.function.Predicate<t>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。</t></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; </span><br><span class="line">    List&lt;T&gt; results = new ArrayList&lt;&gt;(); </span><br><span class="line">    for(T s: list)&#123; </span><br><span class="line">        if(p.test(s))&#123; </span><br><span class="line">            results.add(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return results; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty(); </span><br><span class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings,nonEmptyStringPredicate);</span><br></pre></td></tr></table></figure><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p><strong>java.util.function.Consumer<t>定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）</t></strong>。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface Consumer&lt;T&gt;&#123; </span><br><span class="line">    void accept(T t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123; </span><br><span class="line">        for(T i: list)&#123; </span><br><span class="line">        c.accept(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">forEach( Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.println(i) );</span><br></pre></td></tr></table></figure><h4 id="java-util-function-Function-lt-T-R-gt"><a href="#java-util-function-Function-lt-T-R-gt" class="headerlink" title="java.util.function.Function&lt;T, R&gt;"></a>java.util.function.Function&lt;T, R&gt;</h4><p><strong>接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象</strong>。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface Function&lt;T, R&gt;&#123; </span><br><span class="line">    R apply(T t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, </span><br><span class="line">                                 Function&lt;T, R&gt; f) &#123; </span><br><span class="line">    List&lt;R&gt; result = new ArrayList&lt;&gt;(); </span><br><span class="line">    for(T s: list)&#123; </span><br><span class="line">        result.add(f.apply(s)); </span><br><span class="line">    &#125; </span><br><span class="line">    return result; </span><br><span class="line">&#125; </span><br><span class="line">// [7, 2, 6] </span><br><span class="line">List&lt;Integer&gt; l = map( </span><br><span class="line">                       Arrays.asList(&quot;lambdas&quot;,&quot;in&quot;,&quot;action&quot;), </span><br><span class="line">                       (String s) -&gt; s.length() </span><br><span class="line">               );</span><br></pre></td></tr></table></figure><p>Lambdas及函数式接口的例子：</p><table><thead><tr><th>使用案例</th><th>Lambda实例</th><th>对应的函数式接口</th></tr></thead><tbody><tr><td>布尔表达式</td><td>(List<string> list) -&gt; list.isEmpty()</string></td><td>Predicate&lt;List<string>&gt;</string></td></tr><tr><td>创建对象</td><td>() -&gt; new Apple(10)</td><td>Supplier<apple></apple></td></tr><tr><td>消费一个对象</td><td>(Apple a) -&gt; {  System.out.println(a.getWeight());  }</td><td>Consumer<apple></apple></td></tr><tr><td>从一个对象中选择/抽取</td><td>(String s) -&gt; s.length()</td><td>Function&lt;String,Integer&gt;或ToIntFunction<string></string></td></tr><tr><td>组合两个值</td><td>(int a,int b) -&gt; a*b</td><td>IntBinaryOperator</td></tr><tr><td>比较两个对象</td><td>(Apple a2,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</td><td>Comparator<apple>或BiFunction&lt;Apple, Apple, Integer&gt;或ToIntBiFunction&lt;Apple, Apple&gt; </apple></td></tr></tbody></table><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>请注意，任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要Lambda表达式来抛出异常，有两种办法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda包在一个try/catch块中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface BufferedReaderProcessor &#123; </span><br><span class="line">    String process(BufferedReader b) throws IOException; </span><br><span class="line">&#125; </span><br><span class="line">BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        return b.readLine(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch(IOException e) &#123; </span><br><span class="line">        throw new RuntimeException(e); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p><strong>Lambda表达式本身并不包含它在实现哪个函数式接口的信息。</strong></p><p>Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型</p><p><img src="/images/lambda01.png" alt=""></p><ul><li>首先，你要找出filter方法的声明。</li><li>第二，要求它是Predicate<apple>（目标类型）对象的第二个正式参数。</apple></li><li>第三，Predicate<apple>是一个函数式接口，定义了一个叫作test的抽象方法。</apple></li><li>第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean。</li><li>最后，filter的任何实际参数都必须匹配这个要求。</li></ul><h3 id="同样的Lambda，不同的函数式接口"><a href="#同样的Lambda，不同的函数式接口" class="headerlink" title="同样的Lambda，不同的函数式接口"></a>同样的Lambda，不同的函数式接口</h3><p>有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。比如，前面提到的Callable和PrivilegedAction，这两个接口都代表着什么也不接受且返回一个泛型T的函数。因此，下面两个赋值是有效的：</p><pre><code>Callable&lt;Integer&gt; c = () -&gt; 42; PrivilegedAction&lt;Integer&gt; p = () -&gt; 42; </code></pre><p>第一个赋值的目标类型是Callable<integer>，第二个赋值的目标类型是PrivilegedAction<integer></integer></integer></p><p>菱形运算符<br>Java 7中已经引入了菱形运算符（&lt;&gt;），利用泛型推断从上下文推断类型的思想（这一思想甚至可以追溯到更早的泛型方法）。一个类实例表达式可以出现在两个或更多不同的上下文中，并会像下面这样推断出适当的类型参数：<br>        List&lt;String> listOfStrings = new ArrayList&lt;&gt;();<br>        List&lt;Integer> listOfIntegers = new ArrayList&lt;&gt;(); </p><p>特殊的void兼容规则<br>如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -&gt; void）所要求的void：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Predicate返回了一个boolean </span><br><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s); </span><br><span class="line">// Consumer返回了一个void  </span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure></p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Java编译器会从上下文（目标类型）推断出用什么函数式接来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。换句话说，Java编译器会像下面这样推断Lambda的参数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//参数a没有显式类型</span><br><span class="line">List&lt;Apple&gt; greenApples = </span><br><span class="line">     filter(inventory, a -&gt; &quot;green&quot;.equals(a.getColor())); </span><br><span class="line"></span><br><span class="line">//没有类型推断</span><br><span class="line">Comparator&lt;Apple&gt; c = </span><br><span class="line">    (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); </span><br><span class="line"></span><br><span class="line">//有类型推断</span><br><span class="line">Comparator&lt;Apple&gt; c = </span><br><span class="line">    (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure><h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><p>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><strong>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。</strong></p><p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，<strong>而不是去描述如何调用它</strong>。<strong>事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。</strong>但是，显式地指明方法的名称，你的代码的可读性会更好。它是如何工作的呢？当你需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。例如，<strong>Apple::getWeight就是引用了Apple类中定义的方法getWeight。请记住，不需要括号，因为你没有实际调用这个方法。</strong>方法引用就是Lambda表达式(Apple a) -&gt; a.getWeight()的快捷写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; str = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;A&quot;,&quot;B&quot;); </span><br><span class="line">str.sort((s1, s2) -&gt; s1.compareToIgnoreCase(s2));</span><br></pre></td></tr></table></figure><p>Lambda表达式的签名与Comparator的函数描述符兼容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; str = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;A&quot;,&quot;B&quot;); </span><br><span class="line">str.sort(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure></p><h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。例如，假设有一个构造函数没有参数。它适合Supplier的签名() -&gt; Apple。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::new; </span><br><span class="line">Apple a1 = c1.get(); </span><br><span class="line">//等价于</span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; new Apple(); </span><br><span class="line">Apple a1 = c1.get();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c2 = Apple::new;</span><br><span class="line">Apple a2 = c2.apply(110);</span><br><span class="line">//等价于</span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = (weight) -&gt; new Apple(weight);</span><br><span class="line">Apple a2 = c2.apply(110);</span><br></pre></td></tr></table></figure><p>Comparator具有一个叫作comparing的静态辅助方法，它可以接受一个Function来提取Comparable键值，并生成一个Comparator对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); </span><br><span class="line"></span><br><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a) -&gt; a.getWeight()); </span><br><span class="line"></span><br><span class="line">import static java.util.Comparator.comparing; </span><br><span class="line">inventory.sort(comparing((a) -&gt; a.getWeight()));</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表</li><li>Lambda表达式让你可以简洁地传递代码</li><li>函数式接口就是仅仅声明了一个抽象方法的接口</li><li>只有在接受函数式接口的地方才可以使用Lambda表达式</li><li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例</li><li>Java8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate<t>、Function&lt;T,R&gt;、Supplier<t>、Consumer<t>和BinaryOperator<t></t></t></t></t></li><li>为了避免装箱操作，对Predicate<t>和Function&lt;T,R&gt;等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等</t></li><li>Lambda表达式所需要代表的类型称为目标类型</li><li>方法引用让你重复使用现有的方法实现并直接传递它们</li><li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认返回</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>行为参数化【java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/29/java8%E5%AE%9E%E6%88%98-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://hsb786.github.io/2018/04/29/java8实战-行为参数化/</id>
    <published>2018-04-29T04:20:25.000Z</published>
    <updated>2018-04-29T13:31:52.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>行为参数化是指一个方法的功能，部分或全部由传递给这个方法的某个或多个参数决定，但这些参数不是一般意义上的值（一个字符串或数字），<strong>它代表了一个具体的行为，其本质是代码传递</strong>，表现可能有多种：对象、匿名类、java8里的Lambda表达式（或方法引用）等。</p></blockquote><a id="more"></a><h2 id="为什么需要行为参数化？"><a href="#为什么需要行为参数化？" class="headerlink" title="为什么需要行为参数化？"></a>为什么需要行为参数化？</h2><p>以前做外包项目的时候，似乎永远不知道客户会在什么时候提出新需求或需求变更，如果没有行为参数化或类似行为参数化的东西，客户的需求小有改动可能会带来代码上较大的变动，或为了一个小的新需求复制粘贴好几个类或方法，但行为参数化对于某些需求的变化或新增可以做到以不变应万变。</p><hr><p>question: <strong>农民需要筛选苹果，可能通过颜色，可能通过重量，也可能通过其它属性。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</span><br><span class="line">    List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</span><br><span class="line">    for (Apple apple: inventory)&#123;</span><br><span class="line">        //flag标志用于区分是颜色筛选还是重量筛选</span><br><span class="line">        if ( (flag &amp;&amp; apple.getColor().equals(color)) ||(!flag &amp;&amp; apple.getWeight() &gt; weight) )&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法看起来很糟糕，不易理解，而且无法满足农民可能提出的更多过滤需要，比如大小、形状、产地，更不用说可能出现的组合筛选需求了。因此需要作出改变，既不想每一个过滤需求都写一个对应的过滤方法，又不想写一个巨大而糟糕的方法来实现多个筛选需求，怎么办？</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>上一个例子在过滤时传递的是具体的值（值传递），如string类型的颜色、int类型的重量、boolean，代表的只是苹果的一个属性或状态，更糟糕的它们可能会有无数个组合，每个组合都对应了一个新需求，我们是无法单纯地靠值传递来设计出优雅的过滤方法的!</p><p>由于每一次筛选都是一个具体的行为，行为决定了过滤的结果,那直接将行为传递至过滤方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*对筛选标准建立模型</span><br><span class="line">*/</span><br><span class="line">public interface ApplePredicate&#123;</span><br><span class="line">    //test方法决定了apple是否满足我们的筛选条件</span><br><span class="line">    boolean test (Apple apple);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*代表了选出较重苹果的这一行为</span><br><span class="line">*/</span><br><span class="line">public class AppleHeavyWeightPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return apple.getWeight() &gt; 150;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*代表了选出绿色苹果这一行为</span><br><span class="line">*/</span><br><span class="line">public class AppleGreenColorPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;green&quot;.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了“策略模式”，定义一族算法，把它们封装起来，然后再运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为作为参数，并在内部使用，来完成不同的行为</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory,ApplePredicate p)&#123;</span><br><span class="line">    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for(Apple apple: inventory)&#123;</span><br><span class="line">        //ApplePredicate对象封装了测试苹果的条件</span><br><span class="line">        //满足条件即是我们需要选出的结果</span><br><span class="line">        if(p.test(apple))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样针对不同的过滤需求（行为），我们只需要定义不同的ApplePredicate的实现类，即可使用同一个过滤方法筛选出我们想要的苹果，比如筛选出红色且较重的苹果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;red&quot;.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Apple&gt; redAndHeavyApples =filterApples(inventory, new AppleRedAndHeavyPredicate());</span><br></pre></td></tr></table></figure></p><p>无论筛选需求的组合多么复杂，都只有一个行为参数，至此，filterApples方法已经能够应对不断变化的筛选需求了。但每一个筛选行为都需要定义一个类，是不是太啰嗦了？</p><p><strong>由于该filterApples方法只能接受对象，所以你必须把代码包裹在ApplePredicate对象里。就类似于在内联“传递代码”，因为你是通过一个实现了test方法的对象来传递布尔表达式的。</strong></p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;red&quot;.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>匿名类虽然省去了大量行为类的声明，但是依然笨重（模板化的代码占了4行，实际的筛选代码却只有一行）且匿名类的使用可能会让人费解。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><pre><code>List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; &quot;red&quot;.equals(apple.getColor()));</code></pre><p><img src="/images/xwcsh01.png" alt=""></p><h2 id="将-List-类型抽象化，行为参数化趋于完美"><a href="#将-List-类型抽象化，行为参数化趋于完美" class="headerlink" title="将 List 类型抽象化，行为参数化趋于完美"></a>将 List 类型抽象化，行为参数化趋于完美</h2><p>前方的过滤方法只能过滤Apple，我们可以使用泛型进一步抽象化，使其可以过滤Orange、Banana等任何实体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;&#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for(T e: list)&#123;</span><br><span class="line">        if(p.test(e))&#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//筛选出红苹果</span><br><span class="line">List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; &quot;red&quot;.equals(apple.getColor()));</span><br><span class="line">//筛选出偶数</span><br><span class="line">List&lt;Integer&gt; evenNumbers = filter(numbers, (Integer i) -&gt; i % 2 == 0);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li><li>行为参数化可以让代码更好地适应不断变化的要求，减轻未来的工作量</li><li>传递代码，就是将新行为作为参数传递给方法。但在Java8之前实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java8之前可以用匿名类来减少。</li><li>Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;行为参数化是指一个方法的功能，部分或全部由传递给这个方法的某个或多个参数决定，但这些参数不是一般意义上的值（一个字符串或数字），&lt;strong&gt;它代表了一个具体的行为，其本质是代码传递&lt;/strong&gt;，表现可能有多种：对象、匿名类、java8里的Lambda表达式（或方法引用）等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>二进制问题</title>
    <link href="https://hsb786.github.io/2018/04/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://hsb786.github.io/2018/04/28/二进制问题/</id>
    <published>2018-04-28T06:12:09.000Z</published>
    <updated>2018-05-02T06:13:47.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>0.1+0.2=0.30000000000000004，今天偶尔看到这个问题，刚好前不久笔试的时候也遇到过，只知道是精度问题，但忘了是为什么，回顾一下。🍳</p></blockquote><a id="more"></a><p>有个网站域名就是0.30000000000000004<br><a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">0.30000000000000004.com</a></p><p>网站上举的栗子🎂</p><table><thead><tr><th>运算</th><th>结果</th></tr></thead><tbody><tr><td>.1 + .2</td><td>0.30000000000000004</td></tr><tr><td>.1F + .2F</td><td>0.3</td></tr></tbody></table><blockquote><p>Java has built-in support for arbitrary precision numbers using the BigDecimal class.<br>可以使用BigDecimal解决这个问题</p></blockquote><h2 id="导致这个问题的原因"><a href="#导致这个问题的原因" class="headerlink" title="导致这个问题的原因"></a>导致这个问题的原因</h2><ul><li>计算机将所有数据以二进制的形式存储  </li><li>计算机用有限的大小来存储数据</li></ul><h3 id="二进制十进制小数转换"><a href="#二进制十进制小数转换" class="headerlink" title="二进制十进制小数转换"></a>二进制十进制小数转换</h3><p>例如十进制0.125转换成二进制</p><table><thead><tr><th>二进制</th><th>十进制</th></tr></thead><tbody><tr><td>0.125*2=0.25</td><td>取整数部分0</td></tr><tr><td>0.25*2=0.5</td><td>取整数部分0</td></tr><tr><td>0.5*2=1</td><td>取整数部分1</td></tr></tbody></table><p>最终得到的结果就是0.001</p><p>例如二进制0.001转换成十进制</p><table><thead><tr><th>十进制</th><th>二进制</th></tr></thead><tbody><tr><td>0* 2^-1</td><td>0</td></tr><tr><td>0* 2^-2</td><td>0</td></tr><tr><td>1* 2^-3</td><td>0.125</td></tr></tbody></table><p>最终得到的结果就是0+0+0.125=0.125</p><hr><p>知道了这些就不难理解为什么0.1+0.2！=0.3</p><p>首先看0.1二进制表示：0.0 00110011001100110011001100110011    </p><p>无穷循环，而计算机只能用有限位来存储数据，所以必然会有精度丢失的问题。</p><p>java采用BigDecimal来解决这个问题</p><hr><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.1+.2=0.30000000000000004</span><br><span class="line">new BigDecimal(.1).add(new BigDecimal(.2))=0.3000000000000000166533453693773481063544750213623046875</span><br><span class="line">new BigDecimal(String.valueOf(.1)).add(new BigDecimal(String.valueOf(.2)))=0.3</span><br></pre></td></tr></table></figure></p><p>由于0.1无法用二进制表示，所以调用new BIgDecimal(Double val)依然是有问题的，最好转化为String类型。</p><h2 id="需要注意的东西"><a href="#需要注意的东西" class="headerlink" title="需要注意的东西"></a>需要注意的东西</h2><p>BigDecimal是不可变的，在进行每一步运算时，都会产生一个新的对象。所以不适合大量的数学运算，适用于商业计算中对进度要求比较高的。</p><p><em>感觉不懂的还有很多</em></p><hr><p><em>参考</em></p><blockquote><p><a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">0.30000000000000004.com</a></p><p><a href="https://www.zhihu.com/question/56545018" target="_blank" rel="noopener">为什么java里面3*0.1=0.30000000000000004，而4*0.1=0.4？</a></p><p><a href=""></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;0.1+0.2=0.30000000000000004，今天偶尔看到这个问题，刚好前不久笔试的时候也遇到过，只知道是精度问题，但忘了是为什么，回顾一下。🍳&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>山鬼</title>
    <link href="https://hsb786.github.io/2018/04/24/%E5%B1%B1%E9%AC%BC/"/>
    <id>https://hsb786.github.io/2018/04/24/山鬼/</id>
    <published>2018-04-24T05:10:17.000Z</published>
    <updated>2018-04-24T05:25:15.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。<br><a id="more"></a></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=445198021&auto=0&height=66"></iframe><p><strong>九歌·山鬼</strong></p><p> 若有人兮山之阿，被薜荔兮带女罗。</p><p> 既含睇兮又宜笑，子慕予兮善窈窕。</p><p> 乘赤豹兮从文里，辛夷车兮结旗。</p><p> 被石兰兮带杜衡。折芳馨兮遗所思。</p><p> 余处幽篁兮终不见天，路险难兮独后来。</p><p> 表独立兮山之类上，云容容兮而在下。</p><p> 杳冥冥兮羌昼晦，东风飘兮神灵雨。</p><p> 留灵修兮忘归，岁既晏兮孰华予。</p><p> 采三秀兮於山间，石磊磊兮葛蔓蔓。</p><p> 怨公子兮怅忘归，君思我兮不得闲。</p><p> 山中人兮芳杜若，饮石泉兮荫松柏。</p><p> 君我兮然疑作。</p><p> 雷填填兮雨冥冥，猿啾啾兮又夜鸣。</p><p> 风飒飒兮木萧萧，思公子兮徙离忧。 </p><hr><p> <a href="https://music.douban.com/review/8790064/" target="_blank" rel="noopener"> 山鬼自啼风雨·《山鬼》乐评. </a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://hsb786.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://hsb786.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>RandomAccess</title>
    <link href="https://hsb786.github.io/2018/04/23/RandomAccess/"/>
    <id>https://hsb786.github.io/2018/04/23/RandomAccess/</id>
    <published>2018-04-23T10:30:51.000Z</published>
    <updated>2018-04-23T10:58:03.042Z</updated>
    
    <content type="html"><![CDATA[<p>JDK官方文档上的解释：</p><blockquote><p>Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.<br>大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。<br><a id="more"></a></p></blockquote><p>只定义了一个接口，里面什么都没有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释上举了个栗子🎂，例如下面代码中第一种循环运行比第二种快<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span><br><span class="line"> *         list.get(i);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * runs faster than this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line"> *         i.next();</span><br><span class="line"> * &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><p>so，在遍历ArrayList时，优先使用第一种循环；在遍历LinkedList则使用第二种循环。<br>根据有没有实现RandomAccess接口来判断。<br>ArrayList实现了RandomAccess接口，LinkedList没有实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Collections.class</span><br><span class="line">public static &lt;T&gt;</span><br><span class="line">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        return Collections.indexedBinarySearch(list, key);</span><br><span class="line">    else</span><br><span class="line">        return Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>foreach内部是通过Iterator实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">for(String s:list) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的字节码文件。<br>从第27，37，54行可以看出，foreach其实是通过Iterator来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class al.T01 &#123;</span><br><span class="line">  public al.T01();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #19                 // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #21                 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #22                 // String a</span><br><span class="line">      11: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: aload_1</span><br><span class="line">      18: ldc           #30                 // String b</span><br><span class="line">      20: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      25: pop</span><br><span class="line">      26: aload_1</span><br><span class="line">      27: invokeinterface #32,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</span><br><span class="line">      32: astore_3</span><br><span class="line">      33: goto          53</span><br><span class="line">      36: aload_3</span><br><span class="line">      37: invokeinterface #36,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">      42: checkcast     #42                 // class java/lang/String</span><br><span class="line">      45: astore_2</span><br><span class="line">      46: getstatic     #44                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      49: aload_2</span><br><span class="line">      50: invokevirtual #50                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      53: aload_3</span><br><span class="line">      54: invokeinterface #56,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z</span><br><span class="line">      59: ifne          36</span><br><span class="line">      62: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK官方文档上的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.&lt;br&gt;大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot</title>
    <link href="https://hsb786.github.io/2018/04/23/HotSpot/"/>
    <id>https://hsb786.github.io/2018/04/23/HotSpot/</id>
    <published>2018-04-23T10:15:36.000Z</published>
    <updated>2018-04-23T12:52:33.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&lt;&lt;深入理解Java虚拟机：JVM高级特性与最佳实践&gt;&gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄</p></blockquote><a id="more"></a><p>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。</p><p>HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利），<strong>HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知<a href="https://hsb786.github.io/2018/04/09/术语/">JIT编译器</a>以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</strong></p><p>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</p><p>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&amp;lt;&amp;lt;深入理解Java虚拟机：JVM高级特性与最佳实践&amp;gt;&amp;gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap</title>
    <link href="https://hsb786.github.io/2018/04/22/LinkedHashMap/"/>
    <id>https://hsb786.github.io/2018/04/22/LinkedHashMap/</id>
    <published>2018-04-22T11:37:01.000Z</published>
    <updated>2018-04-23T11:06:33.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LinkedHashMap 保证插入数据的有序性</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line">    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The head (eldest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The tail (youngest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">     * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    final boolean accessOrder;</span><br><span class="line"></span><br><span class="line">    public LinkedHashMap() &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap内部没有重写put方法，很好奇，是怎么把链表加上去的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</span><br><span class="line">    ....................</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一篇博客上看到加链表是通过<code>afterNodeInsertion(evict)</code>。可以看出每次put的时候都调用了<code>afterNodeInsertion(evict)</code>; 而这个afterNodeInsertion在LinkedHashMap中是重写了的。然后就傻呼呼的相信了，but 在<code>afterNodeInsertion(evict)</code>中并没有添加链表啊，傻傻的盯着这段代码看了很久。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，开始自己找。发现了<code>linkNodeLast()</code>方法，这不就是实现链表的关键吗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// link at the end of list</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着发现<code>linkNodeLast()</code>在<code>newNode()</code>中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并且newNode()在HashMap中也存在，注释还写得清清楚楚，就是用来被LinkedHashMap重写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">/* ------------------------------------------------------------ */</span><br><span class="line">// LinkedHashMap support</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* The following package-protected methods are designed to be</span><br><span class="line">* overridden by LinkedHashMap, but not by any other subclass.</span><br><span class="line">* Nearly all other internal methods are also package-protected</span><br><span class="line">* but are declared final, so can be used by LinkedHashMap, view</span><br><span class="line">* classes, and HashSet.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// Create a regular (non-tree) node</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>putVal()</code>中调用了<code>newNode()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就解释通了，LinkedHashMap没有重写put方法。为了保证有序，那么他是怎么实现链表的呢？</p><p>利用多态，通过重写<code>newNode()</code>方法，在<code>newNode()</code>方法中实现了链表的连接。而<code>newNode</code>方法在<code>putVal()</code>中调用了。so，每次添加元素的时候，同时会维护一个双向链表。通过链表实现了有序。</p><p>看来，平时不能太依赖于网上别人分析的东西，不一定是对的。</p><hr><p><strong>accessOrder</strong></p><p>LinkedHashMap中定义了accessOrder属性。官方是这样解释的：accessOrder为true时，迭代顺序就是访问顺序；为false时，迭代顺序就是插入顺序。<br>插入顺序倒好理解，访问顺序是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">*</span><br><span class="line">* @serial</span><br><span class="line">*/</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap重写了<code>get(Object key)</code>方法。accessOrder为true时，调用了<code>afterNodeAccess(e);</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 方法注解写的很明白，move node to last，把node移动到最后。意思就是如果accessOrder设为true时，每次通过get()获取，都会把获取的元素移到链表的最后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>final boolean accessOrder;</code> accessOrder包访问权限，也没有set方法，只能通过<code>public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)</code> 构造函数来将accessOrder设为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LinkedHashMap 保证插入数据的有序性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashSet</title>
    <link href="https://hsb786.github.io/2018/04/22/HashSet/"/>
    <id>https://hsb786.github.io/2018/04/22/HashSet/</id>
    <published>2018-04-22T10:44:43.000Z</published>
    <updated>2018-04-22T11:37:57.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HashSet 底层由HashMap实现<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    //HashSet底层使用HashMap实现</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    //HashSet add(E e)方法中，key为e，value为PRESENT</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new, empty linked hash set.  (This package private</span><br><span class="line">     * constructor is only used by LinkedHashSet.) The backing</span><br><span class="line">     * HashMap instance is a LinkedHashMap with the specified initial</span><br><span class="line">     * capacity and the specified load factor.</span><br><span class="line">     *</span><br><span class="line">     * @param      initialCapacity   the initial capacity of the hash map</span><br><span class="line">     * @param      loadFactor        the load factor of the hash map</span><br><span class="line">     * @param      dummy             ignored (distinguishes this</span><br><span class="line">     *             constructor from other int, float constructor.)</span><br><span class="line">     * @throws     IllegalArgumentException if the initial capacity is less</span><br><span class="line">     *             than zero, or if the load factor is nonpositive</span><br><span class="line">     */</span><br><span class="line">     //这个就有点意思了，dummy参数其实没用，只是为了重载，与其它方法区分开了而已，这样也行！</span><br><span class="line">     //注意的是返回的是LinkedHashMap，数据是有顺序的。</span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><code>add(E e)</code>,<code>remove(Object o)</code>只是直接调用HashMap的put和remove方法。<br>key: e ; value : PRESENT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HashSet 底层由HashMap实现&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Java内存访问重排序的研究（转载）</title>
    <link href="https://hsb786.github.io/2018/04/21/Java%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>https://hsb786.github.io/2018/04/21/Java内存访问重排序的研究/</id>
    <published>2018-04-21T13:40:14.000Z</published>
    <updated>2018-04-24T05:49:34.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">原文链接</a><br><a id="more"></a></p></blockquote><h2 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PossibleReordering &#123;</span><br><span class="line">static int x = 0, y = 0;</span><br><span class="line">static int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread one = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a = 1;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread other = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            b = 1;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p><p>然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程，如下图所示。值得注意的是，a=1和x=b这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”(reordering)。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p><p><img src="/images/reordered01.png" alt=""></p><p>对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。</p><p><img src="/images/reordered02.png" alt=""></p><p>实验代码是构造一个循环，反复执行上面的实例代码，直到出现a=0且b=0的输出为止。实验结果说明，循环执行到第13830次时输出了(0,0).</p><p>大多数现代微处理器都会采用将<strong>指令乱序执行（out-of-order execution，简称OoOE或OOE）</strong>的方法，<strong>在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。</strong>通过乱序执行的技术，处理器可以大大提高执行效率。<br>除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p><strong>As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的</strong>。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。<br>比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成Java字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</p><ul><li>对a赋值1</li><li>对b赋值2</li><li>取a的值</li><li>取b的值</li><li>将取到两个值相加后存入c</li></ul><p>在上面5个动作中，动作1可能会和动作2、4重排序，动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，一旦重排，as-if-serial语义便无法保证。</p><p>为保证as-if-serial语义，<strong>Java异常处理机制也会为重排序做一些特殊处理</strong>。例如在下面的代码中，y = 0 / 0可能会被重排序在x = 2之前执行，为了保证最终不致于输出x = 1的错误结果，<strong>JIT在重排序时会在catch语句中插入错误代偿代码，将x赋值为2，将程序恢复到发生异常时应有的状态</strong>。这种做法的确将异常捕捉的逻辑变得复杂了，但是JIT的优化的原则是，<strong>尽力优化正常运行下的代码逻辑，哪怕以catch块逻辑变得复杂为代价</strong>，毕竟，进入catch块内是一种“异常”情况的表现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Reordering &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        x = 1;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 2;</span><br><span class="line">            y = 0 / 0;    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存访问重排序与内存可见性"><a href="#内存访问重排序与内存可见性" class="headerlink" title="内存访问重排序与内存可见性"></a>内存访问重排序与内存可见性</h2><p>计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。其模型如下图所示。</p><p><img src="/images/reordered03.png" alt=""></p><p>在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。<br>有的观点会将这种现象也视为重排序的一种，命名为“内存系统重排序”。因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。<br>这种内存可见性问题也会导致章节一中示例代码即便在没有发生指令重排序的情况下的执行结果也还是(0, 0)。</p><h2 id="内存访问重排序与Java内存模型"><a href="#内存访问重排序与Java内存模型" class="headerlink" title="内存访问重排序与Java内存模型"></a>内存访问重排序与Java内存模型</h2><p>Java的目标是成为一门平台无关性的语言，即Write once, run anywhere. 但是<strong>不同硬件环境下指令重排序的规则不尽相同</strong>。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-1337制定了<strong>Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性</strong>。从Java 5开始，Java内存模型成为Java语言规范的一部分。<br>根据Java内存模型中的规定，可以总结出以下几条happens-before规则。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p><ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><p>Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4。</p><p>除此之外，Java内存模型对volatile和final的语义做了扩展。对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（的前提是没有this引用溢出）。</p><p>Java内存模型关于重排序的规定，总结后如下表所示。</p><p><img src="/images/reordered04.png" alt=""></p><p>表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有volatile写重排序。另外，JMM也规定了上述volatile和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括JIT，下同）证明了一个volatile变量只能被单线程访问，那么就可能会把它做为普通变量来处理。<br>留白的单元格代表允许在不违反Java基本语义的情况下重排序。例如，编译器不会对对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。</p><p>除此之外，为了保证final的新增语义。JSR-133对于final变量的重排序也做了限制。</p><ul><li>构建方法内部的final成员变量的存储，并且，假如final成员变量本身是一个引用的话，这个final成员变量可以引用到的一切存储操作，都不能与构建方法外的将当期构建对象赋值于多线程共享变量的存储操作重排序。例如对于如下语句<br>x.finalField = v; … ;  构建方法边界sharedRef = x;<br>v.afield = 1; x.finalField = v; … ; 构建方法边界sharedRef = x;<br>这两条语句中，构建方法边界前后的指令都不能重排序。</li><li>初始读取共享对象与初始读取该共享对象的final成员变量之间不能重排序。例如对于如下语句<br>x = sharedRef; … ; i = x.finalField;<br>前后两句语句之间不会发生重排序。由于这两句语句有数据依赖关系，编译器本身就不会对它们重排序，但确实有一些处理器会对这种情况重排序，因此特别制定了这一规则。</li></ul><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型  </p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul><p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p><p><img src="/images/reordered05.png" alt=""></p><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p><h2 id="Intel-64-IA-32架构下的内存访问重排序"><a href="#Intel-64-IA-32架构下的内存访问重排序" class="headerlink" title="Intel 64/IA-32架构下的内存访问重排序"></a>Intel 64/IA-32架构下的内存访问重排序</h2><p>Intel 64和IA-32是我们较常用的硬件环境，相对于其它处理器而言，它们拥有一种较严格的重排序规则。Pentium 4以后的Intel 64或IA-32处理的重排序规则如下。</p><p>在单CPU系统中</p><ul><li>读操作不与其它读操作重排序。</li><li>写操作不与其之前的写操作重排序。</li><li>写内存操作不与其它写操作重排序，但有以下几种例外</li><li>CLFLUSH的写操作</li><li>带有non-temporal move指令(MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD)的streaming写入。</li><li>字符串操作</li><li>读操作可能会与其之前的写不同位置的写操作重排序，但不与其之前的写相同位置的写操作重排序。</li><li>读和写操作不与I/O指令，带锁的指令或序列化指令重排序。</li><li>读操作不能重排序到LFENCE和MFENCE之前。</li><li>写操作不能重排序到LFENCE、SFENCE和MFENCE之前。</li><li>LFENCE不能重排序到读操作之前。</li><li>SFENCE不能重排序到写之前。</li><li>MFENCE不能重排序到读或写操作之前。</li></ul><p>在多处理器系统中</p><ul><li>各自处理器内部遵循单处理器的重排序规则。</li><li>单处理器的写操作对所有处理器可见是同时的。</li><li>各自处理器的写操作不会重排序。</li><li>内存重排序遵守因果性(causality)（内存重排序遵守传递可见性）。</li><li>任何写操作对于执行这些写操作的处理器之外的处理器来看都是一致的。</li><li>s带锁指令是顺序执行的。</li></ul><p>值得注意的是，对于Java编译器而言，Intel 64/IA-32架构下处理器不需要LoadLoad、LoadStore、StoreStore屏障，因为不会发生需要这三种屏障的重排序。</p><h2 id="一例Intel-64-IA-32架构下的代码性能优化"><a href="#一例Intel-64-IA-32架构下的代码性能优化" class="headerlink" title="一例Intel 64/IA-32架构下的代码性能优化"></a>一例Intel 64/IA-32架构下的代码性能优化</h2><p>现在有这样一个场景，一个容器可以放一个东西，容器支持create方法来创建一个新的东西并放到容器里，支持get方法取到这个容器里的东西。我们可以较容易地写出下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程场景下，这段代码执行起来是没有问题的。但是在多线程并发场景下，由不同的线程create和get东西，这段代码是有问题的。问题的原因与普通的双重检查锁定单例模式(Double Checked Locking, DCL)10类似，即SomeThing的构建与将指向构建中的SomeThing引用赋值到object变量这两者可能会发生重排序。导致get中返回一个正被构建中的不完整的SomeThing对象实例。为了解决这一问题，通常的办法是使用volatile修饰object字段。这种方法避免了重排序，保证了内存可见性，摒弃比使用同步块导致的性能损失更小。但是，假如使用场景对object的内存可见性并不敏感的话（不要求一个线程写入了object，object的新值立即对下一个读取的线程可见），在Intel 64/IA-32环境下，有更好的解决方案。</p><p>根据上一章的内容，我们知道Intel 64/IA-32下写操作之间不会发生重排序，即在处理器中，构建SomeThing对象与赋值到object这两个操作之间的顺序性是可以保证的。这样看起来，仅仅使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。但令人高兴的是，Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。</p><p>我们将做一个小实验来比较二者的性能差异。一种是使用volatile修饰object成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile  SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是利用Unsafe. putOrderedObject在避免在适当的位置发生重排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    private Object value;</span><br><span class="line">    private static final Unsafe unsafe = getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(Container.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        SomeThing temp = new SomeThing();</span><br><span class="line">        unsafe.putOrderedObject(this, valueOffset, null);    //将value赋null值只是一项无用操作，实际利用的是这条语句的内存屏障</span><br><span class="line">        object = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            return (Unsafe)f.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接调用Unsafe.getUnsafe()需要配置JRE获取较高权限，我们利用反射获取Unsafe中的theUnsafe来取得Unsafe的可用实例。<br>unsafe.putOrderedObject(this, valueOffset, null)<br>这句仅仅是为了借用这句话功能的防止写重排序，除此之外无其它作用。</p><p>利用下面的代码分别测试两种方案的实际运行时间。在运行时开启-server和 -XX:CompileThreshold=1以模拟生产环境下长时间运行后的JIT优化效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    final int THREADS_COUNT = 20;</span><br><span class="line">    final int LOOP_COUNT = 100000;</span><br><span class="line"></span><br><span class="line">    long sum = 0;</span><br><span class="line">    long min = Integer.MAX_VALUE;</span><br><span class="line">    long max = 0;</span><br><span class="line">    for(int n = 0;n &lt;= 100;n++) &#123;</span><br><span class="line">        final Container basket = new Container();</span><br><span class="line">        List&lt;Thread&gt; putThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        List&lt;Thread&gt; takeThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            putThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.create();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            takeThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.get().getStatus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).start();</span><br><span class="line">            putThreads.get(i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).join();</span><br><span class="line">            putThreads.get(i).join();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line">        long period = end - start;</span><br><span class="line">        if(n == 0) &#123;</span><br><span class="line">            continue;    //由于JIT的编译，第一次执行需要更多时间，将此时间不计入统计</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (period);</span><br><span class="line">        System.out.println(period);</span><br><span class="line">        if(period &lt; min) &#123;</span><br><span class="line">            min = period;</span><br><span class="line">        &#125;</span><br><span class="line">        if(period &gt; max) &#123;</span><br><span class="line">            max = period;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Average : &quot; + sum / 100);</span><br><span class="line">    System.out.println(&quot;Max : &quot; + max);</span><br><span class="line">    System.out.println(&quot;Min : &quot; + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的计算机上运行测试，采用volatile方案的运行结果如下<br>Average : 62535770<br>Max : 82515000<br>Min : 45161000</p><p>采用unsafe.putOrderedObject方案的运行结果如下<br>Average : 50746230<br>Max : 68999000<br>Min : 38038000</p><p>从结果看出，unsafe.putOrderedObject方案比volatile方案平均耗时减少18.9%，最大耗时减少16.4%，最小耗时减少15.8%.另外，即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。&lt;a href=&quot;https://tech.meituan.com/java-memory-reordering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashMap中的扩容</title>
    <link href="https://hsb786.github.io/2018/04/21/HashMap%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9/"/>
    <id>https://hsb786.github.io/2018/04/21/HashMap中的扩容/</id>
    <published>2018-04-21T12:10:50.000Z</published>
    <updated>2018-04-25T07:17:39.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞<br><a id="more"></a><br>术语：</p><ul><li>高位运算：不太了解，网上也找不到解释。让高位参加运算?</li><li>取模运算：例如对于整数a，b来说，取模或者求余主要分为以下两步<ul><li><ol><li>求整数商: c=a/b     </li></ol></li><li><ol start="2"><li>计算模或者余数：r=a-c*b   </li></ol></li><li>取模运算是r向负无穷方向舍弃小数位</li><li>求余运算时r向正无穷方向舍弃小数位</li></ul></li></ul></blockquote><p><em>针对java8</em></p><h2 id="根据key获取哈希桶数组索引位置"><a href="#根据key获取哈希桶数组索引位置" class="headerlink" title="根据key获取哈希桶数组索引位置"></a>根据key获取哈希桶数组索引位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //1. h=key.hashCode()    取hashCode值</span><br><span class="line">    //2. h^(H&gt;&gt;&gt;16)     高位参与运算</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // 3. (n-1)&amp;hash    取模运算</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong></p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用取模运算来计算该对象应该保存在table数组的哪个索引处。</p><p>通过(table.length -1)&amp;h来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。<strong>当length总是2的n次方时，(length-1)&amp; h运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br><em>补充一下：为什么求得的hash值是32位的？这是因为int类型4字节，4X8=32</em></p><p><img src="/images/HashMap21.png" alt=""></p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p><strong>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/images/HashMap22.png" alt=""></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/images/HashMap23.png" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/images/HashMap24.png" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。</p><p><code>final Node&lt;K,V&gt;[] resize()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //// 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // 链表优化重hash的代码块</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                         // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一点搞不懂，<code>if ((e.hash &amp; oldCap) == 0) {</code>这里为什么这么判断就能确定新增的1bit就是0呢😱😱😱。被二进制搞的头昏脑胀😖😞😟。<br>现在好像明白了，oldCap=01 0000，key1= 00 0101 , key2= 01 0101    key1&amp;oldCap=0，新增的1bit为0。应该是这样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>(n - 1) &amp; hash，当n是2次幂的时候，hash%n等于(n-1)&amp;hash，&amp;比%具有更高的效率</li><li>由于长度是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Metaspace</title>
    <link href="https://hsb786.github.io/2018/04/21/Metaspace/"/>
    <id>https://hsb786.github.io/2018/04/21/Metaspace/</id>
    <published>2018-04-21T04:21:05.000Z</published>
    <updated>2018-04-21T07:35:08.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish</p></blockquote><p>Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap</p><blockquote><p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.<br>JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。<br><a id="more"></a></p></blockquote><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>避免了OutOfMemoryError的问题。类的元数据分配只受本地内存大小的限制。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><ul><li>-XX:MetaspaceSize 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li><li>-XX:MaxMetaspaceSize 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li><li>-XX:MinMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li><li>-XX:MaxMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">深入探究JVM | 探秘 Metaspace </a></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p><p><a href="https://stackoverflow.com/questions/20563047/jdk-8-memory-layout-and-garbage-collection" target="_blank" rel="noopener">JDK 8 Memory Layout and garbage collection</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.&lt;br&gt;JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
