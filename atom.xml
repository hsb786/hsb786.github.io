<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-12T08:46:32.563Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8新特性（转载）</title>
    <link href="https://hsb786.github.io/2018/04/12/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/12/java8新特性（转载）/</id>
    <published>2018-04-12T07:56:55.000Z</published>
    <updated>2018-04-12T08:46:32.563Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。<br><img src="/images/java8.jpg" alt=""><br><a id="more"></a></p><h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><p>Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line"></span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt.Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br></pre></td></tr></table></figure><p>那么这个新特征有啥用呢？</p><p>我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类，那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法，那么我们需要去重写每个实现了这个接口的类，而这大大增加了我们的实现需求的负担。</p><p>正是为了解决Java接口中只能定义抽象方法的问题。Java8新增加了默认方法的特性。默认方法可以被继承接口重写成抽象方法或者重新定义成默认方法。除了默认方法，接口里还可以声明静态方法，并且可以实现。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private interface DefaulableFactory &#123;</span><br><span class="line">    // Interfaces now allow static methods</span><br><span class="line">    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h2><p>因为一个类可以实现多个接口，所以当一个类实现了多个接口，而这些接口中存在两个或两个以上方法签名相同的默认方法时就会产生冲突，java8定义如下三条原则来解决冲突：</p><ol><li>类或父类中显式声明的方法，其优先级高于所有的默认方法；</li><li>如果1规则失效，则选择与当前类距离最近的具有具体实现的默认方法；</li><li>如果2规则也失效，则需要显式指定接口。</li></ol><hr><h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><p>Lambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式，它提供了轻量级的语法</p><p>重点留意这四个关键词：匿名、函数、传递、简洁</p><p>Lambda的三个部分：</p><ul><li>参数列表</li><li>箭头</li><li>Lambda 主体</li></ul><p>Lambda的基本语法大概就是下面这样子的了：</p><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; { statements; }</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line">或者是</span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">亦或是</span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><hr><h2 id="Lexiacal-Scope"><a href="#Lexiacal-Scope" class="headerlink" title="Lexiacal Scope"></a>Lexiacal Scope</h2><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>可以直接在Lambda表达式中访问外层的局部变量，但是和匿名对象不同的是，Lambda表达式的局部变量可以不用声明为final，不过局部变量必须不可被后面的代码修改（即隐性的具有final的语义）。</p><p>eg：下面代码无法编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = 1; </span><br><span class="line">Converter&lt;Integer, String&gt; s =  </span><br><span class="line">(param) -&gt; String.valueOf(param + num);  </span><br><span class="line">num = 5;</span><br></pre></td></tr></table></figure></p><p>在Lambda表达式中试图修改局部变量是不允许的！</p><ol><li>在 Lambda 表达式当中被引用的变量的值不可以被更改。</li><li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li><li>和局部变量不同的是，Lambda内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。</li></ol><h3 id="不能访问接口的默认方法"><a href="#不能访问接口的默认方法" class="headerlink" title="不能访问接口的默认方法"></a>不能访问接口的默认方法</h3><p>Lambda表达式中是无法访问到默认方法的。</p><p>补充：Lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，在这里增加一个例子以说明这个特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over values</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = new List&lt;&gt;();</span><br><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的简写？"><a href="#匿名内部类的简写？" class="headerlink" title="匿名内部类的简写？"></a>匿名内部类的简写？</h3><p>Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件</p><h3 id="Lambda表达式中的this"><a href="#Lambda表达式中的this" class="headerlink" title="Lambda表达式中的this"></a>Lambda表达式中的this</h3><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。</p><hr><h2 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h2><p>任意只包含一个抽象方法的接口，我们都可以用来做成Lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br></pre></td></tr></table></figure><p>注意，如果你不写@FunctionalInterface 标注，程序也是正确的。</p><p>下面是Java SE 7中已经存在的函数式接口：</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.util.Comparator</li><li>java.io.FileFilter</li><li>java.beans.PropertyChangeListener</li></ul><p>除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：</p><ul><li>Predicate<t>——接收T对象并返回boolean</t></li><li>Consumer<t>——接收T对象，不返回值</t></li><li>Function&lt;T, R&gt;——接收T对象，返回R对象</li><li>Supplier<t>——提供T对象（例如工厂），不接收值</t></li><li>UnaryOperator<t>——接收T对象，返回T对象</t></li><li>BinaryOperator<t>——接收两个T对象，返回T对象</t></li></ul><p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。</p><hr><h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>Lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。</p><p>方法引用和Lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p><p>方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。<br>方法引用有很多种，它们的语法如下：</p><ul><li>静态方法引用：ClassName::methodName</li><li>实际上的实例方法引用：instanceReference::methodName</li><li>超类上的实例方法引用：super::methodName</li><li>类型上的实例方法引用：ClassName::methodName</li><li>构造方法引用：Class::new</li><li>数组构造方法引用：TypeName[]::new</li></ul><p>对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。</p><p>结合Lambda可以使我们的代码更加简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">strings.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt; chars = Arrays.asList(&apos;a&apos;, &apos;b&apos;);System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;)));</span><br></pre></td></tr></table></figure><hr><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>NullPointException可以说是所有Java程序员都遇到过的一个异常，虽然Java从设计之初就力图让程序员脱离指针的苦海，但是指针确实是实际存在的，而java设计者也只能是让指针在Java语言中变得更加简单、易用，而不能完全的将其剔除，所以才有了我们日常所见到的关键字null。</p><p>空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。当异常真的发生的时候，处理策略也很简单，在存在异常的地方添加一个if语句判定即可，但是这样的应对策略会让我们的程序出现越来越多的null判定，我们知道一个良好的程序设计，应该让代码中尽量少出现null关键字，而Java8所提供的Optional类则在减少NullPointException的同时，也提升了代码的美观度。但首先我们需要明确的是，它并 不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现，从而避免NullPointException。</p><p>java.util.Optional<t> 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。</t></p><p>创建 Optional 对象,三个静态工厂方法：</p><ul><li>Optional.empty：创建空的 Optional 对象</li><li>Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE</li><li>Optianal.ofNullable：创建 Optional 对象，允许传空值</li></ul><p>Optional API：</p><ul><li>isPresent(): 变量存在返回true</li><li>get(): 返回封装的变量值，或者抛出 NoSuchElementException</li><li>orElse(T other): 提供默认值</li><li>orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版</li><li>orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型</li><li>ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法</li><li>filter(Predicate&lt;? super T&gt; predicate): 过滤</li><li>map(Function&lt;? super T, ? extends U&gt; mapper): 转换</li><li>flatMap(Function&lt;? super T, Optional&lt;U>>mapper): 转换成Optional</li></ul><p>值得注意的是：Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题</p><p>Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法，没有考虑将它作为类的字段使用…</p><p>另外，在Java9中对Optional添加了三个新的方法：</p><ol><li><p>public Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)<br>or 方法的作用是，如果一个 Optional 包含值，则返回自己；否则返回由参数 supplier 获得的 Optional</t></p></li><li><p>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)<br>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()</p></li><li>public Stream<t> stream()<br>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream；否则返回一个空的 Stream（Stream.empty()）</t></li></ol><p>举个例子，在 Java8，我们会写下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 此处 getUserById 返回的是 Optional&lt;User&gt;</span><br><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">       return userIds.stream()</span><br><span class="line">            .map(this::getUserById)     // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .filter(Optional::isPresent)// 去掉不包含值的 Optional</span><br><span class="line">            .map(Optional::get)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了 Optional.stream()，我们就可以将其简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">    return userIds.stream()</span><br><span class="line">            .map(this::getUserById)    // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><img src="/images/Java_stream_Interfaces.png" alt=""></p><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;).stream()</span><br><span class="line">                                           .filter(s -&gt; s.startsWith(&quot;c&quot;))</span><br><span class="line">                                           .map(String::toUpperCase)</span><br><span class="line">                                           .sorted()</span><br><span class="line">                                           .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream<t>代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。</t></p><p>引入的原因：</p><ul><li>声明性方式处理数据集合</li><li>透明地并行处理，提高性能</li></ul><p>流 的定义：从支持数据处理操作的源生成的元素序列</p><p>两个重要特点</p><ul><li>流水线</li><li>内部迭代</li></ul><p>流与集合：</p><ul><li>集合与流的差异就在于什么时候进行计算 <ul><li>集合是内存中的数据结构，包含数据结构中目前所有的值</li><li>流的元素则是按需计算/生成</li></ul></li><li>另一个关键区别在于遍历数据的方式 <ul><li>集合使用 Collection 接口，需要用户去做迭代，称为外部迭代</li><li>流的 Streams 库使用内部迭代</li></ul></li></ul><p>流的使用</p><ul><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul><p>流的流水线背后的理念类似于构建器模式。常见的中间操作有filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。</p><p><img src="/images/stream.png" alt=""></p><p>流的操作类型分为两种：</p><ul><li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ul><h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><ul><li>由值创建流：Stream.of、Stream.empty、IntStream.range</li><li>由集合创建流：Collection.stream、Collection.parallelStream</li><li>由数组创建流：Arrays.stream(数组变量)</li><li>由文件生成流：Files.lines、Files.walk</li><li>由BufferedReader创建流：java.io.BufferedReader.lines</li><li>由函数生成流：创建无限流， <ul><li>迭代： Stream.iterate（接受一个种子值，和一个UnaryOperator）</li><li>生成：Stream.generate（接收一个Supplier接口）</li></ul></li></ul><h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>Intermediate（中间操作）：</p><ul><li>筛选<ul><li>谓词筛选：filter</li><li>筛选互异的元素：distinct</li><li>忽略头几个元素：skip</li><li>截短至指定长度：limit</li><li>排序：sorted</li><li>偷瞄（输出）：peek</li><li>平行化：parallel</li><li>串行化：sequential</li></ul></li><li>映射 <ul><li>对流中每个元素应用函数：map</li><li>流的扁平化：flatMap</li><li>转为原始流：mapToInt、mapToInt、mapToInt</li><li>从原始流转为普通流：boxed</li></ul></li><li>数值范围<ul><li>range:[起始值，结束值)</li><li>rangeClosed:[起始值，结束值]</li></ul></li></ul><p>Terminal（终结操作）</p><ul><li>查找和匹配<ul><li>检查谓词是否至少匹配一个元素：anyMatch</li><li>检查谓词是否匹配所有元素：allMatch/noneMatch</li><li>查找元素：findAny</li><li>查找第一个元素：findFirst</li></ul></li><li>归约（折叠）：reduce(初值，结合操作)<ul><li>元素求和：count、sum</li><li>最大值和最小值：min、 max</li></ul></li><li>遍历<ul><li>forEach、 forEachOrdered</li></ul></li></ul><p>anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。<br>原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。</p><ul><li>映射到数值流：mapToInt,mapToDouble,mapToLong</li><li>转换回流对象：boxed</li><li>默认值：OptionalInt,OptionalDouble,OptionalLong</li></ul><h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><p>对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。</p><p>Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能：</p><ul><li>将流元素归约和汇总为一个值</li><li>元素分组</li><li>元素分区</li></ul><p>归约和汇总(Collectors 类中的工厂方法)：</p><ul><li>统计个数：Collectors.counting</li><li>查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy</li><li>汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数</li><li>连接字符串：joining</li><li>广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。</li></ul><p>collect vs. reduce，两者都是 Stream 接口的方法，区别在于：</p><ul><li>语意问题<ul><li>reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约；</li><li>collect 方法设计就是要改变容器，从而累积要输出的结果</li></ul></li><li>实际问题<ul><li>以错误的语义使用 reduce 会导致归约过程不能并行工作</li></ul></li></ul><p>分组和分区</p><ul><li>分组：Collectors.groupingBy<ul><li>多级分组</li><li>按子数组收集数据: maxBy<ul><li>把收集器的结果转换为另一种结果 collectingAndThen</li><li>与 groupingBy 联合使用的其他收集器例子：summingInt,mapping</li></ul></li></ul></li><li>分区：Collectors.partitioningBy是分组的特殊情况，由一个谓词作为分类函数(分区函数)，返回一个Map，只有两个Boolean类型的key。</li></ul><h3 id="Ex1-使用collect-生成Collection"><a href="#Ex1-使用collect-生成Collection" class="headerlink" title="Ex1:使用collect()生成Collection"></a>Ex1:使用collect()生成Collection</h3><p>前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将Stream转换成List或Set</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span><br><span class="line"></span><br><span class="line">上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用toCollection()指定规约容器的类型</span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)</span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)</span><br></pre></td></tr></table></figure><p>上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。</p><h3 id="Ex2-使用collect-生成Map"><a href="#Ex2-使用collect-生成Map" class="headerlink" title="Ex2:使用collect()生成Map"></a>Ex2:使用collect()生成Map</h3><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map：</p><ol><li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li><li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li><li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li></ol><p>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用toMap()统计学生GPA</span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key</span><br><span class="line">                                     student -&gt; computeGPA(student)));// 如何生成value</span><br></pre></td></tr></table></figure><p>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Partition students into passing and failing</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure><p>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Group employees by department</span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure><p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用下游收集器统计每个部门的人数</span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));// 下游收集器</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,// 下游收集器</span><br><span class="line">                                Collectors.toList())));// 更下游的收集器</span><br></pre></td></tr></table></figure><hr><h2 id="Notice-And-Optimization"><a href="#Notice-And-Optimization" class="headerlink" title="Notice And Optimization"></a>Notice And Optimization</h2><ul><li>流不可被复用</li><li>一般先filter、limit、skip操作后再进行sorted、peek、map等操作以达到short-circuiting 目的</li></ul><table><thead><tr><th>Stream操作分类</th><th></th><th>方法 </th></tr></thead><tbody><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td><td></td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td><td></td></tr></tbody></table><p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p><hr><h2 id="Java8-对字符串连接的改进"><a href="#Java8-对字符串连接的改进" class="headerlink" title="Java8 对字符串连接的改进"></a>Java8 对字符串连接的改进</h2><p>有时候，我们会有一种需求就是将若干个字符串用某个链接符衔接起来，例如有一个 List，将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式。</p><p>以前我们的一般做法就是使用StringBuilder：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringBuilder result = new StringBuilder();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.append(str).append(delimiter);</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除末尾多余的 delimiter</span><br><span class="line">    result.delete(result.length() - delimiter.length(), result.length()); </span><br><span class="line">    </span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringBuilder：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">使用 StringBuilder：</span><br><span class="line">a,b,c,d,e,f,g</span><br></pre></td></tr></table></figure><p>JDK1.8 时，添加了一个新的用于字符串连接的类，专门用于这种需要 分隔符 的场合，它就是 StringJoiner。StringJoiner 在构造时可以指定一个分隔符（delimiter），然后每连接一个元素它便会加上一个 delimiter，使用 StringJoiner 改写 formatList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用String.join:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    return String.join(delimiter, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String.join 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 List<string> 格式化为 { 元素1, 元素2, 元素3, … 元素N } 呢？（此时前缀为 “{ “，后缀为 “ }”）</string></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter, prefix, suffix);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner，带前缀和后缀：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Java8 对于字符串集合的连接操作提供了一个专门的流式 API，即 Collectors.joining 函数</p><ul><li>无参的 joining() 方法，即不存在连接符（底层实现为 StringBuilder）；</li><li>joining(CharSequence delimiter) 方法，即分隔符为 delimiter（底层实现为 StringJoiner）；</li><li>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法，即分隔符为 delimiter，前缀为 prefix，后缀为 suffix（底层实现为 StringJoiner）。</li></ul><p>那怎么使用呢？ 我们直接使用三个参数的 Collectors.joining 方法改写 formatList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Collectors.joining：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Java8-中-Map-接口的新方法"><a href="#Java8-中-Map-接口的新方法" class="headerlink" title="Java8 中 Map 接口的新方法"></a>Java8 中 Map 接口的新方法</h2><p>假如现在我们存在这样的需求：给定一个 List<string>，统计每个元素出现的所有位置。</string></p><p>比如，给定 list：[“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “f”, “f”, “g”] ，那么应该返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a : [0]</span><br><span class="line">b : [1, 2]</span><br><span class="line">c : [3, 4, 5]</span><br><span class="line">d : [6, 7, 8]</span><br><span class="line">f : [9, 10]</span><br><span class="line">g : [11]</span><br></pre></td></tr></table></figure></p><p>很明显，我们很适合使用 Map 来完成这件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        List&lt;Integer&gt; positions = positionsMap.get(str);</span><br><span class="line"></span><br><span class="line">        if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt;</span><br><span class="line">            positions = new ArrayList&lt;&gt;(1);</span><br><span class="line">            positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Java8 之前的 API：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 Java8 之前的 API：</span><br><span class="line">&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125;</span><br></pre></td></tr></table></figure><p>computeIfAbsent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 computeIfAbsent：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="当-forEach-需要索引"><a href="#当-forEach-需要索引" class="headerlink" title="当 forEach 需要索引"></a>当 forEach 需要索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是方法里面的for循环似乎让这个方法不太优雅了，Java8中Iterable提供的foreach并不带索引的：</p><p>我们可以自己写一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void forEach(</span><br><span class="line">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改造getElementPositions方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>参考</em></p><blockquote><p>[Java8 Noob Tutorial]<a href="http://yangbingdong.com/2017/java-8-tutorial/" target="_blank" rel="noopener">http://yangbingdong.com/2017/java-8-tutorial/</a>)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。&lt;br&gt;&lt;img src=&quot;/images/java8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="https://hsb786.github.io/2018/04/12/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://hsb786.github.io/2018/04/12/合并两个排序的链表/</id>
    <published>2018-04-12T07:29:59.000Z</published>
    <updated>2018-04-12T07:53:55.820Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode merge(ListNode list1, ListNode list2) &#123;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">if (list2 == null) &#123;</span><br><span class="line">return list1;</span><br><span class="line">&#125;</span><br><span class="line">if (list1.data &lt; list2.data) &#123;</span><br><span class="line">list1.next = merge(list1.next, list2);</span><br><span class="line">return list1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">list2.next = merge(list1, list2.next);</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ListNode mergeSortedList(ListNode list1, ListNode list2) &#123;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">if (list2 == null) &#123;</span><br><span class="line">return list1;</span><br><span class="line">&#125;</span><br><span class="line">ListNode mergeHead = null;</span><br><span class="line">ListNode current = null;</span><br><span class="line">if (list1.data &lt;= list2.data) &#123;</span><br><span class="line">mergeHead = current = list1;</span><br><span class="line">list1 = list1.next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mergeHead = current = list2;</span><br><span class="line">list2 = list2.next;</span><br><span class="line">&#125;</span><br><span class="line">while (list1 != null &amp;&amp; list2 != null) &#123;</span><br><span class="line">if (list1.data &lt;= list2.data) &#123;</span><br><span class="line">current.next = list1;</span><br><span class="line">current = current.next;</span><br><span class="line">list1 = list1.next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current.next = list2;</span><br><span class="line">current = current.next;</span><br><span class="line">list2 = list2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">current.next = list2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current.next = list1;</span><br><span class="line">&#125;</span><br><span class="line">return mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://hsb786.github.io/2018/04/12/MyBatis/"/>
    <id>https://hsb786.github.io/2018/04/12/MyBatis/</id>
    <published>2018-04-12T05:39:35.000Z</published>
    <updated>2018-04-12T08:45:29.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p><img src="/images/mybatis-logo.png" alt=""></p><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。<br><a id="more"></a></p><h2 id="MyBatis组件"><a href="#MyBatis组件" class="headerlink" title="MyBatis组件"></a>MyBatis组件</h2><p>MyBatis的核心组件分为4个部分：</p><ul><li><p>SqlSessionFactoryBuilder(构造器)：它会根据mybatis的配置文件(Configuration配置类)来生成SqlSessionFactory，这里采用的是分步构建的Builder模式</p></li><li><p>SqlSessionFactory(工厂)：用于生成SqlSession，可以被认为是数据库连接池</p></li><li><p>SqlSession(会话)：既可以直接发送SQL执行并返回结果，也可以获取映射器Mapper接口(动态代理的类)执行SQL得到返回结果，相当于数据库连接(Connection对象)</p></li><li><p>Mapper(映射器)：由一个Java接口和XML文件构成：接口用于给出方法的入参以及返回值，XML给出SQL语句和映射规则。映射器的主要作用就是将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中</p></li></ul><p>注意，无论是映射器还是SqlSession都可以发送SQL到数据库执行，但是为了保证代码的可读性与可维护性，推荐使用Mapper接口编程来完成该操作。</p><h2 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  // do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射器实例（Mapper-Instances）"><a href="#映射器实例（Mapper-Instances）" class="headerlink" title="映射器实例（Mapper Instances）"></a>映射器实例（Mapper Instances）</h3><p>映射器是一个你创建来绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  // do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="如何使用MyBatis"><a href="#如何使用MyBatis" class="headerlink" title="如何使用MyBatis"></a>如何使用MyBatis</h2><p>首先，在MyBatis中有两种XML配置文件，一种是基础配置文件，它只有一个，用于配置一些MyBatis的上下文参数和运行环境；另一种是映射器的XML映射文件，它可以配置映射关系，SQL等等。简单来说，在使用MyBatis的时候，先给出MyBatis的配置文件用于生成SqlSession，然后再给出映射器Mapper的接口与相应的映射XML文件，最后就可以生成Mapper接口的动态代理类来发送SQL获取结果了。</p><p><img src="/images/MyBatis.png" alt=""></p><hr><h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>映射器是mybatis最核心的组件，它由一个接口加上xml文件组成。在映射器中可以配置参数，各类的SQL语句，缓存，级联等内容，并且可以通过映射规则映射到指定的POJO上。映射器的接口与映射xml文件配置使用，可以有效的消除jdbc底层代码。</p><p>映射器的映射xml文件有以下几个元素：</p><ul><li>cache – 给定命名空间的缓存配置</li><li>cache-ref – 其他命名空间缓存配置的引用</li><li>resultMap – 描述如何从数据库结果集中来加载对象，它将提供映射规则</li><li>sql – 可被其他语句引用的可重用语句块，可以定义一部分SQL，然后在其他地方引用</li><li>insert – 映射插入语句，执行后返回一个整数，代表插入的条数</li><li>update – 映射更新语句，执行后返回一个整数，代表更新的条数</li><li>delete – 映射删除语句，执行后返回一个整数，代表删除的条数</li><li>select – 映射查询语句，返回查询结果</li></ul><h2 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h2><p>映射器中的select元素代表SQL的select语句，用于查询。select元素中有以下常用的属性：</p><ul><li>id:在Mapper的命名空间中唯一的标识符。Mapper的命名空间与select元素的id将唯一定位对应的映射器接口的某个方法。</li><li>parameterType：将会传入这条语句的参数类的完全限定名或别名，可以选择Java Bean，Map等参数类型传递给SQL。这个属性是可选的，mybatis可以通过TypeHandler推断出具体传入语句的参数。</li><li>resultType：从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。</li><li>resultMap：映射集的引用，用于结果集的映射，完成结果的映射功能。注意resultType和resultMap不能同时使用。</li><li>flushCache：将其设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</li><li>useCache：将其设置为true，将会导致本条语句的结果被二级缓存，默认值：对select元素为true。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.spring.test.pojo.Person&quot;&gt;</span><br><span class="line">    SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Person getPerson(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure><p>mybatis提供的自动映射功能，只要SQL的列名与POJO的属性名保持一致，同时在mybatis的配置文件中settings元素的autoMappingBehavior是开启的(默认是开启)即可完成自动映射。如果列名与属性名不一致的话，还可以通过SQL的别名机制来处理。比如说，假如原来列名为person_name，属性名为personName，那么在SQL中就可以这么写：select person_name as personName … 这样同样可以完成自动映射。</p><p>这里特别说明关于select元素返回一个对象或者对象集合的问题：</p><ol><li>返回数据类型由DAO中的接口和映射xml文件共同决定。另外，不论是返回单一对象还是对象列表，映射xml中的配置都是一样的，都是resultType=“ . .”类型或resultMap=”resultMap-ref”*。</li><li>每一次mybatis从数据库中select数据之后，都会检查数据条数和DAO中定义的返回值是否匹配。</li><li>若返回一条数据，DAO中定义的返回值是一个对象或对象的List列表，则可以正常匹配，将查询的数据按照DAO中定义的返回值存放。</li><li>若返回多条数据，DAO中定义的返回值是一个对象，则无法将多条数据映射为一个对象，此时mybatis报错。</li></ol><h2 id="resultMap元素"><a href="#resultMap元素" class="headerlink" title="resultMap元素"></a>resultMap元素</h2><p>通过resultType加上mybatis的自动映射可以应对大多数的结果集的映射需求，但是这种方法无法定义更多的属性，比如typeHandler，级联等。为了支持更加复杂的映射，mybatis提供了resultMap属性来完成SQL到Java Bean的映射关系定义。接下来，用resulyMap改写之前使用自动映射的select元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id = &quot;Map&quot; type = &quot;mybatis.spring.test.pojo.Person&quot;&gt;</span><br><span class="line">&lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;</span><br><span class="line">&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;</span><br><span class="line">&lt;result property=&quot;tel&quot; column=&quot;tel&quot;&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">   &lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultMap=&quot;Map&quot;&gt;</span><br><span class="line">       SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>子元素id代表主键，result代表属性，id和result元素的property属性代表POJO的属性名称，column代表SQL的列名，这样就将POJO的属性和SQL的列名进行一一对应了。</p><p>一个完整的resultMap元素的构成有哪些？</p><ul><li>constructor：类在实例化时,用来注入结果到构造方法中</li><li>id：表示哪个列是主键</li><li>result：注入到JavaBean属性的普通结果，配置POJO到SQL列名的映射关系</li><li>association：一个复杂的类型关联;许多结果将包成这种类型</li><li>collection：复杂类型的集</li><li>discriminator：使用结果值来决定使用哪个结果映射</li></ul><p>constructor元素用于配置构造方法，一个POJO可能不存在没有参数的构造方法，就要使用construtor元素来配置了。</p><p>id元素，result元素主要来定义POJO与SQL列名的映射规则，它们有如下属性：</p><ul><li>property:映射规则中的POJO的属性名，可以用导航式字段，例如需要访问Person类的Address属性的id，就可以写成Address . id</li><li>column：对应的SQL的列名</li><li>javaType：Java类型</li><li>jdbcType：数据库类型</li><li>typeHandler：类型处理器，允许使用自定义的类型处理器</li></ul><p>其中association，collection和discriminator这些元素是与结果映射的级联相关的。Mybatis支持级联映射，简单来说，假如我们select一个person类，person类有一个属性为address，address也是一个POJO，也就是说需要再进行一次select才能查询到address类的信息。这里需要说明的是，级联不是必须的，级联可以便捷的获取关联数据，但是如果级联太多的话会影响执行效率，也就是著名的N+1问题(如果有N个关联关系完成了级联，那么只要再加入一个关联关系，就变成了N+1个，所有的级联SQL都会被执行，显然不是所有数据是我们感兴趣的，造成了资源的浪费与性能的浪费)。为了应对级联中的N+1问题，mybatis支持延迟加载，在select的时候并不是一次性取出所有的SQL结果来映射，对于那些不常用的级联数据等到需要的时候再取出。在mybatis的全局配置文件中可以设定延迟加载属性，同时在级联元素association和collection中的fetchType属性也可以定义延迟加载。</p><h2 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert,update,delete"></a>insert,update,delete</h2><p>相比于select来说，insert,update,delete就很简单了，它们执行的结果返回的是整数，用以标识该SQL语句影响了数据库的记录行数，不需要进行结果集的映射。除此之外，insert元素是支持主键回填的，在inser语句中有一个属性useGeneratedKeys，用来控制是否使用数据库生成的主键来回填到POJO，默认值为false。当打开了主键回填之后，还要配置keyProperty或者keyColumn，告诉mybatis把生成的主键放入哪个属性中。至于在实际中用不用得到数据库生成的主键，我也不能完全肯定，这里只要知道mybatis是支持主键回填的即可，使用起来也很容易。</p><h2 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h2><p>这个元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;</span><br><span class="line">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,</span><br><span class="line">    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;</span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>mybatis提供了对SQL语句动态的组装能力，大量的判断都可以在mybatis的映射xml里面配置，大大减少了代码量，提供了灵活性。<br><img src="/images/MyBatis2.png" alt=""></p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if元素使用的场景适用于在SQL语句的where子句中动态地选择某几个判断条件作为SQL语句的一部分进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogWithTitleLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>如果传入的参数title不是null，那么就将 AND title like #{title} 这子句拼接在where之后，这样就可以有条件地包含where子句的一部分。</p><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose(when,otherwise)"></a>choose(when,otherwise)</h2><p>if元素是单条件的，choose元素就是多条件的选择类似java里的switch语句，原理一样，还是接着上面的例子来举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  &lt;choose&gt;</span><br><span class="line">    &lt;when test=&quot;title != null&quot;&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;when test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      AND featured = 1</span><br><span class="line">    &lt;/otherwise&gt;</span><br><span class="line">  &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>上述参考文档中的例子otherwise元素写的是 AND featured = 1 是为了解决前面的所有case都不满足的情况，我建议写成 AND 1 = 1 更好理解。<br>该动态SQL语句的功能：如果参数提供了“title”就按“title”查找，提供了“author”就按“author”查找，若两者都没有提供，就返回所有符合默认条件的查询结果集。</p><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim(where,set)"></a>trim(where,set)</h2><p>前面的例子中的where子句总会有一个默认的查询条件也就是例子中的 state = ‘ACTIVE’ ，如果state也设置成动态的呢？可以通过where,set元素来达到这个需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  &lt;where&gt; </span><br><span class="line">    &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt; </span><br><span class="line">    &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>同样如果是update子句，那么也就相应的set元素，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p>如果where,set都无法满足动态拼接SQL的需求，我们可以使用trim来自定义如何拼接SQL子句，where和set只是mybatis定义好的拼接SQL的方法而已，但这也已经可以满足大多数需求了。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。还是参考文档里买的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>foreach元素允许指定一个集合，声明可以用在元素体内的集合项和索引变量，也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。我们可以将任何可迭代对象（如列表、集合等）和任何的字典或者数组对象传递给foreach作为集合参数。当使用可迭代对象或者数组时，index是当前迭代的次数，item的值是本次迭代获取的元素。当使用字典（或者Map.Entry对象的集合）时，index是键，item是值。</p><h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p>#{}表示一个占位符号，用来传入参数，sql在解析的时候会加上” “,当成字符串来解析，可以防止sql注入</p><p>${}表示一个拼接符号, 传入数据直接显示在生成的sql中，这样就会导致sql注入</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><p><a href="https://lujunqiu.github.io/2018/01/23/MyBatis入门/" target="_blank" rel="noopener">MyBatis入门</a></p><p><a href="https://lujunqiu.github.io/2018/01/26/MyBatis进阶/" target="_blank" rel="noopener">MyBatis进阶</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MyBatis简介&quot;&gt;&lt;a href=&quot;#MyBatis简介&quot; class=&quot;headerlink&quot; title=&quot;MyBatis简介&quot;&gt;&lt;/a&gt;MyBatis简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;p&gt;Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。&lt;br&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="https://hsb786.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>动态代理（转载）</title>
    <link href="https://hsb786.github.io/2018/04/12/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/12/动态代理（转载）/</id>
    <published>2018-04-12T05:13:18.000Z</published>
    <updated>2018-04-12T05:19:05.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理，动态代理可以避免编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象实例。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>JDK从1.3版本已经内置对动态代理实现的支持，我们可以通过java.lang.reflect.Proxy类以及java.lang.reflect包中的InvocationHandler接口来自己实现动态代理。<br><a id="more"></a></p><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义被代理的接口</span><br><span class="line"> */</span><br><span class="line">interface Hello&#123;</span><br><span class="line">    void  sayhello();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 接口的实现类</span><br><span class="line"> */</span><br><span class="line">class helloImpl implements Hello &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayhello() &#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 调用处理程序(InvocationHandler)</span><br><span class="line"> * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。</span><br><span class="line"> * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。</span><br><span class="line"> * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。</span><br><span class="line"> */</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    //目标对象，被代理接口的实现类</span><br><span class="line">    private Object target;</span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * @param proxy　代理类实例</span><br><span class="line">     * @param method　方法</span><br><span class="line">     * @param args　　方法入参</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;------织入前置增强代码-------------&quot;);</span><br><span class="line">        //执行相应的目标方法</span><br><span class="line">        Object rs = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;------织入后置增强代码-------------&quot;);</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //获取动态代理类，生成具体的代理类字节码</span><br><span class="line">        Class proxyClazz = Proxy.getProxyClass(Hello.class.getClassLoader(),Hello.class);</span><br><span class="line">        //通过反射获得代理类的构造函数，并传入参数类型InvocationHandler.class</span><br><span class="line">        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);</span><br><span class="line">        //通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入</span><br><span class="line">        Hello iHello = (Hello) constructor.newInstance(new MyInvocationHandler(new helloImpl()));</span><br><span class="line">        //通过代理对象调用目标方法</span><br><span class="line">        iHello.sayhello();</span><br><span class="line">        //上述生成代理类实例的代码，JDK提供了一个统一的方法Proxy.newProxyInstance()完成。传入参数：类加载器，目标对象实现的接口，InvocationHandler的实现类 </span><br><span class="line">        Hello myHello = (Hello) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new helloImpl().getClass().getInterfaces(), new MyInvocationHandler(new helloImpl()));</span><br><span class="line">        //通过代理对象调用目标方法</span><br><span class="line">        myHello.sayhello();</span><br><span class="line">        </span><br><span class="line">//toString()，hashCode()，equals()也被代理了，都织入了增强逻辑。通过反编译代理类可以看到静态块中初始化了这些method</span><br><span class="line">//        iHello.toString();</span><br><span class="line">//        iHello.hashCode();</span><br><span class="line">//        iHello.equals(new Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：<br>上述方法中，我们通过java.lang.reflect.Proxy实现了动态代理。如果我们反编译动态生成的代理类实例，我们会发现，代理类实例iHello或者myHello实际上继承了Proxy同时实现了Hello接口(由于Java是单继承语法，所以JDK提供的动态代理只能代理接口方法)。代理类实例iHello或者myHello在内部调用被代理的接口方法sayhello()时，是通过调用在代理类的构造方法中传入的new MyInvocationHandler(new helloImpl())的invoke()方法实现的。</p><p>另外，在上述例子中我们在InvocationHandler中写的增强逻辑不仅仅增强了被代理的接口方法，还增强了来自Object的三个方法toString()，hashCode()，equals()。在上述代码末尾注释掉的三行代码的输出可以证实这三个方法确实也织入了增强逻辑。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已知需要被代理的接口方法，以及对应的接口和实现了接口方法的目标对象(被代理对象)，如何通过JDK实现动态代理？</p><ol><li><p>通过实现InvocationHandler接口来自定义自己的InvocationHandler;在实现的过程中，通过传入目标对象(被代理的对象)来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。</p></li><li><p>通过Proxy.getProxyClass获得动态代理类，该类继承了java.lang.reflect.Proxy，同时实现了被代理方法的接口(动态生成代理类的字节码)</p></li><li><p>通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</p></li><li><p>通过构造函数获得代理对象并将自定义的InvocationHandler实例对象传为参数传入，作为代理对象的成员变量来使用</p></li></ol><p>5.通过代理对象调用目标方法，实际是通过上述InvocationHandler实现类中的invoke()方法调用</p><hr><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>动态代理要求的目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理(CODE GENERLIZE LIBRARY)，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p><p>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。</p><hr><h2 id="JDK动态代理和CGLIB代理生成的区别"><a href="#JDK动态代理和CGLIB代理生成的区别" class="headerlink" title="JDK动态代理和CGLIB代理生成的区别"></a>JDK动态代理和CGLIB代理生成的区别</h2><ol><li><p>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</p></li><li><p>CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</p></li><li><p>JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。</p></li></ol><p>在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/12/07/动态代理/" target="_blank" rel="noopener">动态代理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;相比于静态代理，动态代理可以避免编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象实例。&lt;/p&gt;
&lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;p&gt;JDK从1.3版本已经内置对动态代理实现的支持，我们可以通过java.lang.reflect.Proxy类以及java.lang.reflect包中的InvocationHandler接口来自己实现动态代理。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://hsb786.github.io/2018/04/12/HashMap/"/>
    <id>https://hsb786.github.io/2018/04/12/HashMap/</id>
    <published>2018-04-12T03:29:30.000Z</published>
    <updated>2018-04-12T05:10:29.846Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HashMap内部存储结构</strong></p><p>HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。<br><a id="more"></a></p><p><em>基本上都是从别人博客里复制下来的，觉得写的很好，可以直接看底部参考中的网址</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>table，一个存放节点(Node[])的数组，是Hashmap的基础设施，所有的节点都存放于此。</p><p>size，Hashmap存放的键值对的数目，并不等于table数组的长度，因为可能存在链表和红黑树结构。</p><p>modCount，Hashmap的修改次数，是实现fail-fast机制的关键（不清楚fail-fast机制的请看<a href="https://hsb786.github.io/2018/04/09/需要注意的一些东西/">需要注意的一些东西</a>）</p><p>DEFAULT_INITIAL_CAPACITY，表示默认HashMap数组初始大小为16，并且为了后续的rehash操作的方便，Hashmap的数组大小始终为2的整数次幂，即使你输入一个不是2的整数次幂的值，也会变成最小的大于该值的2的整数次幂。</p><p>MAXIMUM_CAPACITY，表示Hashmap数组的最大容量，初始值为2^30。</p><p>DEFAULT_LOAD_FACTOR，表示负载因子，当Hashmap的实际容量超过了(设定容量x负载因子)，就触发rehash操作，默认值为0.75。</p><p>TREEIFY_THRESHOLD，jkd1.8新增的，如果Hashmap数组元素的链表长度超过这个值，就使用红黑树结构代替链表提高查询效率，默认值为8。</p><p>数组内的元素的数据结构继承了Map.Entry，用于存放键值对，另外还包含了hash值和next节点，其中hash值可用于存取节点时来寻址的作用，next节点是实现Hashmap的数组+链表(红黑树)结构的关键。</p><p>在继续看Hashmap的内部方法之前，做个大致的总结：</p><p>Hashmap是用于存放键值对的容器，内部实现是基于数组的，数组中存放的是键值对Node节点，一个Node节点保存了一个键值对信息，同时还保存了next节点，可以形成链表结构(在发生hash冲突的时候)。如果链表长度太长，超过了阀值(默认为8)，那么就自动升级为红黑树结构(高效的平衡查找树)，这样一来，数组元素的节点就成为了红黑树的根节点了。</p><p><img src="/images/HashMap3.png" alt=""></p><p>需要注意的是，在java8中如果hash值相同的key数量大于指定值（默认是8）时使用平衡树来代替链表，这会将get()方法的性能从O(n)提高到O(logn)。</p><hr><p><strong>HashMap的自动扩容机制</strong></p><p>HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶都有62500个元素，这时get()，put()，remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小*loadFactor(加载因子)后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16*0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置。</p><p><img src="/images/HashMap2.png" alt=""></p><p>没扩容前，获取EntryE需要遍历5个元素，扩容之后只需要2次。</p><hr><p><strong>put()</strong></p><ol><li>对key的hashCode()做hash，然后计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长（大于等于TREEIFY_THRESHOLD），就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)；</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果put()方法添加的键值对的键已经存在于Hashmap中，那么就用新的键值的值替代旧值。再看源码put()调用了hash()方法以及putVal()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入的key为null时，hash值为0，也就是说Hashmap的key是可以为null的。对比HashTable，HashTable的key直接进行了hashCode，如果key为null时，会抛出异常，所以HashTable的key不可以是null。<br>具体如何得到key的hash值呢？首先调用key自身的hashcode()得到一个hash值h(32位int类型)，然后将h与h右移16位之后的数进行异或，得到最终的hash值。至于为什么这么做，这是前人总结出来的算法可以使得hash值分布更加均匀,尽量减少冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释，我们可以知道入参都代表了什么：</p><ul><li>hash：表示key的hash值</li><li>key：待存储的key值</li><li>value：待存储的value值</li><li>onlyIfAbsent：是否需要替换相同的value值。如果为true，表示不替换已经存在的value</li><li>evict：如果为false，表示数组是新增模式(暂时不知道啥意思,只在方法的最后出现,但不影响其他逻辑)</li></ul><p>首先判断当前HashMap的数组是否为空，如果为空，就调用resize()方法初始化一个长度为16的数组，并且获取到数组的长度n，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>然后，根据数组的长度n-1的值与入参key的hash值按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。但是，如果取到了数据，也就是这个hash值对应数组的位置上面已经有了键值对存在。那么，就判断这个Node,也就是p的hash值是否与传入的hash相等，然后接着判断key是否相等。如果判断通过，表示要传入的key-val键值对就是tab[i]位置上面的键值对，直接替换即可，不用管后面是链表还是红黑树。如果不是的话，就将这个新的键值对插入链表或者红黑树种即可。插入键值对分两种情况：如果数组元素是链表时，就将节点新增到列表头部。如果链表的长度大于等于红黑树化的阀值-1，就将链表转成红黑树。如果数组元素是红黑树的话，就直接插入键值对Node即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br><span class="line">else &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    if (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    else if (p instanceof TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">            if ((e = p.next) == null) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, null);</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                break;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (e != null) &#123; // existing mapping for key</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，将修改次数加一，同时判断当前的键值对数量是否即将超过阀值，如果即将超过，需要进行resize操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++modCount;</span><br><span class="line">     if (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br></pre></td></tr></table></figure></p><p><strong>get()</strong></p><ol><li>bucket里的第一个节点，直接命中；</li><li>如果有冲突，则通过key.equals(k)去查找对应的entry;</li><li>若为树，则在数中通过key.equals(k)查找，O(logn);</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据入参的key对象计算出key的hash值，调用getNode()方法，再来看看getNode()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过key的hash值与key对象，来查找key对应的键值对的值，如果查找失败则返回null。如何查找的呢？首先，通过key的hash值计算出对应数组的索引，如果索引到的第一个Node节点的key和hash值与入参相等，直接返回该Node。否则，循环遍历下一个节点(可能是链表也有可能是红黑树)。</p><p><strong>resize()</strong></p><p>在resize的时候，数组容量还是要保持为2的整数次幂，所以扩容的时候容量会翻倍(原容量乘以2)，那么在resize的时候原来的元素在新数组中要不就维持原索引，要不就从原位置再移动2次幂，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    //记录原数组的容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">    //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量。如果true，将阈值设置为Integer的最大值，同时数组容量不变</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //定义一个新的容量的数组，同时完成对新数组的赋值</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>为什么线程不安全</strong></p><ol><li>如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(根据hash值计算的bucket一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。</li><li>如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。</li><li>扩容时需要rehash，可能会造成死循环(java8已修复)</li></ol><hr><p><strong>如何线程安全的使用HashMap</strong></p><ol><li>Hashtable<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>效率低，一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以。</p><ol start="2"><li><p>ConcurrentHashMap  （效率高）<br>JUC包中的一个类。ConcurrentHashMap 不仅线程安全而且效率高，因为它包含一个 segment 数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的锁分段技术。</p></li><li><p>SynchronizedMap<br>调用synchronizedMap()方法后返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// synchronizedMap方法</span><br><span class="line">public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">       return new SynchronizedMap&lt;&gt;(m);</span><br><span class="line">   &#125;</span><br><span class="line">// SynchronizedMap类</span><br><span class="line">private static class SynchronizedMap&lt;K,V&gt;</span><br><span class="line">       implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">       private static final long serialVersionUID = 1978198479659022715L;</span><br><span class="line">       private final Map&lt;K,V&gt; m;     // Backing Map</span><br><span class="line">       final Object      mutex;        // Object on which to synchronize</span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">           this.m = Objects.requireNonNull(m);</span><br><span class="line">           mutex = this;</span><br><span class="line">       &#125;</span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">           this.m = m;</span><br><span class="line">           this.mutex = mutex;</span><br><span class="line">       &#125;</span><br><span class="line">       public int size() &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.size();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean isEmpty() &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.isEmpty();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean containsKey(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.containsKey(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean containsValue(Object value) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.containsValue(value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V get(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.get(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V put(K key, V value) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.put(key, value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V remove(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.remove(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 省略其他方法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。</p><hr><p><strong>总结</strong></p><ol><li>HashMap在处理冲突时使用链表存储相同索引的元素。</li><li>从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。</li><li>当从链表切换到平衡树时，HashMap迭代的顺序将会改变。不过这并不会造成什么问题，因为HashMap并没有对迭代的顺序提供任何保证。</li><li>从Java 1中就存在的Hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。</li><li>除了Hashtable之外，WeakHashMap和IdentityHashMap也不会在频繁冲突的情况下使用平衡树。</li><li>使用HashMap之所以会产生冲突是因为使用了键对象的hashCode()方法，而equals()和hashCode()方法不保证不同对象的hashCode是不同的。需要记住的是，相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。</li><li>在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/02/03/译-Java中HashMap和LinkedHashMap如何解决冲突/" target="_blank" rel="noopener">Java 8中HashMap和LinkedHashMap如何解决冲突 </a></p><p><a href="https://yemengying.com/2016/05/07/threadsafe-hashmap/" target="_blank" rel="noopener">如何线程安全的使用 HashMap</a></p><p><a href="https://lujunqiu.github.io/2018/01/07/看看HashMap源码/" target="_blank" rel="noopener">看看HashMap源码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;HashMap内部存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>String与StringBuffer</title>
    <link href="https://hsb786.github.io/2018/04/11/String%E4%B8%8EStringBuffer/"/>
    <id>https://hsb786.github.io/2018/04/11/String与StringBuffer/</id>
    <published>2018-04-11T06:17:41.000Z</published>
    <updated>2018-04-11T06:50:46.678Z</updated>
    
    <content type="html"><![CDATA[<p>String不可变，StringBuffer可变，why ?<br><a id="more"></a></p><hr><p>看源码</p><p><strong>String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br></pre></td></tr></table></figure></p><p>可以看出String底层是用char数组实现的，由于被final修饰所以引用不能改变。</p><p><strong>为什么要这样设计</strong></p><ol><li>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</li><li>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。</li><li>因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</li><li>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</li><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li></ol><hr><p><strong>StringBuffer</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A cache of the last value returned by toString. Cleared</span><br><span class="line">     * whenever the StringBuffer is modified.</span><br><span class="line">     */</span><br><span class="line">    private transient char[] toStringCache;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        toStringCache = null;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //AbstractStringBuilder中的方法</span><br><span class="line">     public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">        if (str == null)</span><br><span class="line">            return appendNull();</span><br><span class="line">        int len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(0, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //String中的方法</span><br><span class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</span><br><span class="line">        if (srcBegin &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcEnd &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>StringBuffer中append中的实现</p><ol><li>调用super.append(str)， super类为AbstractStringBuilder</li><li>AbstractStringBuilder.append(str)中通过调用String类的getChars()方法</li><li>String.getChars()，调用System.arraycopy()完成数组的复制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* @param      src      the source array.</span><br><span class="line">   * @param      srcPos   starting position in the source array.</span><br><span class="line">   * @param      dest     the destination array.</span><br><span class="line">   * @param      destPos  starting position in the destination data.</span><br><span class="line">   * @param      length   the number of array elements to be copied.</span><br><span class="line"> public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                      Object dest, int destPos,</span><br><span class="line">                                      int length);</span><br></pre></td></tr></table></figure><p>本地方法的实现。</p><p>src原数组，srcPoc原数组起始位；dest目标数组，destPos目标数组起始位,length复制个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      int[] int1= &#123;1,2,3,4&#125;;</span><br><span class="line">int[] int2= &#123;10,11,12,13,14,15,16,17&#125;;</span><br><span class="line">System.arraycopy(int1, 0, int2, 0, 3);</span><br><span class="line">      System.out.println(Arrays.toString(int2));  //out  [1, 2, 3, 13, 14, 15, 16, 17]</span><br></pre></td></tr></table></figure><hr><p><em>参考</em></p><blockquote><p>[如何理解 String 类型值的不可变？][<a href="https://www.zhihu.com/question/20618891/answer/147575525]" target="_blank" rel="noopener">https://www.zhihu.com/question/20618891/answer/147575525]</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String不可变，StringBuffer可变，why ?&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>工具网站</title>
    <link href="https://hsb786.github.io/2018/04/11/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
    <id>https://hsb786.github.io/2018/04/11/工具网站/</id>
    <published>2018-04-11T04:22:11.000Z</published>
    <updated>2018-04-11T04:50:18.850Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">图标</a></p><p><a href="http://tool.oschina.net/encode?type=4" target="_blank" rel="noopener">在线编码转换</a></p><p><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码</a></p><p><a href="http://www.autojcode.com/code/sql2class.jsp" target="_blank" rel="noopener">Sql转Class</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://fontawesome.com/icons?d=gallery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图标&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tool.oschina.net/encode?ty
      
    
    </summary>
    
    
      <category term="工具" scheme="https://hsb786.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://hsb786.github.io/2018/04/10/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://hsb786.github.io/2018/04/10/HTTP状态码/</id>
    <published>2018-04-10T12:27:44.000Z</published>
    <updated>2018-04-11T04:16:31.866Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。<br><a id="more"></a></p><table><thead><tr><th>status</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>200</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td>202</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>300</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td>302</td><td>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>400</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td></tr><tr><td>401</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td>417</td><td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td>421</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>500</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td>504</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="https://hsb786.github.io/2018/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://hsb786.github.io/2018/04/10/反转链表/</id>
    <published>2018-04-10T12:14:31.000Z</published>
    <updated>2018-04-12T05:27:41.953Z</updated>
    
    <content type="html"><![CDATA[<p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 维护两个节点，一个指向当前节点，一个指向下一个节点 </span><br><span class="line"> * 缺点，需要new 对象，占用内存</span><br><span class="line"> * @author: husb</span><br><span class="line"> * @date: 2018年4月10日 下午7:44:22</span><br><span class="line"> */</span><br><span class="line">private static ListNode reverseList(ListNode head) &#123;</span><br><span class="line">ListNode result = new ListNode(head.data);</span><br><span class="line">ListNode t;</span><br><span class="line">while (head.next != null) &#123;</span><br><span class="line">t = result;</span><br><span class="line">result = new ListNode(head.next.data);</span><br><span class="line">result.next = t;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description: 需要维护三个节点，当前，前一个，下一个</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午7:57:58 </span><br><span class="line"> */</span><br><span class="line">private static ListNode reverseList2(ListNode head) &#123;</span><br><span class="line">ListNode result = null;</span><br><span class="line">ListNode t = head;</span><br><span class="line">ListNode preNode = null;</span><br><span class="line">while (t != null) &#123;</span><br><span class="line">ListNode nextNode = t.next;</span><br><span class="line">if (nextNode == null) &#123;</span><br><span class="line">result = t;</span><br><span class="line">&#125;</span><br><span class="line">t.next = preNode;</span><br><span class="line">preNode = t;</span><br><span class="line">t = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接用Stack</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义一个函数，输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第K个节点</title>
    <link href="https://hsb786.github.io/2018/04/10/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://hsb786.github.io/2018/04/10/链表中倒数第K个节点/</id>
    <published>2018-04-10T12:13:03.000Z</published>
    <updated>2018-04-12T05:28:13.600Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，输出该链表的倒数第K个节点。为了符合大多数人的习惯，本题从1开始计数，即链表尾节点是倒数第一个节点。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 维护两个节点，后一个在前一个的后k位。</span><br><span class="line"> * 之后一起走，如果后一个节点为最后一个节点就停下</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午7:29:09 </span><br><span class="line"> */</span><br><span class="line">public static ListNode findKthNodeFromEnd(ListNode head, int k) &#123;</span><br><span class="line">ListNode node2 = head;</span><br><span class="line">int i = 1;</span><br><span class="line">if(k&lt;=0) &#123;</span><br><span class="line">System.out.println(&quot;必须从1开始&quot;);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">while (i++ &lt; k) &#123;</span><br><span class="line">if (node2.next == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">node2 = node2.next;</span><br><span class="line">&#125;</span><br><span class="line">while (node2.next != null) &#123;</span><br><span class="line">head = head.next;</span><br><span class="line">node2 = node2.next;</span><br><span class="line">&#125;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个链表，输出该链表的倒数第K个节点。为了符合大多数人的习惯，本题从1开始计数，即链表尾节点是倒数第一个节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>调整数组顺序使奇数位于偶数之前</title>
    <link href="https://hsb786.github.io/2018/04/10/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E4%B9%8B%E5%89%8D/"/>
    <id>https://hsb786.github.io/2018/04/10/调整数组顺序使奇数位于偶数之前/</id>
    <published>2018-04-10T12:10:37.000Z</published>
    <updated>2018-04-12T05:28:10.149Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数数组，实现一个函数来调整该数组中数组的顺序，使得所有的奇数位于数组的前半部分，偶数位于数组的后半部分。<br><a id="more"></a></p><p><strong>快速排序的思想</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">    * 快速排序的思想</span><br><span class="line">    * 左边一个指针向右移，遇到偶数停止；</span><br><span class="line">    * 右边一直指针向左移，遇到奇数停止。</span><br><span class="line">    * 两个值交换</span><br><span class="line">    * @author: husb   </span><br><span class="line">    * @date: 2018年4月10日 下午7:12:45 </span><br><span class="line">    */</span><br><span class="line">private static void reorderOddEven(int[] arr) &#123;</span><br><span class="line">    int left = -1;</span><br><span class="line">    int right = arr.length ;</span><br><span class="line">    while (left != right&amp;&amp;left&lt;=right) &#123;</span><br><span class="line">        while(arr[++left]%2!=0&amp;&amp;left&lt;arr.length-1);</span><br><span class="line">        while(arr[--right]%2==0&amp;&amp;right&gt;=0);</span><br><span class="line">        if(left&lt;right) &#123;</span><br><span class="line">            int t=arr[left];</span><br><span class="line">            arr[left]=arr[right];</span><br><span class="line">            arr[right]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数组的顺序，使得所有的奇数位于数组的前半部分，偶数位于数组的后半部分。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在O(1)时间内删除链表节点</title>
    <link href="https://hsb786.github.io/2018/04/10/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/"/>
    <id>https://hsb786.github.io/2018/04/10/在O(1)时间内删除链表节点/</id>
    <published>2018-04-10T12:04:16.000Z</published>
    <updated>2018-04-12T05:27:44.657Z</updated>
    
    <content type="html"><![CDATA[<p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 由于时间复杂度要求为O(1)，</span><br><span class="line"> * 只能将加一个节点的值复制到要删除的节点，之后再将下一个节点删除</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午3:43:23</span><br><span class="line"> */</span><br><span class="line">public static void deleteNode(ListNode head, ListNode node) &#123;</span><br><span class="line">//若为头节点，则将头节点设为head.next</span><br><span class="line">if (node == head) &#123;</span><br><span class="line">head = head.next;</span><br><span class="line">//若为未节点，只能遍历了</span><br><span class="line">&#125; else if (node.next == null) &#123;</span><br><span class="line">ListNode t=head;</span><br><span class="line">while(t.next!=node) &#123;</span><br><span class="line">t=t.next;</span><br><span class="line">&#125;</span><br><span class="line">t.next=null;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//若为中间节点，则将下个节点的值复制到要删除的阶段，并且移除一个节点</span><br><span class="line">node.data = node.next.data;</span><br><span class="line">node.next = node.next.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://hsb786.github.io/2018/04/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://hsb786.github.io/2018/04/10/二进制中1的个数/</id>
    <published>2018-04-10T08:11:44.000Z</published>
    <updated>2018-04-12T05:27:32.509Z</updated>
    
    <content type="html"><![CDATA[<p>请实现一个函数，输入一个整数，输出该整数二进制表示中1的个数。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * n&amp;(n-1)，将二进制表示中的最低位的1变为0</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午3:23:02 </span><br><span class="line"> */</span><br><span class="line">private static int numberOfOne(int n) &#123;</span><br><span class="line">int count=0;</span><br><span class="line">while(n!=0) &#123;</span><br><span class="line">n=n&amp;(n-1);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请实现一个函数，输入一个整数，输出该整数二进制表示中1的个数。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="https://hsb786.github.io/2018/04/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://hsb786.github.io/2018/04/10/旋转数组的最小数字/</id>
    <published>2018-04-10T08:11:33.000Z</published>
    <updated>2018-04-12T05:27:51.508Z</updated>
    
    <content type="html"><![CDATA[<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。<br><a id="more"></a><br><strong>旋转数组的特点：</strong></p><ol><li>旋转之后的数组可以分为两个排序的子数组，且前面的子数组的元素都大于或等于后面子数组的元素。 </li><li>最小或者最大元素位于两个子数组的分界</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 由于旋转数组的特点，前一个数组一定大于后一个数组。数组内部是升序的。</span><br><span class="line"> * 所以就可以使用二分查找。</span><br><span class="line"> * 定义minIndex为0，highIndex为length-1</span><br><span class="line"> * 若中间位大于array[minIndex]，则代表中间位处于前面部分,将minIndex设为midIndex；</span><br><span class="line"> * 小于则处于后面部分,将highIndex设为midIndex</span><br><span class="line"> * 最终minIndex位于前一个数组的最后一位，highIndex位于后一个数组的第一位</span><br><span class="line"> * 显然最小值就是highIndex所在的值。</span><br><span class="line"> * 特殊情况，但minIndex与highIndex上的值相等时，无法判断中间值是在前，还是在后。</span><br><span class="line"> * 所以只能用顺序查找</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午2:56:26 </span><br><span class="line"> */</span><br><span class="line">public static int findMin(int[] array) &#123;</span><br><span class="line">int lowIndex = 0;</span><br><span class="line">int highIndex = array.length - 1;</span><br><span class="line">int midIndex = (lowIndex + highIndex) / 2;</span><br><span class="line">// 当代查找数组第一位大于最后一位时，代表是旋转数组</span><br><span class="line">while (array[lowIndex] &gt;= array[highIndex]) &#123;</span><br><span class="line">// 临界条件 前面最后一位，后面第一位。 后面第一位就是最小值</span><br><span class="line">if (highIndex - lowIndex == 1) &#123;</span><br><span class="line">return array[highIndex];</span><br><span class="line">&#125;</span><br><span class="line">// 当左下标的元素等于右下标的元素时，无法判断中间位是位于前面还是后面的。</span><br><span class="line">// 只能用顺序查找</span><br><span class="line">if (array[lowIndex] == array[highIndex]) &#123;</span><br><span class="line">return findMinInOrder(array, lowIndex, highIndex);</span><br><span class="line">&#125;</span><br><span class="line">// 当中间位大于前面第一位时，代表处于前面</span><br><span class="line">if (array[midIndex] &gt; array[lowIndex]) &#123;</span><br><span class="line">lowIndex = midIndex;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 否则处于后面</span><br><span class="line">highIndex = midIndex;</span><br><span class="line">&#125;</span><br><span class="line">// 计算中间位</span><br><span class="line">midIndex = (lowIndex + highIndex) / 2;</span><br><span class="line">&#125;</span><br><span class="line">//已排好序，返回低位即可</span><br><span class="line">return array[lowIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description: 当有重复元素的时候，无法确定中间的元素是前面的还是后面的</span><br><span class="line"> * @author: husb</span><br><span class="line"> * @date: 2018年4月10日 下午2:33:52</span><br><span class="line"> */</span><br><span class="line">private static int findMinInOrder(int[] array, int lowIndex, int highIndex) &#123;</span><br><span class="line">int result = array[lowIndex];</span><br><span class="line">for (int i = lowIndex + 1; i &lt;= highIndex; i++) &#123;</span><br><span class="line">if (result &gt; array[i]) &#123;</span><br><span class="line">result = array[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个递增排序数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用两个队列实现一个栈</title>
    <link href="https://hsb786.github.io/2018/04/10/%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/"/>
    <id>https://hsb786.github.io/2018/04/10/用两个队列实现一个栈/</id>
    <published>2018-04-10T08:11:19.000Z</published>
    <updated>2018-04-12T05:28:03.670Z</updated>
    
    <content type="html"><![CDATA[<p>用两个队列实现一个栈<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Queue方法: </span><br><span class="line"> * offer() 添加一个元素，失败则返回false </span><br><span class="line"> * pool() 移除并返回队列头部元素，无则返回null </span><br><span class="line"> * peek() 返回头部元素  无则返回null</span><br><span class="line"> */</span><br><span class="line">private static Queue&lt;Object&gt; queue1 = new LinkedList&lt;&gt;();</span><br><span class="line">private static Queue&lt;Object&gt; queue2 = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private static void push(Object obj) &#123;</span><br><span class="line">if (!queue1.isEmpty()) &#123;</span><br><span class="line">queue1.offer(obj);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">queue2.offer(obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;入栈:&quot; + obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将一个队列里的数据都剪切给另一个队列中，只保留最后一位。</span><br><span class="line"> * 这样弹出的数据就是栈尾数据</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午1:55:11 </span><br><span class="line"> */</span><br><span class="line">private static void pop() &#123;</span><br><span class="line">if (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;栈里没有数据&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (queue1.isEmpty()) &#123;</span><br><span class="line">while (queue2.size() &gt; 1) &#123;</span><br><span class="line">queue1.offer(queue2.poll());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;出栈:&quot; + queue2.poll());</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">while (queue1.size() &gt; 1) &#123;</span><br><span class="line">queue2.offer(queue1.poll());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;出栈:&quot; + queue1.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个队列实现一个栈&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://hsb786.github.io/2018/04/10/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://hsb786.github.io/2018/04/10/用两个栈实现队列/</id>
    <published>2018-04-10T08:10:52.000Z</published>
    <updated>2018-04-12T05:27:59.328Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static Stack&lt;Object&gt; stack1 = new Stack&lt;Object&gt;();</span><br><span class="line">private static Stack&lt;Object&gt; stack2 = new Stack&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * stack1用来存放压入的元素</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午1:19:07 </span><br><span class="line"> */</span><br><span class="line">public static void appendTail(Object item) &#123;</span><br><span class="line">stack1.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void deleteHead() &#123;</span><br><span class="line">//当stack2中有数据，直接弹出</span><br><span class="line">if (!stack2.isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;栈顶:&quot; + stack2.pop());</span><br><span class="line">return;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//stack2压入stack1弹出的数据,这样stack2就是一个队列</span><br><span class="line">while (!stack1.isEmpty()) &#123;</span><br><span class="line">stack2.push(stack1.pop());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!stack2.isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;栈顶:&quot; + stack2.pop());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;栈中没有元素&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈实现一个队列。队列的声明如下：请实现他的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://hsb786.github.io/2018/04/10/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://hsb786.github.io/2018/04/10/替换空格/</id>
    <published>2018-04-10T08:08:27.000Z</published>
    <updated>2018-04-12T05:27:55.838Z</updated>
    
    <content type="html"><![CDATA[<p>请实现一个函数，将一个字符串中的空格替换成“%20”。<br><a id="more"></a><br>例如，当字符串为We Are Happy.则经过替换之后的字符串We%20Are%20Happy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * beginIndex记录比较起始下标，spaceIndex记录空格下标。</span><br><span class="line"> * 添加beginIndex到spaceIndex的数据到StringBuilder中。</span><br><span class="line"> * beginIndex设为spaceIndex；spaceIndex重新计算</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 下午12:26:55 </span><br><span class="line"> */</span><br><span class="line">public static String replaceSpace(String str) &#123;</span><br><span class="line">//一开始想到的办法，一个字符一个字符的比，</span><br><span class="line">//这样会创建多个string对象,String.valueOf()内部是通过new String()来实现的。</span><br><span class="line">/*</span><br><span class="line"> * char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); for</span><br><span class="line"> * (char c : chars) &#123; sb.append(c == &apos; &apos; ? &quot;%20&quot; : String.valueOf(c)); &#125;</span><br><span class="line"> */</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">int beginIndex = 0;</span><br><span class="line">int spaceIndex = str.indexOf(&quot; &quot;, beginIndex);</span><br><span class="line">while (spaceIndex &gt; 0) &#123;</span><br><span class="line">sb.append(str.substring(beginIndex, spaceIndex)).append(&quot;%20&quot;);</span><br><span class="line">beginIndex = spaceIndex + 1;</span><br><span class="line">spaceIndex = str.indexOf(&quot; &quot;, beginIndex);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(str.substring(beginIndex, str.length()));</span><br><span class="line">return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请实现一个函数，将一个字符串中的空格替换成“%20”。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二维数组的查找</title>
    <link href="https://hsb786.github.io/2018/04/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://hsb786.github.io/2018/04/10/二维数组的查找/</id>
    <published>2018-04-10T04:01:22.000Z</published>
    <updated>2018-04-12T05:26:43.517Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从左下角开始比，查找的数字大于遍历值右移；查找的数字小于遍历值上移</span><br><span class="line"> * @author: husb   </span><br><span class="line"> * @date: 2018年4月10日 上午11:55:27 </span><br><span class="line"> */</span><br><span class="line">public static boolean find(int targer, int[][] array) &#123;</span><br><span class="line">int rows = array.length;</span><br><span class="line">int columns = array[0].length;</span><br><span class="line">int i = rows - 1, j = 0;</span><br><span class="line">while (targer != array[i][j]) &#123;</span><br><span class="line">if (targer &gt; array[i][j]) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 0 || j &lt; 0 || i &gt; rows || j &gt; columns) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://hsb786.github.io/2018/04/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://hsb786.github.io/2018/04/10/线程池/</id>
    <published>2018-04-10T02:13:01.000Z</published>
    <updated>2018-04-12T05:27:05.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Exexutor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，可以用来控制线程的启动、执行和关闭，可以简化并发编程的操作。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。Executor框架包括：线程池、Executor、Exexutors、ExecutorService、CompletionService、Future、Callable等。<br><a id="more"></a><br>ExecutorService接口对Executor接口进行了扩展，提供了返回Future对象，终止，关闭线程池等方法。</p><p>通过ExecutorService.submit()方法返回的Future对象，还可以取消任务的执行。Future提供了Cancel()方法用来取消pending中的任务。</p><p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的。然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等。抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法。然后ThreadPoolExecutor继承了类AbstractExecutorService。</p><table><thead><tr><th>Executor</th><th>ExecutorService</th></tr></thead><tbody><tr><td>Executor是java线程池的核心接口，用来并发执行提交的任务</td><td>ExecutorService是Executor接口的扩展，提供了异步执行和关闭线程的方法</td></tr><tr><td>提供execute()方法用来提交任务</td><td>提供submit方法用来提交任务</td></tr><tr><td>execute方法无返回值</td><td>submit方法返回Future对象</td></tr><tr><td>不能取消任务</td><td>Future.cancel()中断线程停止任务</td></tr><tr><td>没有提供和关闭线程池有关的方法</td><td>提供了关闭线程池的方法</td></tr></tbody></table><hr><p><strong>关于Callable和Future</strong></p><p>Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。</p><p>Future提供了三种功能：</p><ol><li>判断任务是否完成</li><li>能够中断任务</li><li>能够获取执行结果</li></ol><hr><p><strong>关于Future中的cancel()</strong></p><p>Future对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后再需要时检查Future是否已经有了结果，如果任务已经执行完成，就可以通过Future.get()方法获得执行结果。需要注意的是，Future.get()方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。</p><p>cancel()传入true时会中断线程停止任务，传入false则会让线程正常执行完成。</p><p>传入false只能取消还没有开始的任务，若任务已经开始了，就任由其运行下去。</p><hr><p><strong>FutureTask</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; </span><br><span class="line"></span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">    * Sets this Future to the result of its computation</span><br><span class="line">    * unless it has been cancelled.</span><br><span class="line">    */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask既可以做为Runnable被线程执行，又可以作为Future得到Callable的返回值</p><hr><p><strong>ThreadPoolExecutor</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中核心线程数量</td></tr><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>非核心线程存活时间</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>workQueue</td><td>存放任务的队列</td></tr><tr><td>threadFactory</td><td>用来生产线程的工厂</td></tr><tr><td>handler</td><td>当线程池中不能再放入任务时执行的handler</td></tr></tbody></table><p>任务提交给线程池之后的处理策略：</p><ol><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个认为，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出来执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过KeepAliveTime，线程也会被终止</li></ol><p><img src="/images/threadPool.png" alt=""></p><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ol><li>prestartCoreThread()：初始化一个核心线程；</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ol><hr><p><strong>任务缓存队列及排队策略</strong></p><p>workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><ol><li>ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小</li><li>LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE</li><li>synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</li></ol><hr><p>参考</p><blockquote><p><a href="http://www.cnblogs.com/xiaoxi/p/7692250.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p><p><a href="http://codepub.cn/2016/02/01/Java-multi-thread-Callable-interface-and-thread-pool/" target="_blank" rel="noopener">Java多线程之Callable接口及线程池</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Executor框架&quot;&gt;&lt;a href=&quot;#Executor框架&quot; class=&quot;headerlink&quot; title=&quot;Executor框架&quot;&gt;&lt;/a&gt;Executor框架&lt;/h2&gt;&lt;p&gt;Exexutor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，可以用来控制线程的启动、执行和关闭，可以简化并发编程的操作。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。Executor框架包括：线程池、Executor、Exexutors、ExecutorService、CompletionService、Future、Callable等。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础总结</title>
    <link href="https://hsb786.github.io/2018/04/09/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>https://hsb786.github.io/2018/04/09/java基础总结/</id>
    <published>2018-04-09T13:28:54.000Z</published>
    <updated>2018-04-11T04:17:39.893Z</updated>
    
    <content type="html"><![CDATA[<p><strong>初始化顺序</strong></p><ol><li>父类（静态变量，静态语句块）</li><li>子类（静态变量，静态语句块）</li><li>父类（实例变量，普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量，普通语句块）</li><li>子类（构造函数）<a id="more"></a></li></ol><hr><p><strong>Object</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line"></span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line"></span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123;&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>异常</strong></p><p>Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。其中Error用来表示JVM无法处理的错误，Exception分为两种：</p><ol><li><strong>受检异常（checked exception）</strong>：需要try…catch…语句捕获并进行处理，并且可以从一场恢复</li><li><strong>非受检异常（unchecked exception）</strong>：是程序运行时错误，例如除0会引发Arithmetic Exceptino，此时程序崩溃并且无法恢复 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;初始化顺序&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父类（静态变量，静态语句块）&lt;/li&gt;
&lt;li&gt;子类（静态变量，静态语句块）&lt;/li&gt;
&lt;li&gt;父类（实例变量，普通语句块）&lt;/li&gt;
&lt;li&gt;父类（构造函数）&lt;/li&gt;
&lt;li&gt;子类（实例变量，普通语句块）&lt;/li&gt;
&lt;li&gt;子类（构造函数）
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
</feed>
