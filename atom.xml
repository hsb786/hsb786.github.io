<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-15T11:48:20.538Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javap</title>
    <link href="https://hsb786.github.io/2018/04/15/javap/"/>
    <id>https://hsb786.github.io/2018/04/15/javap/</id>
    <published>2018-04-15T11:11:13.000Z</published>
    <updated>2018-04-15T11:48:20.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line">private volatile int n;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sub() &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap T01 输出T01的public域及方法</p><p><img src="/images/javap01.png" alt=""></p><p>javap -c T01 列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用</p><p><img src="/images/javap02.png" alt=""></p><p>javap -p T01 输出所有类和成员</p><p><img src="/images/javap03.png" alt=""></p><p>javap -v T01 输出栈大小，方法参数的个数</p><p><img src="/images/javap04.png" alt=""></p><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-help 帮助</span><br><span class="line">-l 输出行和变量的表</span><br><span class="line">-public 只输出public方法和域</span><br><span class="line">-protected 只输出public和protected类和成员</span><br><span class="line">-package 只输出包，public和protected类和成员，这是默认的</span><br><span class="line">-p -private 输出所有类和成员</span><br><span class="line">-s 输出内部类型签名</span><br><span class="line">-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，</span><br><span class="line">-verbose 输出栈大小，方法参数的个数</span><br><span class="line">-constants 输出静态final常量</span><br></pre></td></tr></table></figure><h3 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h3><table><thead><tr><th>major version</th><th>java版本</th></tr></thead><tbody><tr><td>46</td><td>2</td></tr><tr><td>47</td><td>3</td></tr><tr><td>48</td><td>4</td></tr><tr><td>49</td><td>5</td></tr><tr><td>50</td><td>6</td></tr><tr><td>51</td><td>7</td></tr><tr><td>52</td><td>8</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://hsb786.github.io/2018/04/14/Proxy/"/>
    <id>https://hsb786.github.io/2018/04/14/Proxy/</id>
    <published>2018-04-14T08:14:06.000Z</published>
    <updated>2018-04-14T11:25:27.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>通过<code>java.lang.reflect.Proxy</code>类以及<code>java.lang.reflect.InvocationHandler</code>接口来实现动态代理</p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p>InvocationHandler接口的唯一方法：</p><p><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code></p><ul><li>proxy:    代理类实例</li><li>method:   方法</li><li>args:     方法入参</li></ul><a id="more"></a><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>public static Object newProxyInstance Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p><ul><li>loader： ClassLoader，定义由哪个ClassLoader对象类对生成的代理对象进行加载</li><li>interfaces：该实现类的所有接口</li><li>h：调用处理程序，表示当这个动态代理对象在调用方法时，会关联到哪一个InvocationHandler对象上</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hello &#123;</span><br><span class="line">void say(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义被代理的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl implements Hello &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void say(String name) &#123;</span><br><span class="line">System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。</span><br><span class="line"> * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。</span><br><span class="line"> * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    //目标对象，被代理接口的实现类</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public DynamicProxy(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * @param proxy 代理类实例</span><br><span class="line"> * @param method 方法</span><br><span class="line"> * @param args 方法入参</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description: 获取代理对象</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy() &#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClientProxy &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new HelloImpl();</span><br><span class="line">DynamicProxy dynamicProxy = new DynamicProxy(hello);</span><br><span class="line">Hello helloProxy = dynamicProxy.getProxy();</span><br><span class="line">helloProxy.say(&quot;hh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">        Before</span><br><span class="line">        Hello hh</span><br><span class="line">        After</span><br></pre></td></tr></table></figure></p><p>用DynamicProxy类去包装HelloImpl实例，然后再调用Proxy类的工厂方法newProxyInstance()去动态地创建一个Hello接口的代理类，调用这个代理类的say()方法。</p><p>被代理方法的调用都是通过InvocationHadler的invoke来实现的。</p><p>Proxy.newProxyInstance这个方法的第二个参数，我们给这个代理对象提供了一组什么接口，那么这个代理对象就会实现了这组接口，这个时候我们可以将这个代理对象强制转化为这组接口中的任意一个。</p><p>Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p><p>动态代理，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，代理类也要变。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有用武之地了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；在实现的过程中，通过传入目标对象（被代理的对象）来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。</li><li>通过Proxy.newProxyInstance来动态创建代理类</li><li>通过代理对象调用目标方法，实际上是通过InvocationHandler实现类的invoke()方法调用</li></ol><p>能否代理没有接口的类?</p><p>CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。</p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CGLibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123;</span><br><span class="line">return (T) Enhancer.create(cls, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。</p><p>与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGLibProxy cgLibProxy = new CGLibProxy();</span><br><span class="line">HelloImpl helloProxy2 = cgLibProxy.getProxy(HelloImpl.class);</span><br><span class="line">helloProxy2.say(&quot;cg&quot;);</span><br></pre></td></tr></table></figure><p>与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象</p><h2 id="JDK动态代理和CGLIB代理生成的区别"><a href="#JDK动态代理和CGLIB代理生成的区别" class="headerlink" title="JDK动态代理和CGLIB代理生成的区别"></a>JDK动态代理和CGLIB代理生成的区别</h2><ol><li>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</li><li>CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</li><li>JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。</li></ol><p>在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159788" target="_blank" rel="noopener">Proxy 那点事儿 </a></p><p><a href="https://lujunqiu.github.io/2017/12/07/动态代理/" target="_blank" rel="noopener">动态代理</a></p><p><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java的动态代理机制详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt;类以及&lt;code&gt;java.lang.reflect.InvocationHandler&lt;/code&gt;接口来实现动态代理&lt;/p&gt;
&lt;h2 id=&quot;InvocationHandler&quot;&gt;&lt;a href=&quot;#InvocationHandler&quot; class=&quot;headerlink&quot; title=&quot;InvocationHandler&quot;&gt;&lt;/a&gt;InvocationHandler&lt;/h2&gt;&lt;p&gt;InvocationHandler接口的唯一方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy:    代理类实例&lt;/li&gt;
&lt;li&gt;method:   方法&lt;/li&gt;
&lt;li&gt;args:     方法入参&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://hsb786.github.io/2018/04/14/ThreadLocal/"/>
    <id>https://hsb786.github.io/2018/04/14/ThreadLocal/</id>
    <published>2018-04-14T07:06:57.000Z</published>
    <updated>2018-04-14T07:55:17.544Z</updated>
    
    <content type="html"><![CDATA[<p>早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。</p><a id="more"></a><p>ThreadLocal常用方法：</p><ol><li>public void set(T value)：将值放入线程局部变量中</li><li>public T get()：从线程局部变量中获取值</li><li>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</li><li>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </li></ol><p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。 </p><h2 id="ThreadLocal简单实现"><a href="#ThreadLocal简单实现" class="headerlink" title="ThreadLocal简单实现"></a>ThreadLocal简单实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, T&gt; container = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;());</span><br><span class="line"></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        container.put(Thread.currentThread(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        T value = container.get(thread);</span><br><span class="line">        if (value == null &amp;&amp; !container.containsKey(thread)) &#123;</span><br><span class="line">            value = initialValue();</span><br><span class="line">            container.put(thread, value);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        container.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected T initialValue() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-具体有哪些使用案例呢？"><a href="#ThreadLocal-具体有哪些使用案例呢？" class="headerlink" title="ThreadLocal 具体有哪些使用案例呢？"></a>ThreadLocal 具体有哪些使用案例呢？</h2><p>通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。(每个线程应该拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接)</p><p> 注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！ </p><hr><p> <em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159489" target="_blank" rel="noopener">ThreadLocal 那点事儿</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IOC-实现原理（转载）</title>
    <link href="https://hsb786.github.io/2018/04/14/IOC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/14/IOC-实现原理（转载）/</id>
    <published>2018-04-14T05:22:40.000Z</published>
    <updated>2018-04-14T07:54:10.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部</p></blockquote><p> IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。<br><a id="more"></a><br>从实例出发，先看看以下 Action 代码。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public class ProductAction extends BaseAction &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Request(&quot;GET:/product/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getProductById(long productId) &#123;</span><br><span class="line">        if (productId == 0) &#123;</span><br><span class="line">            return new Result(ERROR_PARAM);</span><br><span class="line">        &#125;</span><br><span class="line">        Product product = productService.getProduct(productId);</span><br><span class="line">        if (product != null) &#123;</span><br><span class="line">            return new Result(OK, product);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Result(ERROR_DATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上使用了两个自定义注解：@Bean 与 @Inject。<br>在 ProductAction 类上标注了 @Bean 注解，表示该类会交给“容器”处理，以便加入依赖注入框架。</p><p>在 produceService 字段上标注了 @Inject 注解，表示该字段将会被注入进来，而无需 new ProductServiceImpl()，实际上 new 这件事情不是我们做的，而是框架做的，也就是说控制权正好反过来了，所以“依赖注入（DI）”也称作“控制反转（IoC）”。</p><p>那么，应该如何实现依赖注入框架呢？首先还是看看下面的 BeanHelper 类吧。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 遍历 Bean Map</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 获取该接口所有的实现类</span><br><span class="line">                            List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                            if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                // 获取第一个实现类</span><br><span class="line">                                Class&lt;?&gt; implementClass = implementClassList.get(0);</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                beanField.setAccessible(true); // 必须使该字段可访问</span><br><span class="line">                                beanField.set(beanInstance, implementInstance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，依赖注入其实分为两个步骤：1. 通过反射创建实例；2. 获取需要注入的接口实现类并将其赋值给该接口。以上代码中的两个 for 循环就是干这两件事情的。  </p><p>依赖注入框架实现完毕！ </p><p>大家上面看到的 BeanHelper 类，其实兼任了两种职责：1.初始化所有的 Bean 类；2.实现依赖注入。</p><p>这违法了设计模式中的“单一责任原则”，所有有必要将其重构一下，现在的 BeanHelper 类更加苗条了，只是负责初始化 Bean 类而已。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line"></span><br><span class="line">    // Bean 类 =&gt; Bean 实例</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，依赖注入功能放哪里呢？我搞了一个 IOCHelper，用这个类来实现 IOC 功能。代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class IOCHelper &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean 类</span><br><span class="line">            Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 判断接口上是否标注了 @Impl 注解</span><br><span class="line">                            Class&lt;?&gt; implementClass = null;</span><br><span class="line">                            if (interfaceClass.isAnnotationPresent(Impl.class)) &#123;</span><br><span class="line">                                // 获取强制指定的实现类</span><br><span class="line">                                implementClass = interfaceClass.getAnnotation(Impl.class).value();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                // 获取该接口所有的实现类</span><br><span class="line">                                List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                                if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                    // 获取第一个实现类</span><br><span class="line">                                    implementClass = implementClassList.get(0);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 若存在实现类，则执行以下代码</span><br><span class="line">                            if (implementClass != null) &#123;</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                if (implementInstance != null) &#123;</span><br><span class="line">                                    beanField.setAccessible(true); // 取消类型安全检测（可提高反射性能）</span><br><span class="line">                                    beanField.set(beanInstance, implementInstance); // beanInstance 是普通实例，或 CGLib 动态代理实例（不能使 JDK 动态代理实例）</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见，IOCHelper 是依赖于 BeanHelper 的。这样分离，还有一个好处，就是方便实现 ServiceHelper 与 AOPHelper。也就是说，首先通过 BeanHelper 初始化所有的 Bean 类，然后依次初始化 ServiceHelper、IOCHelper、AOPHelper，这个顺序不能搞错。因为在 ServcieHelper 中，对 Servcie 实现类进行了动态代理，所有保证了 IOC 注入进来的是代理类，而并非目标类。 </p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/158992" target="_blank" rel="noopener">IOC 实现原理 </a></p><p><a href="https://my.oschina.net/flashsword/blog/192551" target="_blank" rel="noopener">1000行代码读懂Spring（一）- 实现一个基本的IoC容器 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://hsb786.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Servlet（转载）</title>
    <link href="https://hsb786.github.io/2018/04/14/Servlet%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/14/Servlet（转载）/</id>
    <published>2018-04-14T04:35:27.000Z</published>
    <updated>2018-04-14T05:14:16.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet概述"><a href="#Servlet概述" class="headerlink" title="Servlet概述"></a>Servlet概述</h2><p>Servlet是在Java中创建web应用程序的J2ee 服务端技术。<code>javax.servlet</code> 和 <code>javax.servlet.http</code>包中提供了编写servlet的接口和类。</p><p>所有的servlet都要实现<code>javax.servlet.Servlet</code>接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的<code>GenericServlet</code>类。<code>HttpServlet</code>类中提供了用于处理http请求的<code>doGet()</code>和 <code>doPost()</code>等方法。<br><a id="more"></a><br>多数情况下，web应用程序都使用http协议，所以，我们多数时候都通过继承<code>HttpServlet</code>类来实现自己的Servlet。</p><h2 id="Servlet-API的层次结构"><a href="#Servlet-API的层次结构" class="headerlink" title="Servlet API的层次结构"></a>Servlet API的层次结构</h2><p><code>javax.servlet.Servlet</code>是Servlet Api的最上层接口。还有一些其他的接口和类是我们在使用servlet的时候需要关注的。在Servlet 3.0规范中，建议使用的注解我们也需要了解。</p><p><img src="/images/Servlet-Hierarchy.png" alt="servlet API层次结构"></p><h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>javax.servlet.Servlet<code></code> 是Servlet Api的最上层接口，Servlet接口定义了一系列servlet的生命周期方法（init、service、destory等）。所有的Servlet类都需要继承这个接口。该接口中定义了以下方法：</p><p><code>public abstract void init(ServletConfig paramServletConfig) throws ServletException</code> – 该方法由servlet容器调用，用于初始化servlet以及servlet配置参数。在init()方法执行之前，servlet是无法处理用户请求的。在servlet生命周期中该方法只会被调用一次，他会使servlet类不同区别于普通的java对象。我们可以扩展该方法来初始化资源，如数据库连接、socket连接等。</p><p><code>public abstract ServletConfig getServletConfig()</code> – 该方法返回一个servlet配置对象，其中包含servlet中所有初始化参数和启动配置。我们可以用这个方法来获取servlet的初始化参数，这些参数一般被定义在web.xml或servlet 3的注解中。后面会介绍ServletConfig接口。</p><p><code>public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</code> – 该方法负责处理客户端请求。当servlet容器收到客户端请求时，它会创建一个新线程并执行service()方法，并把request 和 response作为参数传递给该方法。servlet通常运行在多线程环境中，所以开发人员应该使用同步来保证访问共享资源的线程安全性问题。</p><p><code>public abstract String getServletInfo()</code> – 这个方法返回包含servlet信息的字符串，比如它的作者、版本和版权。返回的字符串应该是纯文本，不能有标记符号。</p><p><code>public abstract void destroy()</code> – 这个方法在整个servlet生命周期中只会被调用一次来关闭所有资源。有点像Java中的finalize方法。</p><h2 id="ServletConfig-接口"><a href="#ServletConfig-接口" class="headerlink" title="ServletConfig 接口"></a>ServletConfig 接口</h2><p><code>javax.servlet.ServletConfig</code>用于给servlet传递配置信息（译者注：描述Servlet本身的相关配置信息）。每个servlet都有属于它自己的ServletConfig对象，该对象由servlet容器负责实例化。可以在web.xml中提供初始化参数，当然在servlet3.0中可以使用注解。我们可以使用<code>getServletConfig()</code>方法来获取ServletConfig的对象。</p><p>ServletConfig接口中主要方法：</p><p><code>public abstract ServletContext getServletContext()</code> – 该方法返回servlet的ServletContext对象。在下一节中我们将介绍ServletContext接口。</p><p><code>public abstract Enumeration getInitParameterNames()</code> – 该方法返回servlet中所有初始化参数的名字的枚举。如果没有初始化参数定义，该方法将返回空枚举。</p><p><code>public abstract String getInitParameter(String paramString)</code> – 这种方法可以通过名字来获取特定的初始化参数值。如果参数的名称不存在，则返回null。</p><h2 id="ServletContext-接口"><a href="#ServletContext-接口" class="headerlink" title="ServletContext 接口"></a>ServletContext 接口</h2><p><code>javax.servlet.ServletContext</code>接口用于描述应用程序的相关信息。ServletContext是一个独立的对象，可用于web应用程序中所有的servlet。当我们想要一些初始化的参数可用于web应用程序中多个或全部servlet时，我们可以使用ServletContext对象并且在web.xml中使用&lt; context-param&gt;标签定义参数。我们可以通过ServletConfig 中的 <code>getServletContext()</code>方法得到ServletContext对象。</p><p>ServletContext接口中的主要方法：</p><p><code>public abstract ServletContext getContext(String uripath)</code> – 这个方法返回指定的uripath的ServletContext对象，如果uripath不可用或不可见则返回null。</p><p><code>public abstract URL getResource(String path) throws MalformedURLException</code> – 返回的一个代表某个资源的URL对象。资源可以是本地文件系统、远程文件系统、数据库，甚至是不知道如何获取资源的具体细节的远程网络站点。</p><p><code>public abstract InputStream getResourceAsStream(String path)</code> – 这个方法返回给定的资源路径的一个输入流对象。如果没有找到返回null。</p><p><code>public abstract RequestDispatcher getRequestDispatcher(String urlpath)</code> – 这个方法一般被用于获得对于另外一个servlet的引用。获取到RequestDispatcher对象之后，就可以通过他把一个请求转发出去(forward或者include)。</p><p><code>public abstract void log(String msg)</code> – 该方法用于把指定的消息字符串写入servlet日志文件中。</p><p><code>public abstract Object getAttribute(String name)</code> – 按照指定的name返回对象属性。可以使用<code>public abstract Enumeration getAttributeNames()</code>活的所有对象属性的枚举。</p><p><code>public abstract void setAttribute(String paramString, Object paramObject)</code> – 该方法用于在应用的范围内设置属性。该属性可以被可以访问当前ServletContext的所有servle获取到。可以使用<code>public abstract void removeAttribute(String paramString)</code>删除一个属性。</p><p><code>String getInitParameter(String name)</code> – 该方法用于返回在web.xml中定义的初始化参数的值。如果指定的name在web.xml中并没有匹配到，则返回null。可以使用<code>Enumeration getInitParameterNames()</code>得到所有初始化参数的名称的枚举。</p><p>boolean setInitParameter(String paramString1, String paramString2)<code></code> – 可以使用该方法设置应用中的初始化参数。</p><h2 id="ServletRequest-接口"><a href="#ServletRequest-接口" class="headerlink" title="ServletRequest 接口"></a>ServletRequest 接口</h2><p>ServletRequest接口是用来向servlet提供客户端请求信息。每一个客户端请求到达Servlet容器的时候，他都会创建一个ServletRequest对象，并将其传递对应的servlet的service()方法。</p><p>ServletRequest接口中的主要方法：</p><p><code>Object getAttribute(String name)</code> – 返回指定的参数名对应的属性值。如果对应的参数不存在则返回null。我们可以使用<code>getAttributeNames()</code>方法来获取请求中的所有属性名称的枚举。接口中同样提供了设置值和删除值的方法。</p><p><code>String getParameter(String name)</code> – 以字符串的形式返回请求参数值。我们可以使用getParameterNames()方法来获取请求参数名称的枚举。</p><p><code>String getServerName()</code> – 返回服务器的主机名</p><p><code>int getServerPort()</code> – 返回服务器监听的端口号。</p><p>ServletRequest的子接口HttpServletRequest中还包含了一些和session、cookies等相关的方法。</p><blockquote><p>译者注：该接口中提供了getAttribute和getParameter两个方法，都是用于获取参数（属性）值的，那么这两个方法有什么区别呢？或者说Attribute和Parameter的区别是什么呢？</p><p>答：</p><p>来源不同</p><blockquote><p>   参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的；</p><p>   属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的.</p></blockquote><p>操作不同</p><blockquote><p>   参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取；</p><p>   属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute()</p></blockquote><p>数据类型不同</p><blockquote><p>   参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。</p><p>   属性（attribute）的值可以是任意一个Object类型。</p></blockquote></blockquote><h2 id="ServletResponse-接口"><a href="#ServletResponse-接口" class="headerlink" title="ServletResponse 接口"></a>ServletResponse 接口</h2><p>servlet使用ServletResponse向客户端发送响应。和每ServletRequest类似，一个客户端请求到达Servlet容器的时候，他都会创建一个ServletResponse对象，并将其传递对应的servlet的service()方法。最终，该response对象用于给客户端生成html响应。</p><p>ServletResponse接口中的主要方法：</p><p><code>void addCookie(Cookie cookie)</code> – 向响应中添加cookie</p><p><code>void addHeader(String name, String value)</code>– 设置响应头</p><p><code>String encodeURL(java.lang.String url)</code> – 通过重写Url的方式支持session，在Url中增加sessionId，如果不需要重写，直接返回该url</p><p><code>String getHeader(String name)</code> – 返回指定的头信息。</p><p><code>void sendRedirect(String location)</code>–重定向到指定的地址</p><p><code>void setStatus(int sc)</code> – 设置响应的状态码</p><h2 id="RequestDispatcher-接口"><a href="#RequestDispatcher-接口" class="headerlink" title="RequestDispatcher 接口"></a>RequestDispatcher 接口</h2><p>RequestDispatcher 接口用于把一个请求转发给同一个servlet上下文中的其他的资源（Html、jsp、servlet）来处理。也可以用它来把另一个资源的内容包含到响应中。此接口用于同一个servlet上下文中的servlet相互沟通。</p><p>RequestDispatcher 接口的主要方法： <code>void forward(ServletRequest request, ServletResponse response)</code> – 把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。</p><p><code>void include(ServletRequest request, ServletResponse response)</code> – 把另一个资源的内容包含到当前响应中。</p><blockquote><p>译者注：forward和include的区别：</p><p>如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。</p><p>用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。</p></blockquote><p>在servlet中可以使用<code>getRequestDispatcher(String path)</code>来获取一个RequestDispatcher。路径必须以/开头，并且是针对于当前context的根路径的相对地址。</p><h2 id="GenericServlet-类"><a href="#GenericServlet-类" class="headerlink" title="GenericServlet 类"></a>GenericServlet 类</h2><p>GenericServlet是一个实现类Servlet, ServletConfig 和 Serializable 的抽象类。他提供了Servlet生命周期中的主要方法以及ServletConfig中的方法的默认实现。当我们定义自己的servlet的时候，只要继承了该方法，我们只需要重写我们关注的方法就可以了，其他的不关注的方法都可以使用其默认实现。该类中定义的大部分方法都是让用户更放方便的使用Servlet和ServletConfig接口中定义的常用方法。</p><p>GenericServlet 类中有一个重要的方法——无参数的init方法。如果我们必须在处理请求之前初始化一些资源，那么可以重写该方法。</p><h2 id="HTTPServlet-类"><a href="#HTTPServlet-类" class="headerlink" title="HTTPServlet 类"></a>HTTPServlet 类</h2><p>HTTPServlet 类是GenericServlet类的子类，主要为基于HTTP创建的web应用程序提供了一些支持。其中定义了一些可重写HTTP方法。</p><p><code>doGet()</code>, 用于处理get请求 <code>doPost()</code>, 用于处理post请求 <code>doPut()</code>, 用于处理put请求 <code>doDelete()</code>, 用于处理delete请求</p><h2 id="Servlets属性（Attributes）"><a href="#Servlets属性（Attributes）" class="headerlink" title="Servlets属性（Attributes）"></a>Servlets属性（Attributes）</h2><p>Servlet属性用于servlet之间的沟通，可以在web应用程序中设置、获取甚至删除属性值。servlet属性有三种范围：request、session、application</p><p>ServletRequest， HttpSession 和 ServletContext接口为request、session和application范围提供了get/set/remove的方法。</p><h2 id="Servlet-3中的注解"><a href="#Servlet-3中的注解" class="headerlink" title="Servlet 3中的注解"></a>Servlet 3中的注解</h2><p>在servlet 3之前，所以的servlet映射和初始化参数都是定义在web.xml文件中的，随着应用中的servlet数量增多，这种方式就很难维护。</p><p>servlet 3中使用支持使用java注解来定义servlet、filter、listener以及初始化参数。</p><p>servlet 3 中主要的注解：</p><p><code>WebServlet</code> – 可以在servlet类中使用该注解来定义初始化参数、loadOnStartup的值、description信息和url匹配模式(pattern)等。该注解的属性中 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存。该注释声明的类必须继承HttpServlet。</p><p><code>WebInitParam</code> – 该注解用于给servlet 或者 filter定义初始化参数（包括name,value和description）。可以在 WebFilter 或者 WebServlet中使用该注解。</p><p><code>WebFilter</code> – 该注解用于声明一个servlet过滤器。使用该注解声明的类必须实现javax.servlet.Filter接口。</p><p><code>WebListener</code> – 该注解用于声明一个事件监听器。</p><hr><p><em>参考</em></p><p><a href="http://www.hollischuang.com/archives/1219" target="_blank" rel="noopener">[译]Java Servlet初级知识</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Servlet概述&quot;&gt;&lt;a href=&quot;#Servlet概述&quot; class=&quot;headerlink&quot; title=&quot;Servlet概述&quot;&gt;&lt;/a&gt;Servlet概述&lt;/h2&gt;&lt;p&gt;Servlet是在Java中创建web应用程序的J2ee 服务端技术。&lt;code&gt;javax.servlet&lt;/code&gt; 和 &lt;code&gt;javax.servlet.http&lt;/code&gt;包中提供了编写servlet的接口和类。&lt;/p&gt;
&lt;p&gt;所有的servlet都要实现&lt;code&gt;javax.servlet.Servlet&lt;/code&gt;接口。该接口中定义了一个Servlet生命周期中的所有方法。如果要实现一个通用的Servlet，可以通过继承Java Servlet API中提供的&lt;code&gt;GenericServlet&lt;/code&gt;类。&lt;code&gt;HttpServlet&lt;/code&gt;类中提供了用于处理http请求的&lt;code&gt;doGet()&lt;/code&gt;和 &lt;code&gt;doPost()&lt;/code&gt;等方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何重置一个ArrayList--clear vs removeAll （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%AF%91-%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE%E4%B8%80%E4%B8%AAArrayList-clear-vs-removeAll/"/>
    <id>https://hsb786.github.io/2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/</id>
    <published>2018-04-13T07:55:17.000Z</published>
    <updated>2018-04-13T08:01:13.361Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置<code>clear</code>或<code>removeAll</code>。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现<code>java.lang.OutOfMemoryError: Java Heap Space</code>。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。<br><a id="more"></a></p><h2 id="Clear-vs-RemoveAll-Collection-c"><a href="#Clear-vs-RemoveAll-Collection-c" class="headerlink" title="Clear() vs RemoveAll(Collection c)"></a>Clear() vs RemoveAll(Collection c)</h2><p>为了更好的比较这两个方法，阅读他们源码是很重要的。可以在<code>java.utils.ArrayList</code>类中找到clear()方法，不过为了方便我将它引入到了这里。下面的代码来自JDK 1.7.0_40版本。如果你想要学习更多的有关性能监控和调优的知识，我强烈建议阅读Scott Oaks写的Java Performance the Definitive Guide,它包含了java 7和一点java 8。下面是clear()的代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Removes all of the elements from this list.The list will </span><br><span class="line"> * be empty after this call returns. </span><br><span class="line"> */ </span><br><span class="line"> public void clear() &#123; </span><br><span class="line"> modCount++; // clear to let GC do its work </span><br><span class="line"> for (int i = 0; i &lt; size; i++) </span><br><span class="line"> elementData[i] = null; </span><br><span class="line"> size = 0; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>大家可以看出，clear()在循环遍历ArrayList，并且将每一个元素都置为null，使它们在没有被外部引用的情况下可以被垃圾回收。相似的，我们可以在<code>java.util.AbstractCollection</code>类中查看removeAll(Collention c)的代码，下面是代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">//判断对象是否为null</span><br><span class="line">      Objects.requireNonNull(c);</span><br><span class="line">      boolean modified = false;</span><br><span class="line">      Iterator&lt;?&gt; it = iterator();</span><br><span class="line">      while (it.hasNext()) &#123;</span><br><span class="line">          if (c.contains(it.next())) &#123;</span><br><span class="line">              it.remove();</span><br><span class="line">              modified = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return modified;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  这个方法会检查迭代器顺序返回的每个元素是否包含在特定的集合中。如果存在，调用迭代器的remove方法将它从集合中移除。因为会用到contains方法，removeAll的复杂度是O(n^2)。所以在想要重置一个大的ArrayList时，这种方法是绝对不可取的。下面我们比较一下两者在重置一个包含100K个元素时的性能差异。</p><h2 id="删除一个包含100k个元素的列表中的所有元素"><a href="#删除一个包含100k个元素的列表中的所有元素" class="headerlink" title="删除一个包含100k个元素的列表中的所有元素"></a>删除一个包含100k个元素的列表中的所有元素</h2><p>  我本来想在例子中尝试重置一个包含10M个元素的列表，不过在超过半个小时等待removeAll()结束后，我决定将元素的数量降为100K。在这种情况下，两个方法的差距也是很明显的。removeAll()比clear()多花费了10000倍的时间。事实上，在API中clear()和removeAll(Collection c)这两个方法的目的是不同的。clear()方法是为了通过删除所有元素而重置列表，而removeAll(Collection c)是为了从集合中删除某些存在于另一个提供的集合中的元素，并不是为了从集合中移除所有元素。所以如果你的目的是删除所有元素，用clear(),如果你的目的是删除某些存在于另一集合的元素，那么选择removeAll(Collection c)方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList; </span><br><span class="line">/**</span><br><span class="line"> * Java Program to remove all elements from list in Java and comparing </span><br><span class="line"> * performance of clearn() and removeAll() method. </span><br><span class="line"> * * @author Javin Paul </span><br><span class="line"> */ </span><br><span class="line"> public class ArrayListResetTest &#123; </span><br><span class="line"> </span><br><span class="line"> private static final int SIZE = 100_000; </span><br><span class="line"> public static void main(String args[]) &#123; </span><br><span class="line"> </span><br><span class="line"> // Two ArrayList for clear and removeAll </span><br><span class="line"> ArrayList numbers = new ArrayList(SIZE); </span><br><span class="line"> ArrayList integers = new ArrayList(SIZE); </span><br><span class="line"> // Initialize ArrayList with 10M integers </span><br><span class="line"> for (int i = 0; i &amp;lt; SIZE; i++) &#123; </span><br><span class="line"> numbers.add(new Integer(i)); </span><br><span class="line"> integers.add(new Integer(i)); </span><br><span class="line"> &#125; </span><br><span class="line"> // Empty ArrayList using clear method </span><br><span class="line"> long startTime = System.nanoTime(); </span><br><span class="line"> numbers.clear(); </span><br><span class="line"> long elapsed = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by clear to empty ArrayList of 1M elements (ns): &quot; + elapsed); </span><br><span class="line"> // Reset ArrayList using removeAll method </span><br><span class="line"> startTime = System.nanoTime(); </span><br><span class="line"> integers.removeAll(integers); </span><br><span class="line"> long time = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by removeAll to reset ArrayList of 1M elements (ns): &quot; + time); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> Output: </span><br><span class="line"> Time taken by clear to empty ArrayList of 100000 elements (ns): 889619 </span><br><span class="line"> Time taken by removeAll to reset ArrayList of 100000 elements (ns): 36633112126</span><br></pre></td></tr></table></figure><p>  由于程序使用了两个arrayList存储Integers，所以在运行时要确保有足够的内存，尤其是你想比较在列表存有1M个元素时，两种方法的性能差异。另外，由于使用了在数字中加入下划线的特性，所以需要java7来运行。如果没有JDK7，也可以移除SIZE常量中的下划线。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/10/26/译-如何重置一个ArrayList-clear-vs-removeAll/" target="_blank" rel="noopener"> 【译】如何重置一个ArrayList–clear vs removeAll </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置&lt;code&gt;clear&lt;/code&gt;或&lt;code&gt;removeAll&lt;/code&gt;。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现&lt;code&gt;java.lang.OutOfMemoryError: Java Heap Space&lt;/code&gt;。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>【译】以生产者消费者为例阐述如何使用wait，notify和notifyAll （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%AF%91-%E4%BB%A5%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%BA%E4%BE%8B%E9%98%90%E8%BF%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wait%EF%BC%8Cnotify%E5%92%8CnotifyAll/"/>
    <id>https://hsb786.github.io/2018/04/13/译-以生产者消费者为例阐述如何使用wait，notify和notifyAll/</id>
    <published>2018-04-13T07:34:36.000Z</published>
    <updated>2018-04-13T07:49:23.236Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:<code>Producer</code>(生产者)和<code>Consumer</code>(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。<br><a id="more"></a></p><h2 id="在代码中展示如何使用wait和notify"><a href="#在代码中展示如何使用wait和notify" class="headerlink" title="在代码中展示如何使用wait和notify"></a>在代码中展示如何使用wait和notify</h2><p>尽管wait和notify是相当基础的概念，并且他们定义在<code>Object</code>类中，但要想在代码中使用他们并非易事。你可以在面试中让面试者通过手写代码解决Producer者和Consumer者问题来验证，我相信大多数人都会犯在错误的地方同步，没有在正确的对象上调用wait之类的错。讲真，这些常常会困惑许多程序员。第一个困惑点来自怎样调用wait方法，因为wait方法并不是定义在Thread类中，所以不能简单的Thread.wait()。而许多Java开发者习惯于Thread.sleep(),所以常常错误的想用同样的方式调用wait。实际上，wait()方法需要在一个被两个线程共享的对象上调用，例如在Producer者和消费Consumer的问题中，两个线程共享对象是一个队列。第二个困惑点来自wait方法应该在同步块还是同步方法中调用？如果使用同步块，那么哪个对象应该放到同步块中？这个对象和你想要获得锁的对象应该是同一个。在我们的例子中，这个对象就是两个线程共享的队列。</p><h2 id="在循环中使用wait和notify，而不是If代码块中"><a href="#在循环中使用wait和notify，而不是If代码块中" class="headerlink" title="在循环中使用wait和notify，而不是If代码块中"></a>在循环中使用wait和notify，而不是If代码块中</h2><p>在你已经了解需要在一个共享的对象上调用wait方法后，接下来就是学会避免许多java开发者犯的错—在If代码块中调用wait而不是while循环中。因为需要在一定的条件下调用wait，比如Producer线程要在队列满了的情况下调用wait，所以第一反应都是使用If语句。但是，在If代码块中调用wait会产生<code>bug</code>，因为线程存在一定的可能在等待条件没有改变的情况下<a href="https://hsb786.github.io/2018/04/09/术语/">假唤醒(spurious wake up)</a>。所以如果没有使用循环在线程唤醒后检查等待条件，可能会造成尝试在已经满了的队列中插入元素或者在空了的队列中取元素。这就是为什么我们要在while循环中调用wait而不是if。</p><h2 id="Java中使用wait-notify-notifyAll-的例子"><a href="#Java中使用wait-notify-notifyAll-的例子" class="headerlink" title="Java中使用wait(),notify(),notifyAll()的例子"></a>Java中使用wait(),notify(),notifyAll()的例子</h2><p>下面是在Java中使用wait(),notify(),notifyAll()的例子。在这个程序中，有两个线程(PRODUCTOR和CONSUMER)，用继承了Thread类的Producer和Consumer类实现。Prodcuer和Consumer的业务逻辑写在他们各自的run()方法中。并且实现一个LinkedList，当做共享队列。Producer在一个死循环中不断在队列中插入随机数，直到队列满了。我们会检查while(queue.size == maxSize),需要注意的是在检查之前需要给队列加上同步锁以保证在检查时没有另一个线程修改队列。如果队列满了，PRODUCER线程就会休眠，直到CONSUMER消费了队列中的元素并且调用notify()方法通知PRODUCER线程。<code>wait和notify都是在共享的对象(我们的例子中是队列)上调用的</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.Random;</span><br><span class="line">/**</span><br><span class="line"> * Simple Java program to demonstrate How to use wait, notify and notifyAll()</span><br><span class="line"> * method in Java by solving producer consumer problem.</span><br><span class="line"> *</span><br><span class="line"> * @author Javin Paul</span><br><span class="line"> */</span><br><span class="line">public class MultipleThread &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        System.out.println(&quot;How to use wait and notify method in Java&quot;);</span><br><span class="line">        System.out.println(&quot;Solving Producer Consumper Problem&quot;);</span><br><span class="line">        Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class="line">        int maxSize = 10;</span><br><span class="line">        Thread producer = new Producer(buffer, maxSize, &quot;PRODUCER&quot;);</span><br><span class="line">        Thread consumer = new Consumer(buffer, maxSize, &quot;CONSUMER&quot;);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Producer Thread will keep producing values for Consumer</span><br><span class="line"> * to consumer. It will use wait() method when Queue is full</span><br><span class="line"> * and use notify() method to send notification to Consumer</span><br><span class="line"> * Thread.</span><br><span class="line"> * @author WINDOWS 8</span><br><span class="line"> * */</span><br><span class="line">class Producer extends Thread &#123;</span><br><span class="line">    private Queue&lt;Integer&gt; queue;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    public Producer(Queue&lt;Integer&gt; queue, int maxSize, String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                while (queue.size() == maxSize) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out .println(&quot;Queue is full, &quot; + &quot;Producer thread waiting for &quot; + &quot;consumer to take something from queue&quot;);</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Random random = new Random();</span><br><span class="line">                int i = random.nextInt();</span><br><span class="line">                System.out.println(&quot;Producing value : &quot; + i);</span><br><span class="line">                queue.add(i);</span><br><span class="line">                queue.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Consumer Thread will consumer values form shared queue.</span><br><span class="line"> * It will also use wait() method to wait if queue is</span><br><span class="line"> * empty. It will also use notify method to send * notification to producer thread after consuming values</span><br><span class="line"> * from queue.</span><br><span class="line"> * @author WINDOWS 8</span><br><span class="line"> **/</span><br><span class="line">class Consumer extends Thread &#123;</span><br><span class="line">    private Queue&lt;Integer&gt; queue;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    public Consumer(Queue&lt;Integer&gt; queue, int maxSize, String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                while (queue.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(&quot;Queue is empty,&quot; + &quot;Consumer thread is waiting&quot; + &quot; for producer thread to put something in queue&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; catch (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; System.out.println(&quot;Consuming value : &quot; + queue.remove());</span><br><span class="line">                queue.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Output </span><br><span class="line">How to use wait and notify method in Java </span><br><span class="line">Solving Producer Consumper Problem </span><br><span class="line">Queue is empty,Consumer thread is waiting for producer thread to put something in queue </span><br><span class="line">Producing value : -1692411980 </span><br><span class="line">Producing value : 285310787 </span><br><span class="line">Producing value : -1045894970 </span><br><span class="line">Producing value : 2140997307 </span><br><span class="line">Producing value : 1379699468 </span><br><span class="line">Producing value : 912077154 </span><br><span class="line">Producing value : -1635438928 </span><br><span class="line">Producing value : -500696499 </span><br><span class="line">Producing value : -1985700664 </span><br><span class="line">Producing value : 961945684 </span><br><span class="line">Queue is full, Producer thread waiting for consumer to take something from queue Consuming value : -1692411980 </span><br><span class="line">Consuming value : 285310787 </span><br><span class="line">Consuming value : -1045894970 </span><br><span class="line">Consuming value : 2140997307 </span><br><span class="line">Consuming value : 1379699468 </span><br><span class="line">Consuming value : 912077154 </span><br><span class="line">Consuming value : -1635438928 </span><br><span class="line">Consuming value : -500696499 </span><br><span class="line">Consuming value : -1985700664 </span><br><span class="line">Consuming value : 961945684 </span><br><span class="line">Queue is empty,Consumer thread is waiting for producer thread to put something in queue</span><br></pre></td></tr></table></figure><h2 id="使用wait，notify，notifyAll需要注意的"><a href="#使用wait，notify，notifyAll需要注意的" class="headerlink" title="使用wait，notify，notifyAll需要注意的"></a>使用wait，notify，notifyAll需要注意的</h2><ul><li>在Java中可以使用wait，notify，notifyAll完成多线程(不仅仅是两个线程)的内部通信。</li><li>在同步方法或同步块中使用wait，notify，notifyAll，否则JVM会抛出IllegalMonitorStateException</li><li>在循环中调用wait，notify。</li><li>在线程共享的对象上调用wait</li><li>偏向选择notifyAll，而不是notify</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中可以利用use,notify,notifyAll来完成线程之间的通信。举个例子，假设你的程序中有两个线程(eg:&lt;code&gt;Producer&lt;/code&gt;(生产者)和&lt;code&gt;Consumer&lt;/code&gt;(消费者))，Producer要和Consumer通信，通知Consumer队列中有元素了可以开始消费。相似的，Consumer也需要通知Producer队列中有空闲可以插入元素了。一个线程可以可以在一定条件下调用wait方法暂停什么都不做。比如，在Producer和consumer的问题中，当队列满了时Producer需要调用wait，当队列为空时Consumer需要调用wait方法。如果一些线程在等待某些条件变为真，可以在条件改变时使用notify和notifyAll通知他们并唤醒他们。Notify方法和NotifyAll方法都可以发送通知，不同的是，notify只能向等待的线程中的一个发送通知，不保证接受到通知的是哪个线程，而NotifyAll会向所有线程发送通知。所以如果只有一个线程等待对象锁，notify和notifyAll都会通知到它。在这个java多线程的教程中，将利用生产者，消费者的例子讲述在Java中如何使用wait，notify和notifyAll实现线程内部通信。另外，如果大家对掌握多线程和并发很感兴趣，强烈建议大家阅读Brian Goetz写的Java Concurrency in Practice。如果没看过这本书，你的Java多线程之旅是不完整的🙀。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【译】Java8中的扩展(default/extension)方法 （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/Java-8%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95-Default-Defender-Extension-%E6%96%B9%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/13/Java-8中的扩展-Default-Defender-Extension-方法/</id>
    <published>2018-04-13T07:14:18.000Z</published>
    <updated>2018-04-13T07:24:37.104Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8允许开发者使用<code>default</code>和<code>static</code>两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。<br><a id="more"></a></p><h2 id="Default方法的例子"><a href="#Default方法的例子" class="headerlink" title="Default方法的例子"></a>Default方法的例子</h2><p>Java 8让我们可以通过default关键字为接口添加非抽象的方法。这一特性也被称作Extension(扩展)方法。下面是第一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Multiplication&#123; </span><br><span class="line">    </span><br><span class="line">    int multiply(int a, int b); </span><br><span class="line">    </span><br><span class="line">    default int square(int a)&#123; </span><br><span class="line">        return multiply(a, a); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了抽象方法multiply()之外，接口Multiplication还包含一个default方法square()。任何实现Multiplication接口的类只需实现抽象方法multiply，default方法square()可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Multiplication product = new Multiplication()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int multiply(int x, int y)&#123;</span><br><span class="line">        return x*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    int square = product.square(2);</span><br><span class="line">    int multiplication = product.multiply(2, 3);</span><br></pre></td></tr></table></figure><p>product是个匿名类。这段代码有点啰嗦了，用了6行实现一个简单地乘法的功能。我们可以利用lambda表达式来简化一下代码，lambda表达式也是Java 8中新引入的。因为我们的接口只包含一个抽象方法，而且lambda表达式也是SAM(Single Abstract method单一抽象方法)类型的。我们可以用lambda表达式来替代匿名类将代码简化成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiplication lambda = (x, y) -&gt; x*y; </span><br><span class="line">int product = lambda.multiply(3, 4); </span><br><span class="line">int square = lambda.square(4);</span><br></pre></td></tr></table></figure></p><p>以上就是在接口中使用default方法的例子。现在，你可以毫无顾虑的在旧的接口中扩展新的方法，只要这些方法是default或static的就不用担心会破坏接口的实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**Java Program to demonstrate use of default method in Java 8. </span><br><span class="line"> * You can define non-abstract method by using default keyword, and more </span><br><span class="line"> * than one default method is permitted, which allows you to ship default skeletal </span><br><span class="line"> * implementation on interface itself. </span><br><span class="line"> * @author Javin Paul</span><br><span class="line"> */ </span><br><span class="line"> public class Java8DefaultMethodDemo&#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String args[]) &#123; </span><br><span class="line">    // Implementing interface using Anonymous class </span><br><span class="line">    Multiplication product = new Multiplication()&#123; </span><br><span class="line">        @Override public int multiply(int x, int y)&#123; </span><br><span class="line">            return x*y; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">        int squareOfTwo = product.square(2); </span><br><span class="line">        int cubeOfTwo = product.cube(2); </span><br><span class="line">        System.out.println(&quot;Square of Two : &quot; + squareOfTwo); </span><br><span class="line">        System.out.println(&quot;Cube of Two : &quot; + cubeOfTwo); </span><br><span class="line">        // Since Multiplication has only one abstract method, it can </span><br><span class="line">        // also be implemented using lambda expression in Java 8 </span><br><span class="line">        Multiplication lambda = (x, y) -&gt; x*y; </span><br><span class="line">        int squareOfThree = lambda.square(3); </span><br><span class="line">        int cubeOfThree = lambda.cube(3); </span><br><span class="line">        System.out.println(&quot;Square of Three : &quot; + squareOfThree); </span><br><span class="line">        System.out.println(&quot;Cube of Three : &quot; + cubeOfThree);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">   interface Multiplication&#123; </span><br><span class="line">        int multiply(int a, int b);</span><br><span class="line">        default int square(int a)&#123; </span><br><span class="line">            return multiply(a, a); </span><br><span class="line">        &#125; </span><br><span class="line">        default int cube(int a)&#123; </span><br><span class="line">            return multiply(multiply(a, a), a); </span><br><span class="line">        &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       Output :  Square of Two : 4 </span><br><span class="line">                 Cube of Two : 8 </span><br><span class="line">                 Square of Three : 9 </span><br><span class="line">                 Cube of Three : 27</span><br></pre></td></tr></table></figure><p>这是个很好的关于如何使用default方法在接口中方便的添加方法的例子。也展示了如何避免一个额外的帮助类，比如Collections类。它仅仅提供了一些用于Collection的工具方法，而现在我们可以直接在Collection中定义这些方法。在上面的例子中，我们有一个包含一个抽象方法multiply(a,b)的接口Multiplication，接口还包括两个依赖于multiply(a,b)方法的非抽象方法square(a)和cube(b)。接口的实现类只需要实现multiply(a,b)方法，就可以直接使用square(a)和cube(b)方法了。</p><h2 id="default方法的关键点"><a href="#default方法的关键点" class="headerlink" title="default方法的关键点"></a>default方法的关键点</h2><ul><li>在Java8中你可以在接口中添加default方法</li><li>default方法的出现使得接口和抽象类的不同变得模糊。所以，当在面试中被问到这个问题，别忘了提一下，以前只能通过抽象类实现的事情，现在也可以通过default方法实现了。</li><li>default并不是一个新的关键字，在JDK1.1中就是保留关键字</li><li>接口中default方法的数量没有限制</li><li>如果接口C继承了接口A和B，如果A和B中拥有一样的default方法，编译器在编译过程中会报错。为了避免歧义，这在Java 8中是不允许的。所以当default方法有冲突时，是不可以多继承的</li><li>在JDK1.8中有许多关于default方法的例子，比如forEach方法。也可以查看java.util.Map中新添的putIfAbsent方法，在JDK1.8之前，我们只能ConcurrentMap来使用它。</li></ul><p>以上就是default方法。不得不说，这是一个巨大的突破，使我们可以更好更方便的使用接口。了解CurrentMap的putIfAbsent方法可以帮助我们更好的记住default方法。在JDK1.7中，putIfAbsent方法并不存在于Map接口中，所以为了使用putIfAbsent方法，必须将Map接口指向的ConcurrentMap对象强制转换成ConcurrentMap。但Java 8引入扩展方法之后，Map接口中也有了putIfAbsent方法。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/11/01/Java-8中的扩展-Default-Defender-Extension-方法/" target="_blank" rel="noopener">【译】Java8中的扩展(default/extension)方法 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8允许开发者使用&lt;code&gt;default&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;两个关键字在接口中加入非抽象的方法。带有default关键字的方法在Java中也被称作defender方法或defaul方法。在Java 8之前，想要改变一个已经发布的接口几乎是不可能的，任何改动(例如增加一个新的方法)都会影响该接口现有的实现类。这也是为什么在Java 8想要改变内部iterator的实现，使用forEach()方法时面临了一个巨大的挑战，因为这会破坏了现有的Iterable接口的实现类。毫无疑问，向后兼容是Java工程师最优先考虑的事，所以要破坏现有的实现类是不可行的。因此，他们提出了一个解决办法，引入default方法。这是一个绝妙的想法，因为现在你可以用扩展现有的接口。JDK本身也使用了许多default方法,java.util.Map接口扩展了许多default方法，例如replaceAll(),putIfAbsent(Key k,Value v)….。另外，由于default方法可以扩展现有的接口也被称作extension方法。一个接口中的default方法是数量不受限制的。我相信，在这次改变之后，将不再需要抽象类来提供骨架实现(skeletal implementation),例如List接口有AbstractList，Collection接口有AbstractCollection，Set接口有AbstractSet，Map接口有AbstractMap。我们可以通过在接口中定义default方法来替代创建一个新的抽象类。相似的，static方法的引入也使得接口的工具类变得冗余。例如，Collection接口的Collections类，Path接口的Paths类，因为你可以直接在接口中定义静态工具方法。如果你想了解更多关于Java 8的新特性，我建议阅读Cay S. Horstmann写的Java SE 8 Really Impatient。这是我最喜欢的关于Java 8的书之一，它详细的介绍了Java7与Java 8不同的特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何在java中使用ConcurrentHashMap（转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8ConcurrentHashMap/"/>
    <id>https://hsb786.github.io/2018/04/13/【译】如何在java中使用ConcurrentHashMap/</id>
    <published>2018-04-13T06:41:41.000Z</published>
    <updated>2018-04-13T07:26:36.082Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap(简称<code>CHM</code>)是在Java 1.5作为<code>Hashtable</code>的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。<br><a id="more"></a></p><h2 id="Java中ConcurrentHashMap的实现"><a href="#Java中ConcurrentHashMap的实现" class="headerlink" title="Java中ConcurrentHashMap的实现"></a>Java中ConcurrentHashMap的实现</h2><p>CHM引入了分割，并提供了HashTable支持的所有的功能。在CHM中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(<code>concurrency level</code>)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。</p><p>另一个重要点是在迭代遍历CHM时，keySet返回的iterator是<a href="https://hsb786.github.io/2018/04/09/术语/">弱一致</a>和<a href="(https://hsb786.github.io/2018/04/09/术语/">fail-safe</a>的，可能不会返回某些最近的改变，并且在遍历过程中，如果已经遍历的数组上的内容变化了，不会抛出ConcurrentModificationExceptoin的异常。</p><p>CHM默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，CHM还使用了ReentrantLock来对segments加锁。</p><h2 id="Java中ConcurrentHashMap-putifAbsent方法的例子"><a href="#Java中ConcurrentHashMap-putifAbsent方法的例子" class="headerlink" title="Java中ConcurrentHashMap putifAbsent方法的例子"></a>Java中ConcurrentHashMap putifAbsent方法的例子</h2><p>很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized(map)&#123;</span><br><span class="line">  if (map.get(key) == null)&#123;</span><br><span class="line">      return map.put(key, value);</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">      return map.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码在HashMap和HashTable中是好用的，但在CHM中是有出错的风险的。这是因为CHM在put操作时并没有对整个Map加锁，所以一个线程正在put(k,v)的时候，另一个线程调用get(k)会得到null，这就会造成一个线程put的值会被另一个线程put的值所覆盖。当然，你可以将代码封装到synchronized代码块中，这样虽然线程安全了，但会使你的代码变成了单线程。CHM提供的putIfAbsent(key,value)方法原子性的实现了同样的功能，同时避免了上面的线程竞争的风险。</p><h2 id="什么时候使用ConcurrentHashMap"><a href="#什么时候使用ConcurrentHashMap" class="headerlink" title="什么时候使用ConcurrentHashMap"></a>什么时候使用ConcurrentHashMap</h2><p>CHM适用于读者数量超过写者时，当写者数量大于等于读者时，CHM的性能是低于Hashtable和synchronized Map的。这是因为当锁住了整个Map时，读操作要等待对同一部分执行写操作的线程结束。CHM适用于做cache,在程序启动时初始化，之后可以被多个请求线程访问。正如Javadoc说明的那样，CHM是HashTable一个很好的替代，但要记住，CHM的比HashTable的同步性稍弱。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们知道了什么是ConcurrentHashMap和什么时候该用ConcurrentHashMap，下面我们来复习一下CHM的一些关键点。</p><ul><li>CHM允许并发的读和线程安全的更新操作</li><li>在执行写操作时，CHM只锁住部分的Map</li><li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li><li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li><li>CHM的所有操作都是线程安全</li><li>CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li><li>CHM不允许null的键值</li><li>可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/11/06/【译】如何在java中使用ConcurrentHashMap/" target="_blank" rel="noopener">【译】如何在java中使用ConcurrentHashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap(简称&lt;code&gt;CHM&lt;/code&gt;)是在Java 1.5作为&lt;code&gt;Hashtable&lt;/code&gt;的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>jvm-GC（转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/jvm-GC/"/>
    <id>https://hsb786.github.io/2018/04/13/jvm-GC/</id>
    <published>2018-04-13T06:10:31.000Z</published>
    <updated>2018-04-13T12:08:44.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字约定"><a href="#关键字约定" class="headerlink" title="关键字约定"></a>关键字约定</h2><ul><li>Young generation –&gt;新生代</li><li>Tenured / Old Generation –&gt;老年代</li><li>Perm Area –&gt;永久代</li></ul><h2 id="重要的东东"><a href="#重要的东东" class="headerlink" title="重要的东东"></a>重要的东东</h2><ul><li>在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。</li><li>GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。</li><li>GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。</li><li>在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。</li><li>在从内存回收一个对象之前会调用对象的finalize()方法。</li><li>作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。</li><li>System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。</li><li>如果堆没有内存创建新的对象了，会抛出<code>OutOfMemoryError</code>。<a id="more"></a><h2 id="GC针对什么对象？"><a href="#GC针对什么对象？" class="headerlink" title="GC针对什么对象？"></a>GC针对什么对象？</h2></li></ul><p>了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。</p><p><img src="/images/GC-Object.png" alt="GC回收对象"></p><h2 id="堆内存是如何划分的？"><a href="#堆内存是如何划分的？" class="headerlink" title="堆内存是如何划分的？"></a>堆内存是如何划分的？</h2><p>Java中对象都在堆上创建。为了GC，堆内存分为三个部分，也可以说三代，分别称为新生代，老年代和永久代。其中新生代又进一步分为Eden区，Survivor 1区和Survivor 2区(如下图)。新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代。</p><p><img src="/images/堆内存.png" alt="堆内存"></p><p>永久代有一些特殊，它用来存储类的元信息。对于GC是否发生在永久代有许多不同的看法，在我看来这取决于采用的JVM。大家可以通过创建大量的字符串来观察是发生了GC还是抛出了OutOfMemoryError。</p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><ol><li>标记清除算法<br> 分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="/images/sweep.jpg" alt=""></li><li>复制算法<br> 把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。<br><img src="/images/copy.jpg" alt=""></li><li>标记整理算法<br> 标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理。优点是不会造成内存碎片。<br><img src="/images/compact.jpg" alt=""></li></ol><h2 id="Java中垃圾回收器的类型"><a href="#Java中垃圾回收器的类型" class="headerlink" title="Java中垃圾回收器的类型"></a>Java中垃圾回收器的类型</h2><p>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p><ul><li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li><li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li><li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li><li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li><li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li><li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li></ul><h2 id="与GC有关的JVM参数"><a href="#与GC有关的JVM参数" class="headerlink" title="与GC有关的JVM参数"></a>与GC有关的JVM参数</h2><p>在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。<br>举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过-XX:NewRatio来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小<br><img src="/images/jvm-parameter.png" alt="jvm参数"></p><h2 id="Full-GC和并发垃圾回收"><a href="#Full-GC和并发垃圾回收" class="headerlink" title="Full GC和并发垃圾回收"></a>Full GC和并发垃圾回收</h2><p>并发垃圾回收器的内存回收过程是与用户线程一起并发执行的。通常情况下，并发垃圾回收器可以在用户线程运行的情况下完成大部分的回收工作，所以应用停顿时间很短。</p><p>但由于并发垃圾回收时用户线程还在运行，所以会有新的垃圾不断产生。作为担保，如果在老年代内存都被占用之前，如果并发垃圾回收器还没结束工作，那么应用会暂停，在所有用户线程停止的情况下完成回收。这种情况称作Full GC，这意味着需要调整有关并发回收的参数了。</p><p>由于Full GC很影响应用的性能，要尽量避免或减少。特别是如果对于高容量低延迟的电商系统，要尽量避免在交易时间段发生Full GC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。</li><li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li><li>永久代是否执行GC，取决于采用的JVM。</li><li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li><li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li><li>JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。</li><li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li></ul><p>以上就是关于Java中GC的一些内容。通过这篇博客，我们可以知道堆内存是如何划分的；一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；当垃圾收集器意识到需要进行GC时会触发Minor GC或Major GC，是自动的，无法强制执行。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/05/13/jvm-GC/" target="_blank" rel="noopener">【译】Java中的垃圾回收机制 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关键字约定&quot;&gt;&lt;a href=&quot;#关键字约定&quot; class=&quot;headerlink&quot; title=&quot;关键字约定&quot;&gt;&lt;/a&gt;关键字约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Young generation –&amp;gt;新生代&lt;/li&gt;
&lt;li&gt;Tenured / Old Generation –&amp;gt;老年代&lt;/li&gt;
&lt;li&gt;Perm Area –&amp;gt;永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;重要的东东&quot;&gt;&lt;a href=&quot;#重要的东东&quot; class=&quot;headerlink&quot; title=&quot;重要的东东&quot;&gt;&lt;/a&gt;重要的东东&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。&lt;/li&gt;
&lt;li&gt;GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。&lt;/li&gt;
&lt;li&gt;GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。&lt;/li&gt;
&lt;li&gt;在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。&lt;/li&gt;
&lt;li&gt;在从内存回收一个对象之前会调用对象的finalize()方法。&lt;/li&gt;
&lt;li&gt;作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。&lt;/li&gt;
&lt;li&gt;System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。&lt;/li&gt;
&lt;li&gt;如果堆没有内存创建新的对象了，会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;。
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>【译】Executor, ExecutorService 和 Executors 间的不同 （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/"/>
    <id>https://hsb786.github.io/2018/04/13/difference-between-executor-executorService/</id>
    <published>2018-04-13T05:21:41.000Z</published>
    <updated>2018-04-15T12:27:44.506Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.concurrent.Executor</code>, <code>java.util.concurrent.ExecutorService</code>, <code>java.util.concurrent. Executors</code> 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。<br><a id="more"></a><br>在 Java 1.5 时，开发者需要关心线程池的创建和管理，但在 Java 1.5 之后 Executor 框架提供了多种内置的线程池,例如：FixedThreadPool(包含固定数目的线程)，CachedThreadPool(可根据需要创建新的线程)等等。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor, ExecutorService, 和 Executors 最主要的区别是 Executor 是一个抽象层面的核心接口(大致代码如下)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于 java.lang.Thread 类将任务和执行耦合在一起， Executor 将任务本身和执行任务分离，可以阅读 difference between Thread and Executor 来了解 Thread 和 Executor 间更多的不同。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>ExecutorService 接口 对 Executor 接口进行了扩展，提供了返回 Future 对象，终止，关闭线程池等方法。当调用 shutDown 方法时，线程池会停止接受新的任务，但会完成正在 pending 中的任务。</p><p>Future 对象提供了异步执行，这意味着无需等待任务执行的完成，只要提交需要执行的任务，然后在需要时检查 Future 是否已经有了结果，如果任务已经执行完成，就可以通过 Future.get() 方法获得执行结果。需要注意的是，Future.get() 方法是一个阻塞式的方法，如果调用时任务还没有完成，会等待直到任务执行结束。</p><p>通过 ExecutorService.submit() 方法返回的 Future 对象，还可以取消任务的执行。Future 提供了 cancel() 方法用来取消执行 pending 中的任务。</p><p>ExecutorService 部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">void shutdown();</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 是一个工具类，类似于 Collections。提供工厂方法来创建不同类型的线程池，比如 FixedThreadPool 或 CachedThreadPool。</p><p>Executors 部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Executors &#123;</span><br><span class="line">    public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面详细看一下三者的区别：</p><h2 id="Executor-vs-ExecutorService-vs-Executors"><a href="#Executor-vs-ExecutorService-vs-Executors" class="headerlink" title="Executor vs ExecutorService vs Executors"></a>Executor vs ExecutorService vs Executors</h2><p>正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。总结一下这三者间的区别，以便大家更好的理解：</p><ul><li>Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口</li><li>Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。</li><li>Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法可以通过一个 Future 对象返回运算结果。</li><li>Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。</li><li>Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下表列出了 Executor 和 ExecutorService 的区别：</p><table><thead><tr><th>Executor</th><th>ExecutorService</th></tr></thead><tbody><tr><td>Executor 是 Java 线程池的核心接口，用来并发执行提交的任务</td><td>ExecutorService 是 Executor 接口的扩展，提供了异步执行和关闭线程池的方法</td></tr><tr><td>提供execute()方法用来提交任务</td><td>提供submit()方法用来提交任务</td></tr><tr><td>execute()方法无返回值</td><td>submit()方法返回Future对象，可用来获取任务执行结果</td></tr><tr><td>不能取消任务</td><td>可以通过Future.cancel()取消pending中的任务</td></tr><tr><td>没有提供和关闭线程池有关的方法</td><td>提供了关闭线程池的方法</td></tr></tbody></table><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2017/03/17/difference-between-executor-executorService/" target="_blank" rel="noopener">【译】Executor, ExecutorService 和 Executors 间的不同 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.concurrent.Executor&lt;/code&gt;, &lt;code&gt;java.util.concurrent.ExecutorService&lt;/code&gt;, &lt;code&gt;java.util.concurrent. Executors&lt;/code&gt; 这三者均是 Java Executor 框架的一部分，用来提供线程池的功能。因为创建和管理线程非常心累，并且操作系统通常对线程数有限制，所以建议使用线程池来并发执行任务，而不是每次请求进来时创建一个线程。使用线程池不仅可以提高应用的响应时间，还可以避免”java.lang.OutOfMemoryError: unable to create new native thread” 之类的错误。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>vscode-database</title>
    <link href="https://hsb786.github.io/2018/04/13/vscode-database/"/>
    <id>https://hsb786.github.io/2018/04/13/vscode-database/</id>
    <published>2018-04-13T03:55:59.000Z</published>
    <updated>2018-04-13T04:23:59.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近发现了一个很好用的vscode插件, vscode-database</strong></p><p>迷上了vscode</p><p><img src="/images/vscode-database.png" alt=""><br><a id="more"></a><br><img src="/images/vscode_mysql.png" alt=""></p><p><strong>快捷键</strong></p><table><thead><tr><th>命令</th><th>语义</th></tr></thead><tbody><tr><td>ctrl q</td><td>querySQL</td></tr><tr><td>ctrl shift e</td><td>Run selected text as SQL query    </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近发现了一个很好用的vscode插件, vscode-database&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迷上了vscode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vscode-database.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://hsb786.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>触发器</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://hsb786.github.io/2018/04/13/触发器/</id>
    <published>2018-04-13T03:43:11.000Z</published>
    <updated>2018-04-13T04:38:27.314Z</updated>
    
    <content type="html"><![CDATA[<p>对某一个表的某种操作，触发某种条件，从而执行的一段程序</p><p>new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。</p><p>old：旧数据，数据库里原先有的数据<br><a id="more"></a></p><p>说明：在把userjob(用户岗位关联表)中的success(审批状态)更新为true时，自动在成绩表中出入数据；否则说明没有审批没有通过，把成绩表中对应的数据删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER `insertScore` AFTER UPDATE ON `userjob` FOR EACH ROW if new.success=true then</span><br><span class="line">insert into score(id) values(new.id);</span><br><span class="line">else delete from score where id=new.id;</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p><p>说明：在删除userjob(用户岗位关联表)的数据时，自动删除成绩表对应中的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER `deleteScore` BEFORE DELETE ON `userjob` FOR EACH ROW if old.success=true then</span><br><span class="line">delete from score where id=old.id;</span><br><span class="line">end if</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对某一个表的某种操作，触发某种条件，从而执行的一段程序&lt;/p&gt;
&lt;p&gt;new: 新数据，数据库里原先没有，将要有的数据。例如将要更新的数据或者是新增的数据。&lt;/p&gt;
&lt;p&gt;old：旧数据，数据库里原先有的数据&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="https://hsb786.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://hsb786.github.io/2018/04/12/%E7%B4%A2%E5%BC%95/"/>
    <id>https://hsb786.github.io/2018/04/12/索引/</id>
    <published>2018-04-12T12:56:19.000Z</published>
    <updated>2018-04-15T12:21:35.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构</p><p>排好序的快速查找数据结构</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。<br><a id="more"></a></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引对数据进行排序，降低数据排序的成本，降低了消耗</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，索引列也是要占空间的</li><li>虽然索引列大大提高了查询速度，同时会降低更新表的速度。因为更新表时，还要保存一下索引文件每次更新添加了索引列的字段</li></ul><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul><li>主键自动建立唯一索引            （不需要自己建）</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引    （自动建立）</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组的字段</li></ul><h3 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h3><ul><li>表记录太小</li><li>经常增删改的表</li><li>某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;p&gt;索引（Index）是帮助MySQL高效获取数据的数据结构&lt;/p&gt;
&lt;p&gt;排好序的快速查找数据结构&lt;/p&gt;
&lt;p&gt;在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上快速实现高级查找算法，这种数据结构就是索引。&lt;br&gt;
    
    </summary>
    
    
      <category term="sql" scheme="https://hsb786.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="https://hsb786.github.io/2018/04/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://hsb786.github.io/2018/04/12/Java虚拟机/</id>
    <published>2018-04-12T12:01:50.000Z</published>
    <updated>2018-04-14T12:37:13.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。<br><a id="more"></a></p><h2 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h2><p>JVM并不是专为Java所实现的。实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。</p><p>JVM通过执行Java bytecode可以使java代码在不改变的情况下运行在各种硬件之上，因此实现Java平台无关性</p><p><strong>JVM = 类加载器 Class Loader + 执行引擎 Execution Engine + 运行时数据区域 Runtime Data Area</strong></p><p>首先Java源代码文件被Java编译器编译为字节码文件，然后JVM中的类加载器加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM中的运行时数据区（内存）会用来存储程序执行期间需要用到的数据和相关信息。</p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>ClassLoader把硬盘上的class文件加载到JVM中的运行时数据区域，但是它并不负责这个类文件能否执行，而这个是执行引擎负责的。</p><h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><p>执行字节码，或者执行本地方法</p><h3 id="Runtime-DataArea"><a href="#Runtime-DataArea" class="headerlink" title="Runtime DataArea"></a>Runtime DataArea</h3><p>指JVM在运行期间，其对JVM内存空间的划分和分配。</p><p><img src="/images/java虚拟机.png" alt=""></p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。</p><p>当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。</p><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ol><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。</p><p>和JVM栈一样，也会抛出StackOverflowError和OutOfMemoryError异常</p><h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p><p>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   </p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。</p><p>由于使用反射机制的原因，虚拟机很难推测哪个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，但java7已经把常量池转移到堆里面了。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/ns_code/article/details/17565503" target="_blank" rel="noopener">【深入Java虚拟机】之一：Java内存区域与内存溢出</a></p><p><a href="https://yemengying.com/2015/11/12/读书笔记-深入理解Java虚拟机1/" target="_blank" rel="noopener">读书笔记-深入理解Java虚拟机1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存区域&quot;&gt;&lt;a href=&quot;#内存区域&quot; class=&quot;headerlink&quot; title=&quot;内存区域&quot;&gt;&lt;/a&gt;内存区域&lt;/h2&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>java8新特性（转载）</title>
    <link href="https://hsb786.github.io/2018/04/12/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/12/java8新特性（转载）/</id>
    <published>2018-04-12T07:56:55.000Z</published>
    <updated>2018-04-13T04:39:49.093Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。<br><img src="/images/java8.jpg" alt=""><br><a id="more"></a></p><h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><p>Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line"></span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt.Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br></pre></td></tr></table></figure><p>那么这个新特征有啥用呢？</p><p>我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类，那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法，那么我们需要去重写每个实现了这个接口的类，而这大大增加了我们的实现需求的负担。</p><p>正是为了解决Java接口中只能定义抽象方法的问题。Java8新增加了默认方法的特性。默认方法可以被继承接口重写成抽象方法或者重新定义成默认方法。除了默认方法，接口里还可以声明静态方法，并且可以实现。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private interface DefaulableFactory &#123;</span><br><span class="line">    // Interfaces now allow static methods</span><br><span class="line">    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h2><p>因为一个类可以实现多个接口，所以当一个类实现了多个接口，而这些接口中存在两个或两个以上方法签名相同的默认方法时就会产生冲突，java8定义如下三条原则来解决冲突：</p><ol><li>类或父类中显式声明的方法，其优先级高于所有的默认方法；</li><li>如果1规则失效，则选择与当前类距离最近的具有具体实现的默认方法；</li><li>如果2规则也失效，则需要显式指定接口。</li></ol><hr><h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><p>Lambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式，它提供了轻量级的语法</p><p>重点留意这四个关键词：匿名、函数、传递、简洁</p><p>Lambda的三个部分：</p><ul><li>参数列表</li><li>箭头</li><li>Lambda 主体</li></ul><p>Lambda的基本语法大概就是下面这样子的了：</p><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; { statements; }</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line">或者是</span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">亦或是</span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><hr><h2 id="Lexiacal-Scope"><a href="#Lexiacal-Scope" class="headerlink" title="Lexiacal Scope"></a>Lexiacal Scope</h2><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>可以直接在Lambda表达式中访问外层的局部变量，但是和匿名对象不同的是，Lambda表达式的局部变量可以不用声明为final，不过局部变量必须不可被后面的代码修改（即隐性的具有final的语义）。</p><p>eg：下面代码无法编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = 1; </span><br><span class="line">Converter&lt;Integer, String&gt; s =  </span><br><span class="line">(param) -&gt; String.valueOf(param + num);  </span><br><span class="line">num = 5;</span><br></pre></td></tr></table></figure></p><p>在Lambda表达式中试图修改局部变量是不允许的！</p><ol><li>在 Lambda 表达式当中被引用的变量的值不可以被更改。</li><li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li><li>和局部变量不同的是，Lambda内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。</li></ol><h3 id="不能访问接口的默认方法"><a href="#不能访问接口的默认方法" class="headerlink" title="不能访问接口的默认方法"></a>不能访问接口的默认方法</h3><p>Lambda表达式中是无法访问到默认方法的。</p><p>补充：Lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，在这里增加一个例子以说明这个特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over values</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = new List&lt;&gt;();</span><br><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的简写？"><a href="#匿名内部类的简写？" class="headerlink" title="匿名内部类的简写？"></a>匿名内部类的简写？</h3><p>Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件</p><h3 id="Lambda表达式中的this"><a href="#Lambda表达式中的this" class="headerlink" title="Lambda表达式中的this"></a>Lambda表达式中的this</h3><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。</p><hr><h2 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h2><p>任意只包含一个抽象方法的接口，我们都可以用来做成Lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br></pre></td></tr></table></figure><p>注意，如果你不写@FunctionalInterface 标注，程序也是正确的。</p><p>下面是Java SE 7中已经存在的函数式接口：</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.util.Comparator</li><li>java.io.FileFilter</li><li>java.beans.PropertyChangeListener</li></ul><p>除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：</p><ul><li>Predicate<t>——接收T对象并返回boolean</t></li><li>Consumer<t>——接收T对象，不返回值</t></li><li>Function&lt;T, R&gt;——接收T对象，返回R对象</li><li>Supplier<t>——提供T对象（例如工厂），不接收值</t></li><li>UnaryOperator<t>——接收T对象，返回T对象</t></li><li>BinaryOperator<t>——接收两个T对象，返回T对象</t></li></ul><p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。</p><hr><h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>Lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。</p><p>方法引用和Lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p><p>方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。<br>方法引用有很多种，它们的语法如下：</p><ul><li>静态方法引用：ClassName::methodName</li><li>实际上的实例方法引用：instanceReference::methodName</li><li>超类上的实例方法引用：super::methodName</li><li>类型上的实例方法引用：ClassName::methodName</li><li>构造方法引用：Class::new</li><li>数组构造方法引用：TypeName[]::new</li></ul><p>对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。</p><p>结合Lambda可以使我们的代码更加简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">strings.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt; chars = Arrays.asList(&apos;a&apos;, &apos;b&apos;);System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;)));</span><br></pre></td></tr></table></figure><hr><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>NullPointException可以说是所有Java程序员都遇到过的一个异常，虽然Java从设计之初就力图让程序员脱离指针的苦海，但是指针确实是实际存在的，而java设计者也只能是让指针在Java语言中变得更加简单、易用，而不能完全的将其剔除，所以才有了我们日常所见到的关键字null。</p><p>空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。当异常真的发生的时候，处理策略也很简单，在存在异常的地方添加一个if语句判定即可，但是这样的应对策略会让我们的程序出现越来越多的null判定，我们知道一个良好的程序设计，应该让代码中尽量少出现null关键字，而Java8所提供的Optional类则在减少NullPointException的同时，也提升了代码的美观度。但首先我们需要明确的是，它并 不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现，从而避免NullPointException。</p><p>java.util.Optional<t> 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。</t></p><p>创建 Optional 对象,三个静态工厂方法：</p><ul><li>Optional.empty：创建空的 Optional 对象</li><li>Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE</li><li>Optianal.ofNullable：创建 Optional 对象，允许传空值</li></ul><p>Optional API：</p><ul><li>isPresent(): 变量存在返回true</li><li>get(): 返回封装的变量值，或者抛出 NoSuchElementException</li><li>orElse(T other): 提供默认值</li><li>orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版</li><li>orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型</li><li>ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法</li><li>filter(Predicate&lt;? super T&gt; predicate): 过滤</li><li>map(Function&lt;? super T, ? extends U&gt; mapper): 转换</li><li>flatMap(Function&lt;? super T, Optional&lt;U>>mapper): 转换成Optional</li></ul><p>值得注意的是：Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题</p><p>Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法，没有考虑将它作为类的字段使用…</p><p>另外，在Java9中对Optional添加了三个新的方法：</p><ol><li><p>public Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)<br>or 方法的作用是，如果一个 Optional 包含值，则返回自己；否则返回由参数 supplier 获得的 Optional</t></p></li><li><p>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)<br>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()</p></li><li>public Stream<t> stream()<br>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream；否则返回一个空的 Stream（Stream.empty()）</t></li></ol><p>举个例子，在 Java8，我们会写下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 此处 getUserById 返回的是 Optional&lt;User&gt;</span><br><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">       return userIds.stream()</span><br><span class="line">            .map(this::getUserById)     // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .filter(Optional::isPresent)// 去掉不包含值的 Optional</span><br><span class="line">            .map(Optional::get)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了 Optional.stream()，我们就可以将其简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">    return userIds.stream()</span><br><span class="line">            .map(this::getUserById)    // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><img src="/images/Java_stream_Interfaces.png" alt=""></p><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;).stream()</span><br><span class="line">                                           .filter(s -&gt; s.startsWith(&quot;c&quot;))</span><br><span class="line">                                           .map(String::toUpperCase)</span><br><span class="line">                                           .sorted()</span><br><span class="line">                                           .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream<t>代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。</t></p><p>引入的原因：</p><ul><li>声明性方式处理数据集合</li><li>透明地并行处理，提高性能</li></ul><p>流 的定义：从支持数据处理操作的源生成的元素序列</p><p>两个重要特点</p><ul><li>流水线</li><li>内部迭代</li></ul><p>流与集合：</p><ul><li>集合与流的差异就在于什么时候进行计算 <ul><li>集合是内存中的数据结构，包含数据结构中目前所有的值</li><li>流的元素则是按需计算/生成</li></ul></li><li>另一个关键区别在于遍历数据的方式 <ul><li>集合使用 Collection 接口，需要用户去做迭代，称为外部迭代</li><li>流的 Streams 库使用内部迭代</li></ul></li></ul><p>流的使用</p><ul><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul><p>流的流水线背后的理念类似于构建器模式。常见的中间操作有filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。</p><p><img src="/images/stream.png" alt=""></p><p>流的操作类型分为两种：</p><ul><li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ul><h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><ul><li>由值创建流：Stream.of、Stream.empty、IntStream.range</li><li>由集合创建流：Collection.stream、Collection.parallelStream</li><li>由数组创建流：Arrays.stream(数组变量)</li><li>由文件生成流：Files.lines、Files.walk</li><li>由BufferedReader创建流：java.io.BufferedReader.lines</li><li>由函数生成流：创建无限流， <ul><li>迭代： Stream.iterate（接受一个种子值，和一个UnaryOperator）</li><li>生成：Stream.generate（接收一个Supplier接口）</li></ul></li></ul><h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>Intermediate（中间操作）：</p><ul><li>筛选<ul><li>谓词筛选：filter</li><li>筛选互异的元素：distinct</li><li>忽略头几个元素：skip</li><li>截短至指定长度：limit</li><li>排序：sorted</li><li>偷瞄（输出）：peek</li><li>平行化：parallel</li><li>串行化：sequential</li></ul></li><li>映射 <ul><li>对流中每个元素应用函数：map</li><li>流的扁平化：flatMap</li><li>转为原始流：mapToInt、mapToInt、mapToInt</li><li>从原始流转为普通流：boxed</li></ul></li><li>数值范围<ul><li>range:[起始值，结束值)</li><li>rangeClosed:[起始值，结束值]</li></ul></li></ul><p>Terminal（终结操作）</p><ul><li>查找和匹配<ul><li>检查谓词是否至少匹配一个元素：anyMatch</li><li>检查谓词是否匹配所有元素：allMatch/noneMatch</li><li>查找元素：findAny</li><li>查找第一个元素：findFirst</li></ul></li><li>归约（折叠）：reduce(初值，结合操作)<ul><li>元素求和：count、sum</li><li>最大值和最小值：min、 max</li></ul></li><li>遍历<ul><li>forEach、 forEachOrdered</li></ul></li></ul><p>anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。<br>原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。</p><ul><li>映射到数值流：mapToInt,mapToDouble,mapToLong</li><li>转换回流对象：boxed</li><li>默认值：OptionalInt,OptionalDouble,OptionalLong</li></ul><h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><p>对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。</p><p>Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能：</p><ul><li>将流元素归约和汇总为一个值</li><li>元素分组</li><li>元素分区</li></ul><p>归约和汇总(Collectors 类中的工厂方法)：</p><ul><li>统计个数：Collectors.counting</li><li>查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy</li><li>汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数</li><li>连接字符串：joining</li><li>广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。</li></ul><p>collect vs. reduce，两者都是 Stream 接口的方法，区别在于：</p><ul><li>语意问题<ul><li>reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约；</li><li>collect 方法设计就是要改变容器，从而累积要输出的结果</li></ul></li><li>实际问题<ul><li>以错误的语义使用 reduce 会导致归约过程不能并行工作</li></ul></li></ul><p>分组和分区</p><ul><li>分组：Collectors.groupingBy<ul><li>多级分组</li><li>按子数组收集数据: maxBy<ul><li>把收集器的结果转换为另一种结果 collectingAndThen</li><li>与 groupingBy 联合使用的其他收集器例子：summingInt,mapping</li></ul></li></ul></li><li>分区：Collectors.partitioningBy是分组的特殊情况，由一个谓词作为分类函数(分区函数)，返回一个Map，只有两个Boolean类型的key。</li></ul><h3 id="Ex1-使用collect-生成Collection"><a href="#Ex1-使用collect-生成Collection" class="headerlink" title="Ex1:使用collect()生成Collection"></a>Ex1:使用collect()生成Collection</h3><p>前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将Stream转换成List或Set</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span><br><span class="line"></span><br><span class="line">上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用toCollection()指定规约容器的类型</span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)</span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)</span><br></pre></td></tr></table></figure><p>上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。</p><h3 id="Ex2-使用collect-生成Map"><a href="#Ex2-使用collect-生成Map" class="headerlink" title="Ex2:使用collect()生成Map"></a>Ex2:使用collect()生成Map</h3><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map：</p><ol><li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li><li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li><li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li></ol><p>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用toMap()统计学生GPA</span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key</span><br><span class="line">                                     student -&gt; computeGPA(student)));// 如何生成value</span><br></pre></td></tr></table></figure><p>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Partition students into passing and failing</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure><p>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Group employees by department</span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure><p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用下游收集器统计每个部门的人数</span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));// 下游收集器</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,// 下游收集器</span><br><span class="line">                                Collectors.toList())));// 更下游的收集器</span><br></pre></td></tr></table></figure><hr><h2 id="Notice-And-Optimization"><a href="#Notice-And-Optimization" class="headerlink" title="Notice And Optimization"></a>Notice And Optimization</h2><ul><li>流不可被复用</li><li>一般先filter、limit、skip操作后再进行sorted、peek、map等操作以达到short-circuiting 目的</li></ul><table><thead><tr><th>Stream操作分类</th><th></th><th>方法 </th></tr></thead><tbody><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td><td></td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td><td></td></tr></tbody></table><p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p><hr><h2 id="Java8-对字符串连接的改进"><a href="#Java8-对字符串连接的改进" class="headerlink" title="Java8 对字符串连接的改进"></a>Java8 对字符串连接的改进</h2><p>有时候，我们会有一种需求就是将若干个字符串用某个链接符衔接起来，例如有一个 List，将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式。</p><p>以前我们的一般做法就是使用StringBuilder：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringBuilder result = new StringBuilder();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.append(str).append(delimiter);</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除末尾多余的 delimiter</span><br><span class="line">    result.delete(result.length() - delimiter.length(), result.length()); </span><br><span class="line">    </span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringBuilder：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">使用 StringBuilder：</span><br><span class="line">a,b,c,d,e,f,g</span><br></pre></td></tr></table></figure><p>JDK1.8 时，添加了一个新的用于字符串连接的类，专门用于这种需要 分隔符 的场合，它就是 StringJoiner。StringJoiner 在构造时可以指定一个分隔符（delimiter），然后每连接一个元素它便会加上一个 delimiter，使用 StringJoiner 改写 formatList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用String.join:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    return String.join(delimiter, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String.join 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 List<string> 格式化为 { 元素1, 元素2, 元素3, … 元素N } 呢？（此时前缀为 “{ “，后缀为 “ }”）</string></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter, prefix, suffix);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner，带前缀和后缀：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Java8 对于字符串集合的连接操作提供了一个专门的流式 API，即 Collectors.joining 函数</p><ul><li>无参的 joining() 方法，即不存在连接符（底层实现为 StringBuilder）；</li><li>joining(CharSequence delimiter) 方法，即分隔符为 delimiter（底层实现为 StringJoiner）；</li><li>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法，即分隔符为 delimiter，前缀为 prefix，后缀为 suffix（底层实现为 StringJoiner）。</li></ul><p>那怎么使用呢？ 我们直接使用三个参数的 Collectors.joining 方法改写 formatList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Collectors.joining：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Java8-中-Map-接口的新方法"><a href="#Java8-中-Map-接口的新方法" class="headerlink" title="Java8 中 Map 接口的新方法"></a>Java8 中 Map 接口的新方法</h2><p>假如现在我们存在这样的需求：给定一个 List<string>，统计每个元素出现的所有位置。</string></p><p>比如，给定 list：[“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “f”, “f”, “g”] ，那么应该返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a : [0]</span><br><span class="line">b : [1, 2]</span><br><span class="line">c : [3, 4, 5]</span><br><span class="line">d : [6, 7, 8]</span><br><span class="line">f : [9, 10]</span><br><span class="line">g : [11]</span><br></pre></td></tr></table></figure></p><p>很明显，我们很适合使用 Map 来完成这件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        List&lt;Integer&gt; positions = positionsMap.get(str);</span><br><span class="line"></span><br><span class="line">        if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt;</span><br><span class="line">            positions = new ArrayList&lt;&gt;(1);</span><br><span class="line">            positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Java8 之前的 API：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 Java8 之前的 API：</span><br><span class="line">&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125;</span><br></pre></td></tr></table></figure><p>computeIfAbsent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 computeIfAbsent：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="当-forEach-需要索引"><a href="#当-forEach-需要索引" class="headerlink" title="当 forEach 需要索引"></a>当 forEach 需要索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是方法里面的for循环似乎让这个方法不太优雅了，Java8中Iterable提供的foreach并不带索引的：</p><p>我们可以自己写一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void forEach(</span><br><span class="line">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改造getElementPositions方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>参考</em></p><blockquote><p><a href="http://yangbingdong.com/2017/java-8-tutorial/" target="_blank" rel="noopener">Java8 Noob Tutorial</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。&lt;br&gt;&lt;img src=&quot;/images/java8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="https://hsb786.github.io/2018/04/12/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>https://hsb786.github.io/2018/04/12/合并两个排序的链表/</id>
    <published>2018-04-12T07:29:59.000Z</published>
    <updated>2018-04-12T07:53:55.820Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static ListNode merge(ListNode list1, ListNode list2) &#123;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">if (list2 == null) &#123;</span><br><span class="line">return list1;</span><br><span class="line">&#125;</span><br><span class="line">if (list1.data &lt; list2.data) &#123;</span><br><span class="line">list1.next = merge(list1.next, list2);</span><br><span class="line">return list1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">list2.next = merge(list1, list2.next);</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ListNode mergeSortedList(ListNode list1, ListNode list2) &#123;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">return list2;</span><br><span class="line">&#125;</span><br><span class="line">if (list2 == null) &#123;</span><br><span class="line">return list1;</span><br><span class="line">&#125;</span><br><span class="line">ListNode mergeHead = null;</span><br><span class="line">ListNode current = null;</span><br><span class="line">if (list1.data &lt;= list2.data) &#123;</span><br><span class="line">mergeHead = current = list1;</span><br><span class="line">list1 = list1.next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mergeHead = current = list2;</span><br><span class="line">list2 = list2.next;</span><br><span class="line">&#125;</span><br><span class="line">while (list1 != null &amp;&amp; list2 != null) &#123;</span><br><span class="line">if (list1.data &lt;= list2.data) &#123;</span><br><span class="line">current.next = list1;</span><br><span class="line">current = current.next;</span><br><span class="line">list1 = list1.next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current.next = list2;</span><br><span class="line">current = current.next;</span><br><span class="line">list2 = list2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (list1 == null) &#123;</span><br><span class="line">current.next = list2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">current.next = list1;</span><br><span class="line">&#125;</span><br><span class="line">return mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点人是按照递增排序的。&lt;br&gt;
    
    </summary>
    
    
      <category term="剑指Offer" scheme="https://hsb786.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://hsb786.github.io/2018/04/12/MyBatis/"/>
    <id>https://hsb786.github.io/2018/04/12/MyBatis/</id>
    <published>2018-04-12T05:39:35.000Z</published>
    <updated>2018-04-14T05:13:08.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p><img src="/images/mybatis-logo.png" alt=""></p><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。<br><a id="more"></a></p><h2 id="MyBatis组件"><a href="#MyBatis组件" class="headerlink" title="MyBatis组件"></a>MyBatis组件</h2><p>MyBatis的核心组件分为4个部分：</p><ul><li><p>SqlSessionFactoryBuilder(构造器)：它会根据mybatis的配置文件(Configuration配置类)来生成SqlSessionFactory，这里采用的是分步构建的Builder模式</p></li><li><p>SqlSessionFactory(工厂)：用于生成SqlSession，可以被认为是数据库连接池</p></li><li><p>SqlSession(会话)：既可以直接发送SQL执行并返回结果，也可以获取映射器Mapper接口(动态代理的类)执行SQL得到返回结果，相当于数据库连接(Connection对象)</p></li><li><p>Mapper(映射器)：由一个Java接口和XML文件构成：接口用于给出方法的入参以及返回值，XML给出SQL语句和映射规则。映射器的主要作用就是将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中</p></li></ul><p>注意，无论是映射器还是SqlSession都可以发送SQL到数据库执行，但是为了保证代码的可读性与可维护性，推荐使用Mapper接口编程来完成该操作。</p><h2 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  // do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射器实例（Mapper-Instances）"><a href="#映射器实例（Mapper-Instances）" class="headerlink" title="映射器实例（Mapper Instances）"></a>映射器实例（Mapper Instances）</h3><p>映射器是一个你创建来绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  // do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="如何使用MyBatis"><a href="#如何使用MyBatis" class="headerlink" title="如何使用MyBatis"></a>如何使用MyBatis</h2><p>首先，在MyBatis中有两种XML配置文件，一种是基础配置文件，它只有一个，用于配置一些MyBatis的上下文参数和运行环境；另一种是映射器的XML映射文件，它可以配置映射关系，SQL等等。简单来说，在使用MyBatis的时候，先给出MyBatis的配置文件用于生成SqlSession，然后再给出映射器Mapper的接口与相应的映射XML文件，最后就可以生成Mapper接口的动态代理类来发送SQL获取结果了。</p><p><img src="/images/MyBatis.png" alt=""></p><hr><h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>映射器是mybatis最核心的组件，它由一个接口加上xml文件组成。在映射器中可以配置参数，各类的SQL语句，缓存，级联等内容，并且可以通过映射规则映射到指定的POJO上。映射器的接口与映射xml文件配置使用，可以有效的消除jdbc底层代码。</p><p>映射器的映射xml文件有以下几个元素：</p><ul><li>cache – 给定命名空间的缓存配置</li><li>cache-ref – 其他命名空间缓存配置的引用</li><li>resultMap – 描述如何从数据库结果集中来加载对象，它将提供映射规则</li><li>sql – 可被其他语句引用的可重用语句块，可以定义一部分SQL，然后在其他地方引用</li><li>insert – 映射插入语句，执行后返回一个整数，代表插入的条数</li><li>update – 映射更新语句，执行后返回一个整数，代表更新的条数</li><li>delete – 映射删除语句，执行后返回一个整数，代表删除的条数</li><li>select – 映射查询语句，返回查询结果</li></ul><h2 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h2><p>映射器中的select元素代表SQL的select语句，用于查询。select元素中有以下常用的属性：</p><ul><li>id:在Mapper的命名空间中唯一的标识符。Mapper的命名空间与select元素的id将唯一定位对应的映射器接口的某个方法。</li><li>parameterType：将会传入这条语句的参数类的完全限定名或别名，可以选择Java Bean，Map等参数类型传递给SQL。这个属性是可选的，mybatis可以通过TypeHandler推断出具体传入语句的参数。</li><li>resultType：从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。</li><li>resultMap：映射集的引用，用于结果集的映射，完成结果的映射功能。注意resultType和resultMap不能同时使用。</li><li>flushCache：将其设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。</li><li>useCache：将其设置为true，将会导致本条语句的结果被二级缓存，默认值：对select元素为true。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultType=&quot;mybatis.spring.test.pojo.Person&quot;&gt;</span><br><span class="line">    SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Person getPerson(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure><p>mybatis提供的自动映射功能，只要SQL的列名与POJO的属性名保持一致，同时在mybatis的配置文件中settings元素的autoMappingBehavior是开启的(默认是开启)即可完成自动映射。如果列名与属性名不一致的话，还可以通过SQL的别名机制来处理。比如说，假如原来列名为person_name，属性名为personName，那么在SQL中就可以这么写：select person_name as personName … 这样同样可以完成自动映射。</p><p>这里特别说明关于select元素返回一个对象或者对象集合的问题：</p><ol><li>返回数据类型由DAO中的接口和映射xml文件共同决定。另外，不论是返回单一对象还是对象列表，映射xml中的配置都是一样的，都是resultType=“ . .”类型或resultMap=”resultMap-ref”*。</li><li>每一次mybatis从数据库中select数据之后，都会检查数据条数和DAO中定义的返回值是否匹配。</li><li>若返回一条数据，DAO中定义的返回值是一个对象或对象的List列表，则可以正常匹配，将查询的数据按照DAO中定义的返回值存放。</li><li>若返回多条数据，DAO中定义的返回值是一个对象，则无法将多条数据映射为一个对象，此时mybatis报错。</li></ol><h2 id="resultMap元素"><a href="#resultMap元素" class="headerlink" title="resultMap元素"></a>resultMap元素</h2><p>通过resultType加上mybatis的自动映射可以应对大多数的结果集的映射需求，但是这种方法无法定义更多的属性，比如typeHandler，级联等。为了支持更加复杂的映射，mybatis提供了resultMap属性来完成SQL到Java Bean的映射关系定义。接下来，用resulyMap改写之前使用自动映射的select元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id = &quot;Map&quot; type = &quot;mybatis.spring.test.pojo.Person&quot;&gt;</span><br><span class="line">&lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;</span><br><span class="line">&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;</span><br><span class="line">&lt;result property=&quot;tel&quot; column=&quot;tel&quot;&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">   &lt;select id=&quot;getPerson&quot; parameterType=&quot;int&quot; resultMap=&quot;Map&quot;&gt;</span><br><span class="line">       SELECT name,age,tel,id from t_person WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>子元素id代表主键，result代表属性，id和result元素的property属性代表POJO的属性名称，column代表SQL的列名，这样就将POJO的属性和SQL的列名进行一一对应了。</p><p>一个完整的resultMap元素的构成有哪些？</p><ul><li>constructor：类在实例化时,用来注入结果到构造方法中</li><li>id：表示哪个列是主键</li><li>result：注入到JavaBean属性的普通结果，配置POJO到SQL列名的映射关系</li><li>association：一个复杂的类型关联;许多结果将包成这种类型</li><li>collection：复杂类型的集</li><li>discriminator：使用结果值来决定使用哪个结果映射</li></ul><p>constructor元素用于配置构造方法，一个POJO可能不存在没有参数的构造方法，就要使用construtor元素来配置了。</p><p>id元素，result元素主要来定义POJO与SQL列名的映射规则，它们有如下属性：</p><ul><li>property:映射规则中的POJO的属性名，可以用导航式字段，例如需要访问Person类的Address属性的id，就可以写成Address . id</li><li>column：对应的SQL的列名</li><li>javaType：Java类型</li><li>jdbcType：数据库类型</li><li>typeHandler：类型处理器，允许使用自定义的类型处理器</li></ul><p>其中association，collection和discriminator这些元素是与结果映射的级联相关的。Mybatis支持级联映射，简单来说，假如我们select一个person类，person类有一个属性为address，address也是一个POJO，也就是说需要再进行一次select才能查询到address类的信息。这里需要说明的是，级联不是必须的，级联可以便捷的获取关联数据，但是如果级联太多的话会影响执行效率，也就是著名的N+1问题(如果有N个关联关系完成了级联，那么只要再加入一个关联关系，就变成了N+1个，所有的级联SQL都会被执行，显然不是所有数据是我们感兴趣的，造成了资源的浪费与性能的浪费)。为了应对级联中的N+1问题，mybatis支持延迟加载，在select的时候并不是一次性取出所有的SQL结果来映射，对于那些不常用的级联数据等到需要的时候再取出。在mybatis的全局配置文件中可以设定延迟加载属性，同时在级联元素association和collection中的fetchType属性也可以定义延迟加载。</p><h2 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert,update,delete"></a>insert,update,delete</h2><p>相比于select来说，insert,update,delete就很简单了，它们执行的结果返回的是整数，用以标识该SQL语句影响了数据库的记录行数，不需要进行结果集的映射。除此之外，insert元素是支持主键回填的，在inser语句中有一个属性useGeneratedKeys，用来控制是否使用数据库生成的主键来回填到POJO，默认值为false。当打开了主键回填之后，还要配置keyProperty或者keyColumn，告诉mybatis把生成的主键放入哪个属性中。至于在实际中用不用得到数据库生成的主键，我也不能完全肯定，这里只要知道mybatis是支持主键回填的即可，使用起来也很容易。</p><h2 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h2><p>这个元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;</span><br><span class="line">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">  select</span><br><span class="line">    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,</span><br><span class="line">    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;</span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>mybatis提供了对SQL语句动态的组装能力，大量的判断都可以在mybatis的映射xml里面配置，大大减少了代码量，提供了灵活性。<br><img src="/images/MyBatis2.png" alt=""></p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if元素使用的场景适用于在SQL语句的where子句中动态地选择某几个判断条件作为SQL语句的一部分进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogWithTitleLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>如果传入的参数title不是null，那么就将 AND title like #{title} 这子句拼接在where之后，这样就可以有条件地包含where子句的一部分。</p><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose(when,otherwise)"></a>choose(when,otherwise)</h2><p>if元素是单条件的，choose元素就是多条件的选择类似java里的switch语句，原理一样，还是接着上面的例子来举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  &lt;choose&gt;</span><br><span class="line">    &lt;when test=&quot;title != null&quot;&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;when test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      AND featured = 1</span><br><span class="line">    &lt;/otherwise&gt;</span><br><span class="line">  &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>上述参考文档中的例子otherwise元素写的是 AND featured = 1 是为了解决前面的所有case都不满足的情况，我建议写成 AND 1 = 1 更好理解。<br>该动态SQL语句的功能：如果参数提供了“title”就按“title”查找，提供了“author”就按“author”查找，若两者都没有提供，就返回所有符合默认条件的查询结果集。</p><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim(where,set)"></a>trim(where,set)</h2><p>前面的例子中的where子句总会有一个默认的查询条件也就是例子中的 state = ‘ACTIVE’ ，如果state也设置成动态的呢？可以通过where,set元素来达到这个需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  &lt;where&gt; </span><br><span class="line">    &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt; </span><br><span class="line">    &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>同样如果是update子句，那么也就相应的set元素，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p>如果where,set都无法满足动态拼接SQL的需求，我们可以使用trim来自定义如何拼接SQL子句，where和set只是mybatis定义好的拼接SQL的方法而已，但这也已经可以满足大多数需求了。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。还是参考文档里买的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>foreach元素允许指定一个集合，声明可以用在元素体内的集合项和索引变量，也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。我们可以将任何可迭代对象（如列表、集合等）和任何的字典或者数组对象传递给foreach作为集合参数。当使用可迭代对象或者数组时，index是当前迭代的次数，item的值是本次迭代获取的元素。当使用字典（或者Map.Entry对象的集合）时，index是键，item是值。</p><h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p>#{}表示一个占位符号，用来传入参数，sql在解析的时候会加上” “,当成字符串来解析，可以防止sql注入</p><p>${}表示一个拼接符号, 传入数据直接显示在生成的sql中，这样就会导致sql注入</p><hr><h2 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h2><p>MyBatis提供一级缓存和二级缓存</p><p>如果缓存中有数据就不用从数据库中获取，减少了和数据之间的交互次数，大大提高系统的性能。</p><p><img src="/images/MyBatis-Cache01.png" alt=""></p><ul><li>一级缓存是sqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构(HashMap)，用于存储缓存数据。不同的sqlSession之间的缓存区域(HashMap)是互不影响的。</li><li>二级缓存是mapper级别的缓存，多个sqlSession去操作同一个Mapper的sql语句，多个SqlSession可以公用二级缓存，二级缓存是跨sqlSession的。</li></ul><h3 id="一级缓存的工作原理"><a href="#一级缓存的工作原理" class="headerlink" title="一级缓存的工作原理"></a>一级缓存的工作原理</h3><p><img src="/images/MyBatis-Cache02.png" alt=""></p><h3 id="二级缓存的工作原理"><a href="#二级缓存的工作原理" class="headerlink" title="二级缓存的工作原理"></a>二级缓存的工作原理</h3><p><img src="/images/MyBatis-Cache03.png" alt=""></p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><p><a href="https://lujunqiu.github.io/2018/01/23/MyBatis入门/" target="_blank" rel="noopener">MyBatis入门</a></p><p><a href="https://lujunqiu.github.io/2018/01/26/MyBatis进阶/" target="_blank" rel="noopener">MyBatis进阶</a></p><p><a href="http://www.cnblogs.com/xiaoxi/p/6640590.html" target="_blank" rel="noopener">Mybatis学习总结（九）——查询缓存</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MyBatis简介&quot;&gt;&lt;a href=&quot;#MyBatis简介&quot; class=&quot;headerlink&quot; title=&quot;MyBatis简介&quot;&gt;&lt;/a&gt;MyBatis简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;p&gt;Mybatis与Hibernate都是持久层框架，这类框架的作用就是将数据库中的表和POJO映射起来，它们的本质就是Java对数据库的操作的抽象，所以我们也将这种框架称为对象关系映射框架(ORM,Object Relational Mapping)。它们的区别也很明显，Hibernate基本不需要编写SQL，它可以根据映射规则自动生成SQL语句，是一种全表映射。而MyBatis不屏蔽SQL，我们可以自己定制SQL，这样就提供给了我们足够的灵活性与优化的可能。总而言之，MyBatis相对于Hibernate来说具有性能高，响应快，开发灵活的特点。&lt;br&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="https://hsb786.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://hsb786.github.io/2018/04/12/HashMap/"/>
    <id>https://hsb786.github.io/2018/04/12/HashMap/</id>
    <published>2018-04-12T03:29:30.000Z</published>
    <updated>2018-04-13T12:43:52.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HashMap内部存储结构</strong></p><p>HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>table，一个存放节点(Node[])的数组，是Hashmap的基础设施，所有的节点都存放于此。</p><p>size，Hashmap存放的键值对的数目，并不等于table数组的长度，因为可能存在链表和红黑树结构。</p><p>modCount，Hashmap的修改次数，是实现<a href="https://hsb786.github.io/2018/04/09/术语/">fail-fast</a>机制的关键</p><p>DEFAULT_INITIAL_CAPACITY，表示默认HashMap数组初始大小为16，并且为了后续的rehash操作的方便，Hashmap的数组大小始终为2的整数次幂，即使你输入一个不是2的整数次幂的值，也会变成最小的大于该值的2的整数次幂。</p><p>MAXIMUM_CAPACITY，表示Hashmap数组的最大容量，初始值为2^30。</p><p>DEFAULT_LOAD_FACTOR，表示负载因子，当Hashmap的实际容量超过了(设定容量乘负载因子)，就触发rehash操作，默认值为0.75。</p><p>TREEIFY_THRESHOLD，jkd1.8新增的，如果Hashmap数组元素的链表长度超过这个值，就使用红黑树结构代替链表提高查询效率，默认值为8。</p><p>数组内的元素的数据结构继承了Map.Entry，用于存放键值对，另外还包含了hash值和next节点，其中hash值可用于存取节点时来寻址的作用，next节点是实现Hashmap的数组+链表(红黑树)结构的关键。</p><p>在继续看Hashmap的内部方法之前，做个大致的总结：</p><p>Hashmap是用于存放键值对的容器，内部实现是基于数组的，数组中存放的是键值对Node节点，一个Node节点保存了一个键值对信息，同时还保存了next节点，可以形成链表结构(在发生hash冲突的时候)。如果链表长度太长，超过了阀值(默认为8)，那么就自动升级为红黑树结构(高效的平衡查找树)，这样一来，数组元素的节点就成为了红黑树的根节点了。</p><p><img src="/images/HashMap3.png" alt=""></p><p>需要注意的是，在java8中如果hash值相同的key数量大于指定值（默认是8）时使用平衡树来代替链表，这会将get()方法的性能从O(n)提高到O(logn)。</p><hr><p><strong>HashMap的自动扩容机制</strong></p><p>HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶都有62500个元素，这时get()，put()，remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小*loadFactor(加载因子)后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16*0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置。</p><p><img src="/images/HashMap2.png" alt=""></p><p>没扩容前，获取EntryE需要遍历5个元素，扩容之后只需要2次。</p><hr><p><strong>put()</strong></p><ol><li>对key的hashCode()做hash，然后计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长（大于等于TREEIFY_THRESHOLD），就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)；</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果put()方法添加的键值对的键已经存在于Hashmap中，那么就用新的键值的值替代旧值。再看源码put()调用了hash()方法以及putVal()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入的key为null时，hash值为0，也就是说Hashmap的key是可以为null的。对比HashTable，HashTable的key直接进行了hashCode，如果key为null时，会抛出异常，所以HashTable的key不可以是null。<br>具体如何得到key的hash值呢？首先调用key自身的hashcode()得到一个hash值h(32位int类型)，然后将h与h右移16位之后的数进行异或，得到最终的hash值。至于为什么这么做，这是前人总结出来的算法可以使得hash值分布更加均匀,尽量减少冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释，我们可以知道入参都代表了什么：</p><ul><li>hash：表示key的hash值</li><li>key：待存储的key值</li><li>value：待存储的value值</li><li>onlyIfAbsent：是否需要替换相同的value值。如果为true，表示不替换已经存在的value</li><li>evict：如果为false，表示数组是新增模式(暂时不知道啥意思,只在方法的最后出现,但不影响其他逻辑)</li></ul><p>首先判断当前HashMap的数组是否为空，如果为空，就调用resize()方法初始化一个长度为16的数组，并且获取到数组的长度n，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>然后，根据数组的长度n-1的值与入参key的hash值按位与运算，算出hash值对应于数组中的位置，从tab中将这个位置上面的内容取出，判断为null时，在这个位置新增一个Node。但是，如果取到了数据，也就是这个hash值对应数组的位置上面已经有了键值对存在。那么，就判断这个Node,也就是p的hash值是否与传入的hash相等，然后接着判断key是否相等。如果判断通过，表示要传入的key-val键值对就是tab[i]位置上面的键值对，直接替换即可，不用管后面是链表还是红黑树。如果不是的话，就将这个新的键值对插入链表或者红黑树种即可。插入键值对分两种情况：如果数组元素是链表时，就将节点新增到列表尾部。如果链表的长度大于等于红黑树化的阀值-1，就将链表转成红黑树。如果数组元素是红黑树的话，就插入键值到对应的Node。  <em>注意，java8开始用的是尾插法</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br><span class="line">else &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    if (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    else if (p instanceof TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">            if ((e = p.next) == null) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, null);</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                break;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (e != null) &#123; // existing mapping for key</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，将修改次数加一，同时判断当前的键值对数量是否即将超过阀值，如果即将超过，需要进行resize操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++modCount;</span><br><span class="line">     if (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br></pre></td></tr></table></figure></p><p><strong>get()</strong></p><ol><li>bucket里的第一个节点，直接命中；</li><li>如果有冲突，则通过key.equals(k)去查找对应的entry;</li><li>若为树，则在数中通过key.equals(k)查找，O(logn);</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据入参的key对象计算出key的hash值，调用getNode()方法，再来看看getNode()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过key的hash值与key对象，来查找key对应的键值对的值，如果查找失败则返回null。如何查找的呢？首先，通过key的hash值计算出对应数组的索引，如果索引到的第一个Node节点的key和hash值与入参相等，直接返回该Node。否则，循环遍历下一个节点(可能是链表也有可能是红黑树)。</p><p><strong>resize()</strong></p><p>在resize的时候，数组容量还是要保持为2的整数次幂，所以扩容的时候容量会翻倍(原容量乘以2)，那么在resize的时候原来的元素在新数组中要不就维持原索引，要不就从原位置再移动2次幂，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    //记录原数组的容量</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">    //如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量。如果true，将阈值设置为Integer的最大值，同时数组容量不变</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    //定义一个新的容量的数组，同时完成对新数组的赋值</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>为什么线程不安全</strong></p><ol><li>如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(根据hash值计算的bucket一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。</li><li>如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。</li><li>扩容时需要rehash，可能会造成死循环(java8已修复)</li></ol><hr><p><strong>如何线程安全的使用HashMap</strong></p><ol><li>Hashtable<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>效率低，一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以。</p><ol start="2"><li><p>ConcurrentHashMap  （效率高）<br>JUC包中的一个类。ConcurrentHashMap 不仅线程安全而且效率高，因为它包含一个 segment 数组，将数据分段存储，给每一段数据配一把锁，也就是所谓的锁分段技术。</p></li><li><p>SynchronizedMap<br>调用synchronizedMap()方法后返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized同步关键字来保证对Map的操作是线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// synchronizedMap方法</span><br><span class="line">public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">       return new SynchronizedMap&lt;&gt;(m);</span><br><span class="line">   &#125;</span><br><span class="line">// SynchronizedMap类</span><br><span class="line">private static class SynchronizedMap&lt;K,V&gt;</span><br><span class="line">       implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">       private static final long serialVersionUID = 1978198479659022715L;</span><br><span class="line">       private final Map&lt;K,V&gt; m;     // Backing Map</span><br><span class="line">       final Object      mutex;        // Object on which to synchronize</span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">           this.m = Objects.requireNonNull(m);</span><br><span class="line">           mutex = this;</span><br><span class="line">       &#125;</span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">           this.m = m;</span><br><span class="line">           this.mutex = mutex;</span><br><span class="line">       &#125;</span><br><span class="line">       public int size() &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.size();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean isEmpty() &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.isEmpty();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean containsKey(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.containsKey(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public boolean containsValue(Object value) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.containsValue(value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V get(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.get(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V put(K key, V value) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.put(key, value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public V remove(Object key) &#123;</span><br><span class="line">           synchronized (mutex) &#123;return m.remove(key);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 省略其他方法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。</p><hr><p><strong>总结</strong></p><ol><li>HashMap在处理冲突时使用链表存储相同索引的元素。</li><li>从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。</li><li>当从链表切换到平衡树时，HashMap迭代的顺序将会改变。不过这并不会造成什么问题，因为HashMap并没有对迭代的顺序提供任何保证。</li><li>从Java 1中就存在的Hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。</li><li>除了Hashtable之外，WeakHashMap和IdentityHashMap也不会在频繁冲突的情况下使用平衡树。</li><li>使用HashMap之所以会产生冲突是因为使用了键对象的hashCode()方法，而equals()和hashCode()方法不保证不同对象的hashCode是不同的。需要记住的是，相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。</li><li>在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/02/03/译-Java中HashMap和LinkedHashMap如何解决冲突/" target="_blank" rel="noopener">Java 8中HashMap和LinkedHashMap如何解决冲突 </a></p><p><a href="https://yemengying.com/2016/05/07/threadsafe-hashmap/" target="_blank" rel="noopener">如何线程安全的使用 HashMap</a></p><p><a href="https://lujunqiu.github.io/2018/01/07/看看HashMap源码/" target="_blank" rel="noopener">看看HashMap源码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;HashMap内部存储结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap内部存储使用了一个Node数组（默认大小是16），而Node类包含一个类型为Node的next变量，也就是相当于一个链表，所有根据hash值计算的bucket一样的key会存储到同一个链表里（即产生了冲突）。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>String与StringBuffer</title>
    <link href="https://hsb786.github.io/2018/04/11/String%E4%B8%8EStringBuffer/"/>
    <id>https://hsb786.github.io/2018/04/11/String与StringBuffer/</id>
    <published>2018-04-11T06:17:41.000Z</published>
    <updated>2018-04-13T12:13:33.151Z</updated>
    
    <content type="html"><![CDATA[<p>String不可变，StringBuffer可变，why ?<br><a id="more"></a></p><hr><p>看源码</p><p><strong>String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br></pre></td></tr></table></figure></p><p>可以看出String底层是用char数组实现的，由于被final修饰所以引用不能改变。</p><p><strong>为什么要这样设计</strong></p><ol><li>只有当字符串是不可变的，字符串池才有可能实现。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</li><li>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。</li><li>因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</li><li>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</li><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li></ol><hr><p><strong>StringBuffer</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> public final class StringBuffer</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A cache of the last value returned by toString. Cleared</span><br><span class="line">     * whenever the StringBuffer is modified.</span><br><span class="line">     */</span><br><span class="line">    private transient char[] toStringCache;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        toStringCache = null;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //AbstractStringBuilder中的方法</span><br><span class="line">     public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">        if (str == null)</span><br><span class="line">            return appendNull();</span><br><span class="line">        int len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(0, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //String中的方法</span><br><span class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</span><br><span class="line">        if (srcBegin &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcEnd &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>StringBuffer中append中的实现</p><ol><li>调用super.append(str)， super类为AbstractStringBuilder</li><li>AbstractStringBuilder.append(str)中通过调用String类的getChars()方法</li><li>String.getChars()，调用System.arraycopy()完成数组的复制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  * @param      src      the source array.</span><br><span class="line">  * @param      srcPos   starting position in the source array.</span><br><span class="line">  * @param      dest     the destination array.</span><br><span class="line">  * @param      destPos  starting position in the destination data.</span><br><span class="line">  * @param      length   the number of array elements to be copied.</span><br><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                     Object dest, int destPos,</span><br><span class="line">                                     int length);</span><br></pre></td></tr></table></figure><p>本地方法的实现。</p><p>src原数组，srcPoc原数组起始位；dest目标数组，destPos目标数组起始位,length复制个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] int1= &#123;1,2,3,4&#125;;</span><br><span class="line">int[] int2= &#123;10,11,12,13,14,15,16,17&#125;;</span><br><span class="line">System.arraycopy(int1, 0, int2, 0, 3);</span><br><span class="line">System.out.println(Arrays.toString(int2));  //out  [1, 2, 3, 13, 14, 15, 16, 17]</span><br></pre></td></tr></table></figure><hr><p><em>参考</em></p><blockquote><p><a href="https://www.zhihu.com/question/20618891/answer/147575525" target="_blank" rel="noopener">如何理解 String 类型值的不可变？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String不可变，StringBuffer可变，why ?&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
</feed>
