<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-29T05:51:21.489Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>行为参数化【java8实战】</title>
    <link href="https://hsb786.github.io/2018/04/29/java8%E5%AE%9E%E6%88%98-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://hsb786.github.io/2018/04/29/java8实战-行为参数化/</id>
    <published>2018-04-29T04:20:25.000Z</published>
    <updated>2018-04-29T05:51:21.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>行为参数化是指一个方法的功能，部分或全部由传递给这个方法的某个或多个参数决定，但这些参数不是一般意义上的值（一个字符串或数字），它代表了一个具体的行为，其本质是代码传递，表现可能有多种：对象、匿名类、java8里的Lambda表达式（或方法引用）等。</p></blockquote><a id="more"></a><h2 id="为什么需要行为参数化？"><a href="#为什么需要行为参数化？" class="headerlink" title="为什么需要行为参数化？"></a>为什么需要行为参数化？</h2><p>以前做外包项目的时候，似乎永远不知道客户会在什么时候提出新需求或需求变更，如果没有行为参数化或类似行为参数化的东西，客户的需求小有改动可能会带来代码上较大的变动，或为了一个小的新需求复制粘贴好几个类或方法，但行为参数化对于某些需求的变化或新增可以做到以不变应万变。</p><hr><p>question: <strong>农民需要筛选苹果，可能通过颜色，可能通过重量，也可能通过其它属性。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, String color,int weight, boolean flag) &#123;</span><br><span class="line">    List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;();</span><br><span class="line">    for (Apple apple: inventory)&#123;</span><br><span class="line">        //flag标志用于区分是颜色筛选还是重量筛选</span><br><span class="line">        if ( (flag &amp;&amp; apple.getColor().equals(color)) ||(!flag &amp;&amp; apple.getWeight() &gt; weight) )&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法看起来很糟糕，不易理解，而且无法满足农民可能提出的更多过滤需要，比如大小、形状、产地，更不用说可能出现的组合筛选需求了。因此需要作出改变，既不想每一个过滤需求都写一个对应的过滤方法，又不想写一个巨大而糟糕的方法来实现多个筛选需求，怎么办？</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>上一个例子在过滤时传递的是具体的值（值传递），如string类型的颜色、int类型的重量、boolean，代表的只是苹果的一个属性或状态，更糟糕的它们可能会有无数个组合，每个组合都对应了一个新需求，我们是无法单纯地靠值传递来设计出优雅的过滤方法的!</p><p>由于每一次筛选都是一个具体的行为，行为决定了过滤的结果,那直接将行为传递至过滤方法呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*对筛选标准建立模型</span><br><span class="line">*/</span><br><span class="line">public interface ApplePredicate&#123;</span><br><span class="line">    //test方法决定了apple是否满足我们的筛选条件</span><br><span class="line">    boolean test (Apple apple);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*代表了选出较重苹果的这一行为</span><br><span class="line">*/</span><br><span class="line">public class AppleHeavyWeightPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return apple.getWeight() &gt; 150;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*代表了选出绿色苹果这一行为</span><br><span class="line">*/</span><br><span class="line">public class AppleGreenColorPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;green&quot;.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了“策略模式”，定义一族算法，把它们封装起来，然后再运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为作为参数，并在内部使用，来完成不同的行为</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory,ApplePredicate p)&#123;</span><br><span class="line">    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for(Apple apple: inventory)&#123;</span><br><span class="line">        //ApplePredicate对象封装了测试苹果的条件</span><br><span class="line">        //满足条件即是我们需要选出的结果</span><br><span class="line">        if(p.test(apple))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样针对不同的过滤需求（行为），我们只需要定义不同的ApplePredicate的实现类，即可使用同一个过滤方法筛选出我们想要的苹果，比如筛选出红色且较重的苹果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleRedAndHeavyPredicate implements ApplePredicate&#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;red&quot;.equals(apple.getColor())&amp;&amp; apple.getWeight() &gt; 150;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Apple&gt; redAndHeavyApples =filterApples(inventory, new AppleRedAndHeavyPredicate());</span><br></pre></td></tr></table></figure></p><p>无论筛选需求的组合多么复杂，都只有一个行为参数，至此，filterApples方法已经能够应对不断变化的筛选需求了。但每一个筛选行为都需要定义一个类，是不是太啰嗦了？</p><p><strong>由于该filterApples方法只能接受对象，所以你必须把代码包裹在ApplePredicate对象里。就类似于在内联“传递代码”，因为你是通过一个实现了test方法的对象来传递布尔表达式的。</strong></p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123;</span><br><span class="line">    public boolean test(Apple apple)&#123;</span><br><span class="line">        return &quot;red&quot;.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>匿名类虽然省去了大量行为类的声明，但是依然笨重（模板化的代码占了4行，实际的筛选代码却只有一行）且匿名类的使用可能会让人费解。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><pre><code>List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; &quot;red&quot;.equals(apple.getColor()));</code></pre><p><img src="/images/xwcsh01.png" alt=""></p><h2 id="将-List-类型抽象化，行为参数化趋于完美"><a href="#将-List-类型抽象化，行为参数化趋于完美" class="headerlink" title="将 List 类型抽象化，行为参数化趋于完美"></a>将 List 类型抽象化，行为参数化趋于完美</h2><p>前方的过滤方法只能过滤Apple，我们可以使用泛型进一步抽象化，使其可以过滤Orange、Banana等任何实体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;&#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for(T e: list)&#123;</span><br><span class="line">        if(p.test(e))&#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//筛选出红苹果</span><br><span class="line">List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; &quot;red&quot;.equals(apple.getColor()));</span><br><span class="line">//筛选出偶数</span><br><span class="line">List&lt;Integer&gt; evenNumbers = filter(numbers, (Integer i) -&gt; i % 2 == 0);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li><li>行为参数化可以让代码更好地适应不断变化的要求，减轻未来的工作量</li><li>传递代码，就是将新行为作为参数传递给方法。但在Java8之前实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java8之前可以用匿名类来减少。</li><li>Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;行为参数化是指一个方法的功能，部分或全部由传递给这个方法的某个或多个参数决定，但这些参数不是一般意义上的值（一个字符串或数字），它代表了一个具体的行为，其本质是代码传递，表现可能有多种：对象、匿名类、java8里的Lambda表达式（或方法引用）等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="Java8实战" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/Java8%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>二进制问题</title>
    <link href="https://hsb786.github.io/2018/04/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://hsb786.github.io/2018/04/28/二进制问题/</id>
    <published>2018-04-28T06:12:09.000Z</published>
    <updated>2018-04-28T07:11:10.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>0.1+0.2=0.30000000000000004，今天偶尔看到这个问题，刚好前不久笔试的时候也遇到过，只知道是精度问题，但忘了是为什么，回顾一下。🍳</p></blockquote><a id="more"></a><p>有个网站域名就是0.30000000000000004<br><a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">0.30000000000000004.com</a></p><p>网站上举的栗子🎂</p><table><thead><tr><th>运算</th><th>结果</th></tr></thead><tbody><tr><td>.1 + .2</td><td>0.30000000000000004</td></tr><tr><td>.1F + .2F</td><td>0.3</td></tr></tbody></table><blockquote><p>Java has built-in support for arbitrary precision numbers using the BigDecimal class.<br>可以使用BigDecimal解决这个问题</p></blockquote><h2 id="导致这个问题的原因"><a href="#导致这个问题的原因" class="headerlink" title="导致这个问题的原因"></a>导致这个问题的原因</h2><ul><li>计算机将所有数据以二进制的形式存储  </li><li>计算机用有限的大小来存储数据</li></ul><h3 id="二进制十进制小数转换"><a href="#二进制十进制小数转换" class="headerlink" title="二进制十进制小数转换"></a>二进制十进制小数转换</h3><p>例如十进制0.125转换成二进制</p><table><thead><tr><th>二进制</th><th>十进制</th></tr></thead><tbody><tr><td>0.125*2=0.25</td><td>取整数部分0</td></tr><tr><td>0.25*2=0.5</td><td>取整数部分0</td></tr><tr><td>0.5*2=1</td><td>取整数部分1</td></tr></tbody></table><p>最终得到的结果就是0.001</p><p>例如二进制0.001转换成十进制</p><table><thead><tr><th>十进制</th><th>二进制</th></tr></thead><tbody><tr><td>0* 2^-1</td><td>0</td></tr><tr><td>0* 2^-2</td><td>0</td></tr><tr><td>1* 2^-3</td><td>0.125</td></tr></tbody></table><p>最终得到的结果就是0+0+0.125=0.125</p><hr><p>知道了这些就不难理解为什么0.1+0.2！=0.3</p><p>首先看0.1二进制表示：0.0 00110011001100110011001100110011    </p><p>无穷循环，而计算机只能用有限位来存储数据，所以必然会有精度丢失的问题。</p><p>java采用BigDecimal来解决这个问题</p><hr><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.1+.2=0.30000000000000004</span><br><span class="line">new BigDecimal(.1).add(new BigDecimal(.2))=0.3000000000000000166533453693773481063544750213623046875</span><br><span class="line">new BigDecimal(String.valueOf(.1)).add(new BigDecimal(String.valueOf(.2)))=0.3</span><br></pre></td></tr></table></figure></p><p>由于0.1无法用二进制表示，所以调用new BIgDecimal(Double val)依然是有问题的，最好转化为String类型。</p><h2 id="需要注意的东西"><a href="#需要注意的东西" class="headerlink" title="需要注意的东西"></a>需要注意的东西</h2><p>BigDecimal是不可变的，在进行每一步运算时，都会产生一个新的对象，由于所以不适合大量的数学运算，适用于商业计算中对进度要求比较高的。</p><p><em>感觉不懂的还有很多</em></p><hr><p><em>参考</em></p><blockquote><p><a href="http://0.30000000000000004.com/" target="_blank" rel="noopener">0.30000000000000004.com</a></p><p><a href="https://www.zhihu.com/question/56545018" target="_blank" rel="noopener">为什么java里面3*0.1=0.30000000000000004，而4*0.1=0.4？</a></p><p><a href=""></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;0.1+0.2=0.30000000000000004，今天偶尔看到这个问题，刚好前不久笔试的时候也遇到过，只知道是精度问题，但忘了是为什么，回顾一下。🍳&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>山鬼</title>
    <link href="https://hsb786.github.io/2018/04/24/%E5%B1%B1%E9%AC%BC/"/>
    <id>https://hsb786.github.io/2018/04/24/山鬼/</id>
    <published>2018-04-24T05:10:17.000Z</published>
    <updated>2018-04-24T05:25:15.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。<br><a id="more"></a></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=445198021&auto=0&height=66"></iframe><p><strong>九歌·山鬼</strong></p><p> 若有人兮山之阿，被薜荔兮带女罗。</p><p> 既含睇兮又宜笑，子慕予兮善窈窕。</p><p> 乘赤豹兮从文里，辛夷车兮结旗。</p><p> 被石兰兮带杜衡。折芳馨兮遗所思。</p><p> 余处幽篁兮终不见天，路险难兮独后来。</p><p> 表独立兮山之类上，云容容兮而在下。</p><p> 杳冥冥兮羌昼晦，东风飘兮神灵雨。</p><p> 留灵修兮忘归，岁既晏兮孰华予。</p><p> 采三秀兮於山间，石磊磊兮葛蔓蔓。</p><p> 怨公子兮怅忘归，君思我兮不得闲。</p><p> 山中人兮芳杜若，饮石泉兮荫松柏。</p><p> 君我兮然疑作。</p><p> 雷填填兮雨冥冥，猿啾啾兮又夜鸣。</p><p> 风飒飒兮木萧萧，思公子兮徙离忧。 </p><hr><p> <a href="https://music.douban.com/review/8790064/" target="_blank" rel="noopener"> 山鬼自啼风雨·《山鬼》乐评. </a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://hsb786.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://hsb786.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>RandomAccess</title>
    <link href="https://hsb786.github.io/2018/04/23/RandomAccess/"/>
    <id>https://hsb786.github.io/2018/04/23/RandomAccess/</id>
    <published>2018-04-23T10:30:51.000Z</published>
    <updated>2018-04-23T10:58:03.042Z</updated>
    
    <content type="html"><![CDATA[<p>JDK官方文档上的解释：</p><blockquote><p>Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.<br>大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。<br><a id="more"></a></p></blockquote><p>只定义了一个接口，里面什么都没有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释上举了个栗子🎂，例如下面代码中第一种循环运行比第二种快<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span><br><span class="line"> *         list.get(i);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * runs faster than this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line"> *         i.next();</span><br><span class="line"> * &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><p>so，在遍历ArrayList时，优先使用第一种循环；在遍历LinkedList则使用第二种循环。<br>根据有没有实现RandomAccess接口来判断。<br>ArrayList实现了RandomAccess接口，LinkedList没有实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Collections.class</span><br><span class="line">public static &lt;T&gt;</span><br><span class="line">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        return Collections.indexedBinarySearch(list, key);</span><br><span class="line">    else</span><br><span class="line">        return Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>foreach内部是通过Iterator实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">for(String s:list) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的字节码文件。<br>从第27，37，54行可以看出，foreach其实是通过Iterator来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class al.T01 &#123;</span><br><span class="line">  public al.T01();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #19                 // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #21                 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #22                 // String a</span><br><span class="line">      11: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: aload_1</span><br><span class="line">      18: ldc           #30                 // String b</span><br><span class="line">      20: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      25: pop</span><br><span class="line">      26: aload_1</span><br><span class="line">      27: invokeinterface #32,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</span><br><span class="line">      32: astore_3</span><br><span class="line">      33: goto          53</span><br><span class="line">      36: aload_3</span><br><span class="line">      37: invokeinterface #36,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">      42: checkcast     #42                 // class java/lang/String</span><br><span class="line">      45: astore_2</span><br><span class="line">      46: getstatic     #44                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      49: aload_2</span><br><span class="line">      50: invokevirtual #50                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      53: aload_3</span><br><span class="line">      54: invokeinterface #56,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z</span><br><span class="line">      59: ifne          36</span><br><span class="line">      62: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK官方文档上的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.&lt;br&gt;大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot</title>
    <link href="https://hsb786.github.io/2018/04/23/HotSpot/"/>
    <id>https://hsb786.github.io/2018/04/23/HotSpot/</id>
    <published>2018-04-23T10:15:36.000Z</published>
    <updated>2018-04-23T12:52:33.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&lt;&lt;深入理解Java虚拟机：JVM高级特性与最佳实践&gt;&gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄</p></blockquote><a id="more"></a><p>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。</p><p>HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利），<strong>HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知<a href="https://hsb786.github.io/2018/04/09/术语/">JIT编译器</a>以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</strong></p><p>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</p><p>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&amp;lt;&amp;lt;深入理解Java虚拟机：JVM高级特性与最佳实践&amp;gt;&amp;gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap</title>
    <link href="https://hsb786.github.io/2018/04/22/LinkedHashMap/"/>
    <id>https://hsb786.github.io/2018/04/22/LinkedHashMap/</id>
    <published>2018-04-22T11:37:01.000Z</published>
    <updated>2018-04-23T11:06:33.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LinkedHashMap 保证插入数据的有序性</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line">    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The head (eldest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The tail (youngest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">     * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    final boolean accessOrder;</span><br><span class="line"></span><br><span class="line">    public LinkedHashMap() &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap内部没有重写put方法，很好奇，是怎么把链表加上去的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</span><br><span class="line">    ....................</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一篇博客上看到加链表是通过<code>afterNodeInsertion(evict)</code>。可以看出每次put的时候都调用了<code>afterNodeInsertion(evict)</code>; 而这个afterNodeInsertion在LinkedHashMap中是重写了的。然后就傻呼呼的相信了，but 在<code>afterNodeInsertion(evict)</code>中并没有添加链表啊，傻傻的盯着这段代码看了很久。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，开始自己找。发现了<code>linkNodeLast()</code>方法，这不就是实现链表的关键吗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// link at the end of list</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着发现<code>linkNodeLast()</code>在<code>newNode()</code>中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并且newNode()在HashMap中也存在，注释还写得清清楚楚，就是用来被LinkedHashMap重写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">/* ------------------------------------------------------------ */</span><br><span class="line">// LinkedHashMap support</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* The following package-protected methods are designed to be</span><br><span class="line">* overridden by LinkedHashMap, but not by any other subclass.</span><br><span class="line">* Nearly all other internal methods are also package-protected</span><br><span class="line">* but are declared final, so can be used by LinkedHashMap, view</span><br><span class="line">* classes, and HashSet.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// Create a regular (non-tree) node</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>putVal()</code>中调用了<code>newNode()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就解释通了，LinkedHashMap没有重写put方法。为了保证有序，那么他是怎么实现链表的呢？</p><p>利用多态，通过重写<code>newNode()</code>方法，在<code>newNode()</code>方法中实现了链表的连接。而<code>newNode</code>方法在<code>putVal()</code>中调用了。so，每次添加元素的时候，同时会维护一个双向链表。通过链表实现了有序。</p><p>看来，平时不能太依赖于网上别人分析的东西，不一定是对的。</p><hr><p><strong>accessOrder</strong></p><p>LinkedHashMap中定义了accessOrder属性。官方是这样解释的：accessOrder为true时，迭代顺序就是访问顺序；为false时，迭代顺序就是插入顺序。<br>插入顺序倒好理解，访问顺序是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">*</span><br><span class="line">* @serial</span><br><span class="line">*/</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap重写了<code>get(Object key)</code>方法。accessOrder为true时，调用了<code>afterNodeAccess(e);</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 方法注解写的很明白，move node to last，把node移动到最后。意思就是如果accessOrder设为true时，每次通过get()获取，都会把获取的元素移到链表的最后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>final boolean accessOrder;</code> accessOrder包访问权限，也没有set方法，只能通过<code>public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)</code> 构造函数来将accessOrder设为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LinkedHashMap 保证插入数据的有序性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashSet</title>
    <link href="https://hsb786.github.io/2018/04/22/HashSet/"/>
    <id>https://hsb786.github.io/2018/04/22/HashSet/</id>
    <published>2018-04-22T10:44:43.000Z</published>
    <updated>2018-04-22T11:37:57.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HashSet 底层由HashMap实现<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    //HashSet底层使用HashMap实现</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    //HashSet add(E e)方法中，key为e，value为PRESENT</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new, empty linked hash set.  (This package private</span><br><span class="line">     * constructor is only used by LinkedHashSet.) The backing</span><br><span class="line">     * HashMap instance is a LinkedHashMap with the specified initial</span><br><span class="line">     * capacity and the specified load factor.</span><br><span class="line">     *</span><br><span class="line">     * @param      initialCapacity   the initial capacity of the hash map</span><br><span class="line">     * @param      loadFactor        the load factor of the hash map</span><br><span class="line">     * @param      dummy             ignored (distinguishes this</span><br><span class="line">     *             constructor from other int, float constructor.)</span><br><span class="line">     * @throws     IllegalArgumentException if the initial capacity is less</span><br><span class="line">     *             than zero, or if the load factor is nonpositive</span><br><span class="line">     */</span><br><span class="line">     //这个就有点意思了，dummy参数其实没用，只是为了重载，与其它方法区分开了而已，这样也行！</span><br><span class="line">     //注意的是返回的是LinkedHashMap，数据是有顺序的。</span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><code>add(E e)</code>,<code>remove(Object o)</code>只是直接调用HashMap的put和remove方法。<br>key: e ; value : PRESENT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HashSet 底层由HashMap实现&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Java内存访问重排序的研究（转载）</title>
    <link href="https://hsb786.github.io/2018/04/21/Java%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>https://hsb786.github.io/2018/04/21/Java内存访问重排序的研究/</id>
    <published>2018-04-21T13:40:14.000Z</published>
    <updated>2018-04-24T05:49:34.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">原文链接</a><br><a id="more"></a></p></blockquote><h2 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PossibleReordering &#123;</span><br><span class="line">static int x = 0, y = 0;</span><br><span class="line">static int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread one = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a = 1;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread other = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            b = 1;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p><p>然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程，如下图所示。值得注意的是，a=1和x=b这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”(reordering)。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p><p><img src="/images/reordered01.png" alt=""></p><p>对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。</p><p><img src="/images/reordered02.png" alt=""></p><p>实验代码是构造一个循环，反复执行上面的实例代码，直到出现a=0且b=0的输出为止。实验结果说明，循环执行到第13830次时输出了(0,0).</p><p>大多数现代微处理器都会采用将<strong>指令乱序执行（out-of-order execution，简称OoOE或OOE）</strong>的方法，<strong>在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。</strong>通过乱序执行的技术，处理器可以大大提高执行效率。<br>除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p><strong>As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的</strong>。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。<br>比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成Java字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</p><ul><li>对a赋值1</li><li>对b赋值2</li><li>取a的值</li><li>取b的值</li><li>将取到两个值相加后存入c</li></ul><p>在上面5个动作中，动作1可能会和动作2、4重排序，动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，一旦重排，as-if-serial语义便无法保证。</p><p>为保证as-if-serial语义，<strong>Java异常处理机制也会为重排序做一些特殊处理</strong>。例如在下面的代码中，y = 0 / 0可能会被重排序在x = 2之前执行，为了保证最终不致于输出x = 1的错误结果，<strong>JIT在重排序时会在catch语句中插入错误代偿代码，将x赋值为2，将程序恢复到发生异常时应有的状态</strong>。这种做法的确将异常捕捉的逻辑变得复杂了，但是JIT的优化的原则是，<strong>尽力优化正常运行下的代码逻辑，哪怕以catch块逻辑变得复杂为代价</strong>，毕竟，进入catch块内是一种“异常”情况的表现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Reordering &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        x = 1;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 2;</span><br><span class="line">            y = 0 / 0;    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存访问重排序与内存可见性"><a href="#内存访问重排序与内存可见性" class="headerlink" title="内存访问重排序与内存可见性"></a>内存访问重排序与内存可见性</h2><p>计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。其模型如下图所示。</p><p><img src="/images/reordered03.png" alt=""></p><p>在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。<br>有的观点会将这种现象也视为重排序的一种，命名为“内存系统重排序”。因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。<br>这种内存可见性问题也会导致章节一中示例代码即便在没有发生指令重排序的情况下的执行结果也还是(0, 0)。</p><h2 id="内存访问重排序与Java内存模型"><a href="#内存访问重排序与Java内存模型" class="headerlink" title="内存访问重排序与Java内存模型"></a>内存访问重排序与Java内存模型</h2><p>Java的目标是成为一门平台无关性的语言，即Write once, run anywhere. 但是<strong>不同硬件环境下指令重排序的规则不尽相同</strong>。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-1337制定了<strong>Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性</strong>。从Java 5开始，Java内存模型成为Java语言规范的一部分。<br>根据Java内存模型中的规定，可以总结出以下几条happens-before规则。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p><ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><p>Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4。</p><p>除此之外，Java内存模型对volatile和final的语义做了扩展。对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（的前提是没有this引用溢出）。</p><p>Java内存模型关于重排序的规定，总结后如下表所示。</p><p><img src="/images/reordered04.png" alt=""></p><p>表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有volatile写重排序。另外，JMM也规定了上述volatile和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括JIT，下同）证明了一个volatile变量只能被单线程访问，那么就可能会把它做为普通变量来处理。<br>留白的单元格代表允许在不违反Java基本语义的情况下重排序。例如，编译器不会对对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。</p><p>除此之外，为了保证final的新增语义。JSR-133对于final变量的重排序也做了限制。</p><ul><li>构建方法内部的final成员变量的存储，并且，假如final成员变量本身是一个引用的话，这个final成员变量可以引用到的一切存储操作，都不能与构建方法外的将当期构建对象赋值于多线程共享变量的存储操作重排序。例如对于如下语句<br>x.finalField = v; … ;  构建方法边界sharedRef = x;<br>v.afield = 1; x.finalField = v; … ; 构建方法边界sharedRef = x;<br>这两条语句中，构建方法边界前后的指令都不能重排序。</li><li>初始读取共享对象与初始读取该共享对象的final成员变量之间不能重排序。例如对于如下语句<br>x = sharedRef; … ; i = x.finalField;<br>前后两句语句之间不会发生重排序。由于这两句语句有数据依赖关系，编译器本身就不会对它们重排序，但确实有一些处理器会对这种情况重排序，因此特别制定了这一规则。</li></ul><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型  </p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul><p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p><p><img src="/images/reordered05.png" alt=""></p><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p><h2 id="Intel-64-IA-32架构下的内存访问重排序"><a href="#Intel-64-IA-32架构下的内存访问重排序" class="headerlink" title="Intel 64/IA-32架构下的内存访问重排序"></a>Intel 64/IA-32架构下的内存访问重排序</h2><p>Intel 64和IA-32是我们较常用的硬件环境，相对于其它处理器而言，它们拥有一种较严格的重排序规则。Pentium 4以后的Intel 64或IA-32处理的重排序规则如下。</p><p>在单CPU系统中</p><ul><li>读操作不与其它读操作重排序。</li><li>写操作不与其之前的写操作重排序。</li><li>写内存操作不与其它写操作重排序，但有以下几种例外</li><li>CLFLUSH的写操作</li><li>带有non-temporal move指令(MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD)的streaming写入。</li><li>字符串操作</li><li>读操作可能会与其之前的写不同位置的写操作重排序，但不与其之前的写相同位置的写操作重排序。</li><li>读和写操作不与I/O指令，带锁的指令或序列化指令重排序。</li><li>读操作不能重排序到LFENCE和MFENCE之前。</li><li>写操作不能重排序到LFENCE、SFENCE和MFENCE之前。</li><li>LFENCE不能重排序到读操作之前。</li><li>SFENCE不能重排序到写之前。</li><li>MFENCE不能重排序到读或写操作之前。</li></ul><p>在多处理器系统中</p><ul><li>各自处理器内部遵循单处理器的重排序规则。</li><li>单处理器的写操作对所有处理器可见是同时的。</li><li>各自处理器的写操作不会重排序。</li><li>内存重排序遵守因果性(causality)（内存重排序遵守传递可见性）。</li><li>任何写操作对于执行这些写操作的处理器之外的处理器来看都是一致的。</li><li>s带锁指令是顺序执行的。</li></ul><p>值得注意的是，对于Java编译器而言，Intel 64/IA-32架构下处理器不需要LoadLoad、LoadStore、StoreStore屏障，因为不会发生需要这三种屏障的重排序。</p><h2 id="一例Intel-64-IA-32架构下的代码性能优化"><a href="#一例Intel-64-IA-32架构下的代码性能优化" class="headerlink" title="一例Intel 64/IA-32架构下的代码性能优化"></a>一例Intel 64/IA-32架构下的代码性能优化</h2><p>现在有这样一个场景，一个容器可以放一个东西，容器支持create方法来创建一个新的东西并放到容器里，支持get方法取到这个容器里的东西。我们可以较容易地写出下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程场景下，这段代码执行起来是没有问题的。但是在多线程并发场景下，由不同的线程create和get东西，这段代码是有问题的。问题的原因与普通的双重检查锁定单例模式(Double Checked Locking, DCL)10类似，即SomeThing的构建与将指向构建中的SomeThing引用赋值到object变量这两者可能会发生重排序。导致get中返回一个正被构建中的不完整的SomeThing对象实例。为了解决这一问题，通常的办法是使用volatile修饰object字段。这种方法避免了重排序，保证了内存可见性，摒弃比使用同步块导致的性能损失更小。但是，假如使用场景对object的内存可见性并不敏感的话（不要求一个线程写入了object，object的新值立即对下一个读取的线程可见），在Intel 64/IA-32环境下，有更好的解决方案。</p><p>根据上一章的内容，我们知道Intel 64/IA-32下写操作之间不会发生重排序，即在处理器中，构建SomeThing对象与赋值到object这两个操作之间的顺序性是可以保证的。这样看起来，仅仅使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。但令人高兴的是，Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。</p><p>我们将做一个小实验来比较二者的性能差异。一种是使用volatile修饰object成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile  SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是利用Unsafe. putOrderedObject在避免在适当的位置发生重排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    private Object value;</span><br><span class="line">    private static final Unsafe unsafe = getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(Container.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        SomeThing temp = new SomeThing();</span><br><span class="line">        unsafe.putOrderedObject(this, valueOffset, null);    //将value赋null值只是一项无用操作，实际利用的是这条语句的内存屏障</span><br><span class="line">        object = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            return (Unsafe)f.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接调用Unsafe.getUnsafe()需要配置JRE获取较高权限，我们利用反射获取Unsafe中的theUnsafe来取得Unsafe的可用实例。<br>unsafe.putOrderedObject(this, valueOffset, null)<br>这句仅仅是为了借用这句话功能的防止写重排序，除此之外无其它作用。</p><p>利用下面的代码分别测试两种方案的实际运行时间。在运行时开启-server和 -XX:CompileThreshold=1以模拟生产环境下长时间运行后的JIT优化效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    final int THREADS_COUNT = 20;</span><br><span class="line">    final int LOOP_COUNT = 100000;</span><br><span class="line"></span><br><span class="line">    long sum = 0;</span><br><span class="line">    long min = Integer.MAX_VALUE;</span><br><span class="line">    long max = 0;</span><br><span class="line">    for(int n = 0;n &lt;= 100;n++) &#123;</span><br><span class="line">        final Container basket = new Container();</span><br><span class="line">        List&lt;Thread&gt; putThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        List&lt;Thread&gt; takeThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            putThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.create();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            takeThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.get().getStatus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).start();</span><br><span class="line">            putThreads.get(i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).join();</span><br><span class="line">            putThreads.get(i).join();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line">        long period = end - start;</span><br><span class="line">        if(n == 0) &#123;</span><br><span class="line">            continue;    //由于JIT的编译，第一次执行需要更多时间，将此时间不计入统计</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (period);</span><br><span class="line">        System.out.println(period);</span><br><span class="line">        if(period &lt; min) &#123;</span><br><span class="line">            min = period;</span><br><span class="line">        &#125;</span><br><span class="line">        if(period &gt; max) &#123;</span><br><span class="line">            max = period;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Average : &quot; + sum / 100);</span><br><span class="line">    System.out.println(&quot;Max : &quot; + max);</span><br><span class="line">    System.out.println(&quot;Min : &quot; + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的计算机上运行测试，采用volatile方案的运行结果如下<br>Average : 62535770<br>Max : 82515000<br>Min : 45161000</p><p>采用unsafe.putOrderedObject方案的运行结果如下<br>Average : 50746230<br>Max : 68999000<br>Min : 38038000</p><p>从结果看出，unsafe.putOrderedObject方案比volatile方案平均耗时减少18.9%，最大耗时减少16.4%，最小耗时减少15.8%.另外，即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。&lt;a href=&quot;https://tech.meituan.com/java-memory-reordering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashMap中的扩容</title>
    <link href="https://hsb786.github.io/2018/04/21/HashMap%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9/"/>
    <id>https://hsb786.github.io/2018/04/21/HashMap中的扩容/</id>
    <published>2018-04-21T12:10:50.000Z</published>
    <updated>2018-04-25T07:17:39.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞<br><a id="more"></a><br>术语：</p><ul><li>高位运算：不太了解，网上也找不到解释。让高位参加运算?</li><li>取模运算：例如对于整数a，b来说，取模或者求余主要分为以下两步<ul><li><ol><li>求整数商: c=a/b     </li></ol></li><li><ol start="2"><li>计算模或者余数：r=a-c*b   </li></ol></li><li>取模运算是r向负无穷方向舍弃小数位</li><li>求余运算时r向正无穷方向舍弃小数位</li></ul></li></ul></blockquote><p><em>针对java8</em></p><h2 id="根据key获取哈希桶数组索引位置"><a href="#根据key获取哈希桶数组索引位置" class="headerlink" title="根据key获取哈希桶数组索引位置"></a>根据key获取哈希桶数组索引位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //1. h=key.hashCode()    取hashCode值</span><br><span class="line">    //2. h^(H&gt;&gt;&gt;16)     高位参与运算</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // 3. (n-1)&amp;hash    取模运算</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong></p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用取模运算来计算该对象应该保存在table数组的哪个索引处。</p><p>通过(table.length -1)&amp;h来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。<strong>当length总是2的n次方时，(length-1)&amp; h运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br><em>补充一下：为什么求得的hash值是32位的？这是因为int类型4字节，4X8=32</em></p><p><img src="/images/HashMap21.png" alt=""></p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p><strong>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/images/HashMap22.png" alt=""></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/images/HashMap23.png" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/images/HashMap24.png" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。</p><p><code>final Node&lt;K,V&gt;[] resize()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //// 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // 链表优化重hash的代码块</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                         // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一点搞不懂，<code>if ((e.hash &amp; oldCap) == 0) {</code>这里为什么这么判断就能确定新增的1bit就是0呢😱😱😱。被二进制搞的头昏脑胀😖😞😟。<br>现在好像明白了，oldCap=01 0000，key1= 00 0101 , key2= 01 0101    key1&amp;oldCap=0，新增的1bit为0。应该是这样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>(n - 1) &amp; hash，当n是2次幂的时候，hash%n等于(n-1)&amp;hash，&amp;比%具有更高的效率</li><li>由于长度是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Metaspace</title>
    <link href="https://hsb786.github.io/2018/04/21/Metaspace/"/>
    <id>https://hsb786.github.io/2018/04/21/Metaspace/</id>
    <published>2018-04-21T04:21:05.000Z</published>
    <updated>2018-04-21T07:35:08.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish</p></blockquote><p>Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap</p><blockquote><p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.<br>JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。<br><a id="more"></a></p></blockquote><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>避免了OutOfMemoryError的问题。类的元数据分配只受本地内存大小的限制。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><ul><li>-XX:MetaspaceSize 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li><li>-XX:MaxMetaspaceSize 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li><li>-XX:MinMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li><li>-XX:MaxMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">深入探究JVM | 探秘 Metaspace </a></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p><p><a href="https://stackoverflow.com/questions/20563047/jdk-8-memory-layout-and-garbage-collection" target="_blank" rel="noopener">JDK 8 Memory Layout and garbage collection</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.&lt;br&gt;JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>jvm-GC</title>
    <link href="https://hsb786.github.io/2018/04/21/jvm-GC/"/>
    <id>https://hsb786.github.io/2018/04/21/jvm-GC/</id>
    <published>2018-04-21T03:10:31.000Z</published>
    <updated>2018-04-24T06:06:39.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字约定"><a href="#关键字约定" class="headerlink" title="关键字约定"></a>关键字约定</h2><ul><li>Young generation –&gt;新生代</li><li>Tenured / Old Generation –&gt;老年代</li><li>Perm Area –&gt;永久代</li></ul><p><img src="/images/JVM21.png" alt=""><br><a id="more"></a></p><h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><p>新生代是所有新对象产生的地方。当新生代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。新生代分为Enden、Survivor1、Survivor2。</p><ul><li>大多数新建的对象都位于Eden区。</li><li>当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。</li><li>Minor GC同样会检查存活下来的对象，如果需要会把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。</li><li>经过多次GC周期后，仍然存活下来的对象会被转移到老年代内存空间。通常这是在新生代有资格提升到老年代前通过设定年龄阈值(<em>默认15</em>)来完成的。</li></ul><h2 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h2><p>一些大对象(<em>长字符串或数组</em>)可能会直接存放到老年代。老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。 Major GC会花费更多的时间。</p><h2 id="永久代（Perm-Area）"><a href="#永久代（Perm-Area）" class="headerlink" title="永久代（Perm Area）"></a>永久代（Perm Area）</h2><p>永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。</p><blockquote><p>java8中移除了永久代，取而代之的是Metaspace(元空间)</p></blockquote><h2 id="重要的东东"><a href="#重要的东东" class="headerlink" title="重要的东东"></a>重要的东东</h2><ul><li>在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。</li><li>GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。</li><li>GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。</li><li>在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。</li><li>在从内存回收一个对象之前会调用对象的finalize()方法。</li><li>作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。</li><li>System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。</li><li>如果堆没有内存创建新的对象了，会抛出<code>OutOfMemoryError</code>。</li></ul><h2 id="GC针对什么对象？"><a href="#GC针对什么对象？" class="headerlink" title="GC针对什么对象？"></a>GC针对什么对象？</h2><p>了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(<em>比如：静态属性引用的常量</em>)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。</p><p><img src="/images/GC-Object.png" alt="GC回收对象"></p><h2 id="引用记数法"><a href="#引用记数法" class="headerlink" title="引用记数法"></a>引用记数法</h2><ul><li>思想：给对象设置引用计数器，每引用该对象一次，计数器就+1，引用失效时，计数器就-1，当任意时候引用计数器的值都为0时，则该对象可被回收</li><li>Java不适用原因：无法解决对象互相循环引用的问题</li></ul><h2 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h2><p>可达性分析法, 当一个对象通过一系列根对象(Root)都不可达时就会被回收。</p><p>可作为GC Root的对象有:</p><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><p>在可达性分析过程中，对象引用类型会对对象的生命周期产生影响，JAVA中有这几种类型的引用：</p><ul><li>强引用：只要该引用还有效，GC就不会回收</li><li>软引用：内存空间足够时不进行回收，在内存溢出发生前进行回收、用SoftReference类实现</li><li>弱引用：弱引用关联的对象只能存活到下一次Gc收集、用WeakReference类实现</li><li>虚引用：无法通过虚引用获得对象实例，也不会对对象的生存时间产生影响、唯一目的：当该对象被Gc收集时，收到一个系统通知。用PhantomReference类实现</li></ul><p>一个对象真正不可用，要经历两次标记过程：</p><ul><li>首先进行可达性分析，筛选出与GC Root没用引用链的对象，进行第一次标记</li><li>第一次标记后，再进行一次筛选，筛选条件是是否有必要执行finalize()方法。若对象有没有重写finalize()方法，或者finalize()是否已被jvm调用过，则没必要执行，GC会回收该对象</li><li>若有必要执行，则该对象会被放入F-Queue中，由jvm开启一个低优先级的线程去执行它（但不一定等待finalize执行完毕）。</li><li>finalize()是对象最后一次自救的机会，若对象在finalize()中重新加入到引用链中，则它会被移出要回收的对象的集合。其他对象则会被第二次标记，进行回收</li></ul><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><ol><li>标记清除算法<br> 分为标记和清除两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="/images/sweep.jpg" alt="标记清除"></li><li>复制算法<br> <strong>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中</strong>。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。<br><img src="/images/copy.jpg" alt="复制"></li><li><p>标记整理算法<br> <strong>标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理</strong>。优点是不会造成内存碎片。<br><img src="/images/compact.jpg" alt="标记整理"></p></li><li><p>分代收集算法</p></li></ol><ul><li>把堆分为新生代和老年代</li><li>新生代使用复制算法</li><li>将新生代内存分为一块大的Eden区和两块小的Survivor；每次使用Eden和一个Survivor，回收时将Eden和Survivor存活的对象复制到另一个Survivor（HotSpot的比例Eden：Survivor = 8：1）</li><li>老年代使用标记-清理或者标记-整理</li></ul><p><img src="/images/java虚拟机2.png" alt=""></p><h2 id="内存分配规则"><a href="#内存分配规则" class="headerlink" title="内存分配规则"></a>内存分配规则</h2><ul><li>对象优先在Eden分配<ul><li>当Eden区没有足够的空间时就会发起一次Minor GC</li></ul></li><li>大对象直接进入老年代<ul><li>典型的大对象是很长的字符串和数组</li></ul></li><li>长期存活的对象进入老年代<ul><li>每个对象有年龄计数器，每经过一次GC，计数器值加一，当到达一定程度时（默认15），就会进入老年代</li><li>年龄的阈值可通过参数 -XX:MaxTenuringThreshold设置</li></ul></li><li>对象年龄的判定<ul><li>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</li></ul></li><li>空间分配担保<ul><li>发生Minor GC前，jvm会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若大于，则Minor GC是安全的</li><li>若不大于，jvm会查看HandlePromotionFailure是否允许担保失败，若不允许，则改为一次Full GC</li><li>若允许担保失败，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试进行Minor GC；若小于，则要改为Full GC</li></ul></li></ul><h2 id="Java中垃圾回收器的类型"><a href="#Java中垃圾回收器的类型" class="headerlink" title="Java中垃圾回收器的类型"></a>Java中垃圾回收器的类型</h2><p>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p><ul><li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li><li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li><li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li><li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li><li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li><li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li></ul><h2 id="与GC有关的JVM参数"><a href="#与GC有关的JVM参数" class="headerlink" title="与GC有关的JVM参数"></a>与GC有关的JVM参数</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>设置JVM启动时堆的初始化大小。</td></tr><tr><td>-Xmx</td><td>设置堆最大值。</td></tr><tr><td>-Xmn</td><td>设置新生代的空间大小，剩下的为老年代的空间大小。</td></tr><tr><td>-XX:SurvivorRatio</td><td>提供Eden区和survivor区的空间比例。比如，如果新生代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。</td></tr><tr><td>-XX:NewRatio</td><td>提供老年代和新生代的比例大小。默认值是2。</td></tr><tr><td>-XX:MetaspaceSize</td><td>分配给类元数据空间的初始大小</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>分配给类元数据空间的最大值</td></tr><tr><td>-XX:MinMetaspaceFreeRatio</td><td>一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</td></tr><tr><td>-XX:MaxMetaspaceFreeRatio</td><td>一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</td></tr></tbody></table><h2 id="GC监控"><a href="#GC监控" class="headerlink" title="GC监控"></a>GC监控</h2><p>可以使用JDK自带的VisualVM进行监控</p><p><img src="/images/JVM22.png" alt="Java2D"></p><p><img src="/images/JVM23.png" alt="监视器"></p><p><img src="/images/JVM24.png" alt="线程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。java8开始永久代已移出</li><li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li><li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li><li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li><li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/05/13/jvm-GC/" target="_blank" rel="noopener">【译】Java中的垃圾回收机制 </a></p><p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">Java HotSpot VM Options</a></p><p><a href="http://www.importnew.com/14086.html" target="_blank" rel="noopener">Java内存与垃圾回收调优</a></p><p><a href="http://colobu.com/2015/04/14/Java-GC-memo/" target="_blank" rel="noopener">Java GC 中的一些概念</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关键字约定&quot;&gt;&lt;a href=&quot;#关键字约定&quot; class=&quot;headerlink&quot; title=&quot;关键字约定&quot;&gt;&lt;/a&gt;关键字约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Young generation –&amp;gt;新生代&lt;/li&gt;
&lt;li&gt;Tenured / Old Generation –&amp;gt;老年代&lt;/li&gt;
&lt;li&gt;Perm Area –&amp;gt;永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/JVM21.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Unsafe</title>
    <link href="https://hsb786.github.io/2018/04/20/Unsafe/"/>
    <id>https://hsb786.github.io/2018/04/20/Unsafe/</id>
    <published>2018-04-20T10:48:25.000Z</published>
    <updated>2018-04-20T13:19:46.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作</p></blockquote><p>Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, &quot;getUnsafe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //饿汉式单例</span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line"></span><br><span class="line">    @CallerSensitive</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        //获取调用该方法的调用者信息</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        //判断类加载器是否是系统类加载器</span><br><span class="line">        if (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">    .............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VM.class</span><br><span class="line"> public static boolean isSystemDomainLoader(ClassLoader loader) &#123;</span><br><span class="line">        return loader == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Unsafe.getUnsafe()只能被boostrap classloader加载的类使用，所以可以利用java反射来获取Unsafe的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取Unsafe类中的theUnsafe字段</span><br><span class="line">Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">//由于theUnsafe被private修饰，所以要跳过安全检查</span><br><span class="line">f.setAccessible(true);</span><br><span class="line">//获取当前f的值，也就是Unsafe的实例</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(null);</span><br></pre></td></tr></table></figure><p><code>public native long objectFieldOffset(Field f)</code>和<code>public native long staticFieldOffset(Field f)</code>：用于返回类定义中某个属性在主内存中设定的偏移量。相当于CAS中的V。</p><p><code>public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);</code>：对属性进行比较并替换（CAS过程——Compare And Swap）。offect：V，expected：A，x：B </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//java8</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        //自旋，一直循环直到compareAndSwapInt执行成功</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int     getIntVolatile(Object o, long offset);</span><br></pre></td></tr></table></figure><p><code>getAndAddInt()</code>采用的是基于Unsafe的”乐观锁”进行实现的，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。适合并发量不高的情况。</p><hr><h2 id="CallerSensitive"><a href="#CallerSensitive" class="headerlink" title="@CallerSensitive"></a>@CallerSensitive</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//sun.reflect.CallerSensitive</span><br><span class="line">/**</span><br><span class="line"> * A method annotated @CallerSensitive is sensitive to its calling class,</span><br><span class="line"> * via &#123;@link sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;,</span><br><span class="line"> * or via some equivalent.</span><br><span class="line"> *</span><br><span class="line"> * @author John R. Rose</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;METHOD&#125;)</span><br><span class="line">public @interface CallerSensitive &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//sun.reflect.Reflection</span><br><span class="line">/** Returns the class of the caller of the method calling this method,</span><br><span class="line">    ignoring frames associated with java.lang.reflect.Method.invoke()</span><br><span class="line">    and its implementation. */</span><br><span class="line">@CallerSensitive</span><br><span class="line">public static native Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure><blockquote><p>用@CallerSensitive注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用sun.reflect.Reflection.getCallerClass方法。</p></blockquote><p>Reflection类位于调用栈中的0帧位置，sun.reflect.Reflection.getCallerClass()方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p><p><em>感觉不太懂，做个标记，以后再来看吧</em></p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/yinwenjie/article/details/72909981" target="_blank" rel="noopener">线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） </a></p><p><a href="https://juejin.im/post/5921927c44d904006cca9720" target="_blank" rel="noopener">跟我一起剖析 Java 并发源码之 Unsafe</a></p><p><a href="https://blog.csdn.net/aguda_king/article/details/72355807" target="_blank" rel="noopener">JDK8的@CallerSensitive</a></p><p><a href="https://blog.csdn.net/HEL_WOR/article/details/50199797" target="_blank" rel="noopener">JVM注解@CallSensitive</a></p><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-2/" target="_blank" rel="noopener">深入解析Java反射（2） - invoke方法 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础2</title>
    <link href="https://hsb786.github.io/2018/04/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%802/"/>
    <id>https://hsb786.github.io/2018/04/20/多线程基础2/</id>
    <published>2018-04-20T05:28:33.000Z</published>
    <updated>2018-04-24T06:20:42.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。</p></blockquote><a id="more"></a><p>根据操作系统的不同（Windows/Unix/Linux/其他），他们所支持的线程底层实现和操作效果也是不尽相同的。不过一个操作系统支持的线程至少会有四种状态：就绪、运行、阻塞和终止。<strong>线程在四种状态下进行切换，都是要消耗不少的CPU计算能力的。</strong></p><p>根据操作系统使用线程的进程的不一样，线程还分为用户线程和操作系统线程。操作系统线程（内核线程），是指操作系统内核为了完成硬件接口层操作，<strong>由操作系统内核创建的线程</strong>：例如I/O操作的内核线程，这些线程应用程序是不能干预的；用户线程，是指用户安装/管理的应用程序，为执行某一种操作，而<strong>由这个应用程序创建的线程</strong>。</p><p><img src="/images/Thread01.jpg" alt=""></p><p>黄色钥匙代表对象锁</p><h2 id="thread-interrupt-，Thread-interrupted-，thread-isInterrupted"><a href="#thread-interrupt-，Thread-interrupted-，thread-isInterrupted" class="headerlink" title="thread.interrupt()，Thread.interrupted()，thread.isInterrupted()"></a>thread.interrupt()，Thread.interrupted()，thread.isInterrupted()</h2><p><img src="/images/Thread02.png" alt=""></p><p><img src="/images/Thread03.png" alt=""></p><p>当Thread收到interrupt信号是，可能的两种结果:</p><ol><li>线程处于运行状态时，线程对象的isInterrupt属性被置为true</li><li>处于阻塞状态是，抛出InterruptedException异常，其isInterrupt不会被置为true。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Tests whether the current thread has been interrupted.  The</span><br><span class="line">     * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span><br><span class="line">     * other words, if this method were to be called twice in succession, the</span><br><span class="line">     * second call would return false (unless the current thread were</span><br><span class="line">     * interrupted again, after the first call had cleared its interrupted</span><br><span class="line">     * status and before the second call had examined it).</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see #isInterrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><br><span class="line">     * status&lt;/i&gt; of the thread is unaffected by this method.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see     #interrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line">     * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line">     * passed.</span><br><span class="line">     */</span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure><p>可以看出interrupted和isInterrupted区别在于传给ClearInterrupted的参数是true还是false。</p><p><strong>ClearInterrupted参数向操作系统指明是否在获取状态后将当前线程的interrupted状态重置为false。</strong></p><p>这就意味着当某个线程的isInterrupt属性成功被置为true后，如果您使用对象方法thread.isInterrupted()获取值，无论您获取多少次得到的返回值都是true；但是如果您使用静态方法Thread.interrupted()获取值，那么只有第一次获取的结果是true，随后线程的isInterrupt属性将被恢复成false，后续无论使用Thread.interrupted()调用还是使用thread.isInterrupted()调用，获取的结果都是false。</p><p>wait和sleep都是让<strong>当前线程</strong>进入阻塞状态，yield是让主线程等待调用yield的线程执行完。</p><p>sleep和yield都是public static native void方法</p><hr><p>Java语言为我们提供了两种基础线程池的选择：ScheduledThreadPoolExecutor和ThreadPoolExecutor。它们都实现了ExecutorService接口（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）。</p><h2 id="JAVA主要线程池的继承结构"><a href="#JAVA主要线程池的继承结构" class="headerlink" title="JAVA主要线程池的继承结构"></a>JAVA主要线程池的继承结构</h2><p><img src="/images/Thread04.png" alt=""></p><ul><li>ThreadPoolExecutor：对于任务的执行是立即的、一次性的。</li><li>ScheduledThreadPoolExecutor：一个用来执行延迟任务、定时任务或者周期性任务的线程池。一般情况下，我们用它可以处理定时计算、周期性统计一类的任务。</li><li>ForkJoinPool：ScheduledThreadPoolExecutor和ThreadPoolExecutor都是在JDK1.5版本中提供的。在JDK1.7中，JAVA为我们提供了一种新的线程池ForkJoinPool以及配套的任务定义ForkJoinTask。除了可以执行实现了Runnable接口或者Callable接口的任务以外，ForkJoinPool还可以执行集成了ForkJoinTask定义的任务。ForkJoinPool的执行原理和ThreadPoolExecutor的执行原理是不一样的</li></ul><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在ThreadPoolExecutor线程池中，创建线程的工作交给ThreadFactory来完成。要使用线程池，就必须要指定ThreadFactory。</p><p>如果我们使用的构造函数时并没有指定使用的ThreadFactory，这个时候ThreadPoolExecutor会使用一个默认的ThreadFactory：DefaultThreadFactory。（这个类在Executors工具类中）</p><p><strong>Executors工具类和ThreadPoolExecutor类存在循环依赖：ThreadPoolExecutor中使用了Executors工具类中定义的DefaultThreadFactory；而在Executors工具类中却又在创建ThreadPoolExecutor的对象实例。</strong></p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/column/details/yinwenjiethread.html" target="_blank" rel="noopener">多线程基础</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://hsb786.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://hsb786.github.io/2018/04/19/CAS/"/>
    <id>https://hsb786.github.io/2018/04/19/CAS/</id>
    <published>2018-04-19T09:41:51.000Z</published>
    <updated>2018-04-24T06:25:08.055Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CAS（Compare And Swap），翻译过来就是比较和替换。</strong></p><p><strong>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</strong></p><p><strong>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。</strong></p><a id="more"></a><p>举个栗子🎂</p><ol><li>在内存地址V当中，存储着值为10的变量。</li></ol><p><img src="/images/CAS01.png" alt=""></p><ol start="2"><li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</li></ol><p><img src="/images/CAS02.png" alt=""></p><ol start="3"><li>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11</li></ol><p><img src="/images/CAS03.png" alt=""></p><ol start="4"><li>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</li></ol><p><img src="/images/CAS04.png" alt=""></p><ol start="5"><li>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</li></ol><p><img src="/images/CAS05.png" alt=""></p><ol start="6"><li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</li></ol><p><img src="/images/CAS06.png" alt=""></p><ol start="7"><li>线程1进行SWAP，把地址V的值替换为B，也就是12。</li></ol><p><img src="/images/CAS07.png" alt=""></p><hr><h2 id="synchronized与CAS"><a href="#synchronized与CAS" class="headerlink" title="synchronized与CAS"></a>synchronized与CAS</h2><p><strong>synchronized关键字会让没有得到线程锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的切换，代价比较高。</strong></p><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>指的是<code>java.util.concurrent.atomic</code>包下，一系列以Atomic开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int value;</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unsafe</strong>：Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。<strong>unsafe为我们提供了硬件级别的原子操作。</strong></p><p><strong>valueOffset</strong>：至于valueOffset对象，是通过unsafe.objectFieldOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单地把valueOffset理解为value变量的内存地址。</p><p>getAndIncrement 相当于i++，先返回值再加1</p><p>在java7中是这样实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getAndIncrement方法内部会不停的循环，直到unsafe.comparAndSwapInt方法执行成功。<br>valueOffset相当于前面讲的V，expect：旧的预期值A，update：新的预期值B</p><hr><p>java8中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这时需要查看Unsafe的源码，可以下载openjdk，openjdk中有关于<code>sun.misc</code>包中的源码</em>。需要注意的是，由于版本不一致，导致跟代码的时候会不准确。而且我发现同样是java8，代码还有些不一样，可能是java8的版本不一致导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int     getIntVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                  int expected,</span><br><span class="line">                                                  int x);</span><br></pre></td></tr></table></figure><p>感觉跟jdk7差不多，只是把自旋部分的代码从AtomicInteger移动到了Unsafe中。</p><p>Java语言CAS底层就是利用unsafe提供的原子性操作方法来实现的。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>1. CPU开销较大</strong></p><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p><strong>2. 不能保证代码块的原子性</strong></p><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p><p><strong>3. ABA问题</strong></p><p>当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。利用版本号比较可以有效解决ABA问题。</p><hr><p><em>参考</em></p><blockquote><p><a href="http://mp.weixin.qq.com/s/f9PYMnpAgS1gAQYPDuCq-w" target="_blank" rel="noopener">漫画：什么是CAS机制？</a></p><p><a href="http://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg" target="_blank" rel="noopener">漫画：什么是CAS机制？（进阶篇）</a></p><p><a href="https://blog.csdn.net/yinwenjie/article/details/72909981" target="_blank" rel="noopener">线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CAS（Compare And Swap），翻译过来就是比较和替换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>RESTful</title>
    <link href="https://hsb786.github.io/2018/04/18/RESTful/"/>
    <id>https://hsb786.github.io/2018/04/18/RESTful/</id>
    <published>2018-04-18T05:37:06.000Z</published>
    <updated>2018-04-24T06:26:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他在论文中提到：</p><blockquote><p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”<br><a id="more"></a></p></blockquote><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer（表现层状态转化）的缩写。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><h2 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息</strong>。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）</strong>。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="HTTP协议，是一个无状态协议，无状态是什么意思"><a href="#HTTP协议，是一个无状态协议，无状态是什么意思" class="headerlink" title="HTTP协议，是一个无状态协议，无状态是什么意思"></a>HTTP协议，是一个无状态协议，无状态是什么意思</h3><h4 id="回答1"><a href="#回答1" class="headerlink" title="回答1"></a>回答1</h4><p>有状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：还不错，挺好吃的。  </p><p>无状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：？？？啊？啥？啥味道怎么样？</p><p>所以需要cookie这种东西：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：你今天中午吃的大盘鸡味道怎么样呀？<br>B：还不错，挺好吃的。</p><h4 id="回答2"><a href="#回答2" class="headerlink" title="回答2"></a>回答2</h4><ul><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见</li></ul><p>【状态】的含义就是：客户端和服务器在某次会话中产生的数据，从而【无状态】就意味着，这些数据不会被保留</p><p>但是：</p><ul><li>通过增加cookie和session机制，现在的网络请求其实是有状态的</li><li>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p><strong>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</strong></p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>例子</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p><p><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP是一个无状态的协议。这句话里的无状态是什么意思？</a></p><p><a href="http://www.cnblogs.com/bellkosmos/p/5237146.html" target="_blank" rel="noopener">http协议无状态中的 “状态” 到底指的是什么？！</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api" target="_blank" rel="noopener">RESTful API 设计指南</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。&lt;/p&gt;
&lt;p&gt;他在论文中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://hsb786.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="https://hsb786.github.io/2018/04/18/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/18/基本排序算法/</id>
    <published>2018-04-18T04:27:50.000Z</published>
    <updated>2018-04-20T13:21:43.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：<strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void quickSort(int[] array) &#123;</span><br><span class="line">    quickSort(array, 0, array.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = partion(array, left, right);</span><br><span class="line">    quickSort(array, left, mid - 1);</span><br><span class="line">    quickSort(array, mid + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int partion(int[] array, int left, int right) &#123;</span><br><span class="line">    // 取第一个数为基准元素</span><br><span class="line">    int tmp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; array[right] &gt;= tmp) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素小的移动到低端</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= tmp) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素大的移动到高端</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入基准元素</span><br><span class="line">    array[left] = tmp;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：<strong>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列</strong></p><p><img src="/images/sort-merge.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void mergeSort(int[] arr) &#123;</span><br><span class="line">int[] temp = new int[arr.length];</span><br><span class="line">mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序</span><br><span class="line">mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序</span><br><span class="line">merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">int i = left;// 左序列指针</span><br><span class="line">int j = mid + 1;// 右序列指针</span><br><span class="line">int t = 0;// 临时数组指针</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">if (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (i &lt;= mid) &#123;// 将左边剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;= right) &#123;// 将右序列剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">t = 0;</span><br><span class="line">// 将temp中的元素全部拷贝到原数组中</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">arr[left++] = temp[t++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;基本思想：&lt;strong&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hsb786.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/代理模式/</id>
    <published>2018-04-17T10:21:28.000Z</published>
    <updated>2018-04-20T13:20:26.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为其他对象提供一种代理以控制对这个对象的访问<br><a id="more"></a><br><img src="/images/design-pattern-proxy.png" alt=""></p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>代理对象可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能，符合开闭原则</p></li><li><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p></li></ul><h2 id="代理类分类"><a href="#代理类分类" class="headerlink" title="代理类分类"></a>代理类分类</h2><ul><li><p>静态代理:静态定义代理类，我们自己静态定义的代理类。</p></li><li><p>动态代理:通过程序动态生成代理类，该代理类不是我们自己定义的，而是由程序自动生成，常用的动态代理技术有JDK自带的动态代理和CGLIB动态代理。</p></li></ul><hr><p>*参考</p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/30/代理模式/" target="_blank" rel="noopener">代理模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/策略模式/</id>
    <published>2018-04-17T10:07:27.000Z</published>
    <updated>2018-04-20T13:20:07.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p></blockquote><p>根据条件的不同选择不同的策略<br><a id="more"></a></p><p><img src="/images/design-pattern-strategy01.png" alt=""></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用享元模式在一定程度上减少对象的数量。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1691" target="_blank" rel="noopener">设计模式（十二）——策略模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据条件的不同选择不同的策略&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="https://hsb786.github.io/2018/04/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://hsb786.github.io/2018/04/17/抽象工厂/</id>
    <published>2018-04-17T09:17:08.000Z</published>
    <updated>2018-04-20T13:20:15.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。<br><a id="more"></a><br><img src="/images/design-pattern-factory02.png" alt=""></p><hr><h2 id="产品等级结构和产品族"><a href="#产品等级结构和产品族" class="headerlink" title="产品等级结构和产品族"></a>产品等级结构和产品族</h2><p>产品等级结构： <strong>产品等级结构即产品的继承结构，同一类产品</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p>产品族：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，同一个品牌产品</strong>，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><h2 id="抽象工厂与工厂方法"><a href="#抽象工厂与工厂方法" class="headerlink" title="抽象工厂与工厂方法"></a>抽象工厂与工厂方法</h2><p>抽象工厂和工厂方法最大的区别在于，工厂方法针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p><p>工厂方法：用来生产同一等级结构中的固定产品（支持增加任意产品，新增产品是不需要更改已有的工程，需要增加该产品对应的工程。符合单一职责原则、符合开闭原则。但是引入了复杂性）</p><p>抽象工厂：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开闭原则，降低了复杂性）</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>每次可以通过具体工厂类创建一个产品族的多个对象，增加新的具体工厂和产品族很方便。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/13/工厂模式-下/" target="_blank" rel="noopener">工厂模式-下</a></p><p><a href="http://www.hollischuang.com/archives/1430" target="_blank" rel="noopener">设计模式（八）——工厂模式总结</a><br><a href="http://www.hollischuang.com/archives/1420" target="_blank" rel="noopener">设计模式（七）——抽象工厂模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://hsb786.github.io/2018/04/17/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/17/工厂方法/</id>
    <published>2018-04-17T09:05:30.000Z</published>
    <updated>2018-04-20T13:21:25.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义了一个用于创建对象的接口，让子类决定实例化哪一个类。</p></blockquote><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br><a id="more"></a><br><img src="/images/design-pattern-factory01.png" alt=""></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/08/工厂模式/" target="_blank" rel="noopener">工厂模式(上)</a></p><p><a href="http://www.cnblogs.com/xiaoxi/p/7641358.html" target="_blank" rel="noopener">设计模式：工厂方法模式</a></p><p><a href="http://www.hollischuang.com/archives/1401" target="_blank" rel="noopener">设计模式（五）——工厂方法模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义了一个用于创建对象的接口，让子类决定实例化哪一个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
