<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-24T05:25:15.267Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>山鬼</title>
    <link href="https://hsb786.github.io/2018/04/24/%E5%B1%B1%E9%AC%BC/"/>
    <id>https://hsb786.github.io/2018/04/24/山鬼/</id>
    <published>2018-04-24T05:10:17.000Z</published>
    <updated>2018-04-24T05:25:15.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。<br><a id="more"></a></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=445198021&auto=0&height=66"></iframe><p><strong>九歌·山鬼</strong></p><p> 若有人兮山之阿，被薜荔兮带女罗。</p><p> 既含睇兮又宜笑，子慕予兮善窈窕。</p><p> 乘赤豹兮从文里，辛夷车兮结旗。</p><p> 被石兰兮带杜衡。折芳馨兮遗所思。</p><p> 余处幽篁兮终不见天，路险难兮独后来。</p><p> 表独立兮山之类上，云容容兮而在下。</p><p> 杳冥冥兮羌昼晦，东风飘兮神灵雨。</p><p> 留灵修兮忘归，岁既晏兮孰华予。</p><p> 采三秀兮於山间，石磊磊兮葛蔓蔓。</p><p> 怨公子兮怅忘归，君思我兮不得闲。</p><p> 山中人兮芳杜若，饮石泉兮荫松柏。</p><p> 君我兮然疑作。</p><p> 雷填填兮雨冥冥，猿啾啾兮又夜鸣。</p><p> 风飒飒兮木萧萧，思公子兮徙离忧。 </p><hr><p> <a href="https://music.douban.com/review/8790064/" target="_blank" rel="noopener"> 山鬼自啼风雨·《山鬼》乐评. </a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在循环的一首音乐，歌词出自屈原《楚辞·九歌》中的第九章。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://hsb786.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://hsb786.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>RandomAccess</title>
    <link href="https://hsb786.github.io/2018/04/23/RandomAccess/"/>
    <id>https://hsb786.github.io/2018/04/23/RandomAccess/</id>
    <published>2018-04-23T10:30:51.000Z</published>
    <updated>2018-04-23T10:58:03.042Z</updated>
    
    <content type="html"><![CDATA[<p>JDK官方文档上的解释：</p><blockquote><p>Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.<br>大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。<br><a id="more"></a></p></blockquote><p>只定义了一个接口，里面什么都没有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释上举了个栗子🎂，例如下面代码中第一种循环运行比第二种快<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (int i=0, n=list.size(); i &amp;lt; n; i++)</span><br><span class="line"> *         list.get(i);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * runs faster than this loop:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     for (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line"> *         i.next();</span><br><span class="line"> * &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><p>so，在遍历ArrayList时，优先使用第一种循环；在遍历LinkedList则使用第二种循环。<br>根据有没有实现RandomAccess接口来判断。<br>ArrayList实现了RandomAccess接口，LinkedList没有实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Collections.class</span><br><span class="line">public static &lt;T&gt;</span><br><span class="line">int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        return Collections.indexedBinarySearch(list, key);</span><br><span class="line">    else</span><br><span class="line">        return Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>foreach内部是通过Iterator实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">for(String s:list) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的字节码文件。<br>从第27，37，54行可以看出，foreach其实是通过Iterator来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class al.T01 &#123;</span><br><span class="line">  public al.T01();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Exception;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #19                 // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #21                 // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: ldc           #22                 // String a</span><br><span class="line">      11: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      16: pop</span><br><span class="line">      17: aload_1</span><br><span class="line">      18: ldc           #30                 // String b</span><br><span class="line">      20: invokeinterface #24,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line">      25: pop</span><br><span class="line">      26: aload_1</span><br><span class="line">      27: invokeinterface #32,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</span><br><span class="line">      32: astore_3</span><br><span class="line">      33: goto          53</span><br><span class="line">      36: aload_3</span><br><span class="line">      37: invokeinterface #36,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</span><br><span class="line">      42: checkcast     #42                 // class java/lang/String</span><br><span class="line">      45: astore_2</span><br><span class="line">      46: getstatic     #44                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      49: aload_2</span><br><span class="line">      50: invokevirtual #50                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      53: aload_3</span><br><span class="line">      54: invokeinterface #56,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z</span><br><span class="line">      59: ifne          36</span><br><span class="line">      62: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK官方文档上的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.  The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists.&lt;br&gt;大致意思就是：RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机顺序访问的list中表现的更加高效。&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot</title>
    <link href="https://hsb786.github.io/2018/04/23/HotSpot/"/>
    <id>https://hsb786.github.io/2018/04/23/HotSpot/</id>
    <published>2018-04-23T10:15:36.000Z</published>
    <updated>2018-04-23T12:52:33.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&lt;&lt;深入理解Java虚拟机：JVM高级特性与最佳实践&gt;&gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄</p></blockquote><a id="more"></a><p>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。</p><p>HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利），<strong>HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知<a href="https://hsb786.github.io/2018/04/09/术语/">JIT编译器</a>以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</strong></p><p>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</p><p>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;经常看到HotSpot，但不知道是什么。so，这是一篇科普文。摘自&amp;lt;&amp;lt;深入理解Java虚拟机：JVM高级特性与最佳实践&amp;gt;&amp;gt;。等以后工作了，一定要看这本神书，看下有没有传说中的那么神奇。🙄🙄&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap</title>
    <link href="https://hsb786.github.io/2018/04/22/LinkedHashMap/"/>
    <id>https://hsb786.github.io/2018/04/22/LinkedHashMap/</id>
    <published>2018-04-22T11:37:01.000Z</published>
    <updated>2018-04-23T11:06:33.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LinkedHashMap 保证插入数据的有序性</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;</span><br><span class="line">    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The head (eldest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The tail (youngest) of the doubly linked list.</span><br><span class="line">     */</span><br><span class="line">    transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">     * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">     *</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    final boolean accessOrder;</span><br><span class="line"></span><br><span class="line">    public LinkedHashMap() &#123;</span><br><span class="line">        super();</span><br><span class="line">        accessOrder = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap内部没有重写put方法，很好奇，是怎么把链表加上去的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</span><br><span class="line">    ....................</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一篇博客上看到加链表是通过<code>afterNodeInsertion(evict)</code>。可以看出每次put的时候都调用了<code>afterNodeInsertion(evict)</code>; 而这个afterNodeInsertion在LinkedHashMap中是重写了的。然后就傻呼呼的相信了，but 在<code>afterNodeInsertion(evict)</code>中并没有添加链表啊，傻傻的盯着这段代码看了很久。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，开始自己找。发现了<code>linkNodeLast()</code>方法，这不就是实现链表的关键吗。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// link at the end of list</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p;</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着发现<code>linkNodeLast()</code>在<code>newNode()</code>中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>并且newNode()在HashMap中也存在，注释还写得清清楚楚，就是用来被LinkedHashMap重写的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//HashMap.class</span><br><span class="line">/* ------------------------------------------------------------ */</span><br><span class="line">// LinkedHashMap support</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* The following package-protected methods are designed to be</span><br><span class="line">* overridden by LinkedHashMap, but not by any other subclass.</span><br><span class="line">* Nearly all other internal methods are also package-protected</span><br><span class="line">* but are declared final, so can be used by LinkedHashMap, view</span><br><span class="line">* classes, and HashSet.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// Create a regular (non-tree) node</span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>putVal()</code>中调用了<code>newNode()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就解释通了，LinkedHashMap没有重写put方法。为了保证有序，那么他是怎么实现链表的呢？</p><p>利用多态，通过重写<code>newNode()</code>方法，在<code>newNode()</code>方法中实现了链表的连接。而<code>newNode</code>方法在<code>putVal()</code>中调用了。so，每次添加元素的时候，同时会维护一个双向链表。通过链表实现了有序。</p><p>看来，平时不能太依赖于网上别人分析的东西，不一定是对的。</p><hr><p><strong>accessOrder</strong></p><p>LinkedHashMap中定义了accessOrder属性。官方是这样解释的：accessOrder为true时，迭代顺序就是访问顺序；为false时，迭代顺序就是插入顺序。<br>插入顺序倒好理解，访问顺序是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">*</span><br><span class="line">* @serial</span><br><span class="line">*/</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap重写了<code>get(Object key)</code>方法。accessOrder为true时，调用了<code>afterNodeAccess(e);</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e = getNode(hash(key), key)) == null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 方法注解写的很明白，move node to last，把node移动到最后。意思就是如果accessOrder设为true时，每次通过get()获取，都会把获取的元素移到链表的最后面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = null;</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a;</span><br><span class="line">        else</span><br><span class="line">            b.after = a;</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b;</span><br><span class="line">        else</span><br><span class="line">            last = b;</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>final boolean accessOrder;</code> accessOrder包访问权限，也没有set方法，只能通过<code>public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder)</code> 构造函数来将accessOrder设为true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor,</span><br><span class="line">                         boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor);</span><br><span class="line">        this.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LinkedHashMap 保证插入数据的有序性&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashSet</title>
    <link href="https://hsb786.github.io/2018/04/22/HashSet/"/>
    <id>https://hsb786.github.io/2018/04/22/HashSet/</id>
    <published>2018-04-22T10:44:43.000Z</published>
    <updated>2018-04-22T11:37:57.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HashSet 底层由HashMap实现<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    //HashSet底层使用HashMap实现</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    //HashSet add(E e)方法中，key为e，value为PRESENT</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line"></span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new, empty linked hash set.  (This package private</span><br><span class="line">     * constructor is only used by LinkedHashSet.) The backing</span><br><span class="line">     * HashMap instance is a LinkedHashMap with the specified initial</span><br><span class="line">     * capacity and the specified load factor.</span><br><span class="line">     *</span><br><span class="line">     * @param      initialCapacity   the initial capacity of the hash map</span><br><span class="line">     * @param      loadFactor        the load factor of the hash map</span><br><span class="line">     * @param      dummy             ignored (distinguishes this</span><br><span class="line">     *             constructor from other int, float constructor.)</span><br><span class="line">     * @throws     IllegalArgumentException if the initial capacity is less</span><br><span class="line">     *             than zero, or if the load factor is nonpositive</span><br><span class="line">     */</span><br><span class="line">     //这个就有点意思了，dummy参数其实没用，只是为了重载，与其它方法区分开了而已，这样也行！</span><br><span class="line">     //注意的是返回的是LinkedHashMap，数据是有顺序的。</span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><code>add(E e)</code>,<code>remove(Object o)</code>只是直接调用HashMap的put和remove方法。<br>key: e ; value : PRESENT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HashSet 底层由HashMap实现&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Java内存访问重排序的研究（转载）</title>
    <link href="https://hsb786.github.io/2018/04/21/Java%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>https://hsb786.github.io/2018/04/21/Java内存访问重排序的研究/</id>
    <published>2018-04-21T13:40:14.000Z</published>
    <updated>2018-04-24T05:49:34.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">原文链接</a><br><a id="more"></a></p></blockquote><h2 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class PossibleReordering &#123;</span><br><span class="line">static int x = 0, y = 0;</span><br><span class="line">static int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread one = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            a = 1;</span><br><span class="line">            x = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread other = new Thread(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            b = 1;</span><br><span class="line">            y = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p><p>然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程，如下图所示。值得注意的是，a=1和x=b这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”(reordering)。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p><p><img src="/images/reordered01.png" alt=""></p><p>对重排序现象不太了解的开发者可能会对这种现象感到吃惊，但是，笔者开发环境下做的一个小实验证实了这一结果。</p><p><img src="/images/reordered02.png" alt=""></p><p>实验代码是构造一个循环，反复执行上面的实例代码，直到出现a=0且b=0的输出为止。实验结果说明，循环执行到第13830次时输出了(0,0).</p><p>大多数现代微处理器都会采用将<strong>指令乱序执行（out-of-order execution，简称OoOE或OOE）</strong>的方法，<strong>在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。</strong>通过乱序执行的技术，处理器可以大大提高执行效率。<br>除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作，即生成的机器指令与字节码指令顺序不一致。</p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p><strong>As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的</strong>。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。<br>比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成Java字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</p><ul><li>对a赋值1</li><li>对b赋值2</li><li>取a的值</li><li>取b的值</li><li>将取到两个值相加后存入c</li></ul><p>在上面5个动作中，动作1可能会和动作2、4重排序，动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，一旦重排，as-if-serial语义便无法保证。</p><p>为保证as-if-serial语义，<strong>Java异常处理机制也会为重排序做一些特殊处理</strong>。例如在下面的代码中，y = 0 / 0可能会被重排序在x = 2之前执行，为了保证最终不致于输出x = 1的错误结果，<strong>JIT在重排序时会在catch语句中插入错误代偿代码，将x赋值为2，将程序恢复到发生异常时应有的状态</strong>。这种做法的确将异常捕捉的逻辑变得复杂了，但是JIT的优化的原则是，<strong>尽力优化正常运行下的代码逻辑，哪怕以catch块逻辑变得复杂为代价</strong>，毕竟，进入catch块内是一种“异常”情况的表现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Reordering &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        x = 1;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 2;</span><br><span class="line">            y = 0 / 0;    </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存访问重排序与内存可见性"><a href="#内存访问重排序与内存可见性" class="headerlink" title="内存访问重排序与内存可见性"></a>内存访问重排序与内存可见性</h2><p>计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。其模型如下图所示。</p><p><img src="/images/reordered03.png" alt=""></p><p>在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。<br>有的观点会将这种现象也视为重排序的一种，命名为“内存系统重排序”。因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。<br>这种内存可见性问题也会导致章节一中示例代码即便在没有发生指令重排序的情况下的执行结果也还是(0, 0)。</p><h2 id="内存访问重排序与Java内存模型"><a href="#内存访问重排序与Java内存模型" class="headerlink" title="内存访问重排序与Java内存模型"></a>内存访问重排序与Java内存模型</h2><p>Java的目标是成为一门平台无关性的语言，即Write once, run anywhere. 但是<strong>不同硬件环境下指令重排序的规则不尽相同</strong>。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-1337制定了<strong>Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性</strong>。从Java 5开始，Java内存模型成为Java语言规范的一部分。<br>根据Java内存模型中的规定，可以总结出以下几条happens-before规则。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p><ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul><p>Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4。</p><p>除此之外，Java内存模型对volatile和final的语义做了扩展。对volatile语义的扩展保证了volatile变量在一些情况下不会重排序，volatile的64位变量double和long的读取和赋值操作都是原子的。对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（的前提是没有this引用溢出）。</p><p>Java内存模型关于重排序的规定，总结后如下表所示。</p><p><img src="/images/reordered04.png" alt=""></p><p>表中“第二项操作”的含义是指，第一项操作之后的所有指定操作。如，普通读不能与其之后的所有volatile写重排序。另外，JMM也规定了上述volatile和同步块的规则尽适用于存在多线程访问的情景。例如，若编译器（这里的编译器也包括JIT，下同）证明了一个volatile变量只能被单线程访问，那么就可能会把它做为普通变量来处理。<br>留白的单元格代表允许在不违反Java基本语义的情况下重排序。例如，编译器不会对对同一内存地址的读和写操作重排序，但是允许对不同地址的读和写操作重排序。</p><p>除此之外，为了保证final的新增语义。JSR-133对于final变量的重排序也做了限制。</p><ul><li>构建方法内部的final成员变量的存储，并且，假如final成员变量本身是一个引用的话，这个final成员变量可以引用到的一切存储操作，都不能与构建方法外的将当期构建对象赋值于多线程共享变量的存储操作重排序。例如对于如下语句<br>x.finalField = v; … ;  构建方法边界sharedRef = x;<br>v.afield = 1; x.finalField = v; … ; 构建方法边界sharedRef = x;<br>这两条语句中，构建方法边界前后的指令都不能重排序。</li><li>初始读取共享对象与初始读取该共享对象的final成员变量之间不能重排序。例如对于如下语句<br>x = sharedRef; … ; i = x.finalField;<br>前后两句语句之间不会发生重排序。由于这两句语句有数据依赖关系，编译器本身就不会对它们重排序，但确实有一些处理器会对这种情况重排序，因此特别制定了这一规则。</li></ul><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下几种类型  </p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul><p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。<br>为了实现上一章中讨论的JSR-133的规定，Java编译器会这样使用内存屏障。</p><p><img src="/images/reordered05.png" alt=""></p><p>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。<br>x.finalField = v; StoreStore; sharedRef = x;</p><h2 id="Intel-64-IA-32架构下的内存访问重排序"><a href="#Intel-64-IA-32架构下的内存访问重排序" class="headerlink" title="Intel 64/IA-32架构下的内存访问重排序"></a>Intel 64/IA-32架构下的内存访问重排序</h2><p>Intel 64和IA-32是我们较常用的硬件环境，相对于其它处理器而言，它们拥有一种较严格的重排序规则。Pentium 4以后的Intel 64或IA-32处理的重排序规则如下。</p><p>在单CPU系统中</p><ul><li>读操作不与其它读操作重排序。</li><li>写操作不与其之前的写操作重排序。</li><li>写内存操作不与其它写操作重排序，但有以下几种例外</li><li>CLFLUSH的写操作</li><li>带有non-temporal move指令(MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, and MOVNTPD)的streaming写入。</li><li>字符串操作</li><li>读操作可能会与其之前的写不同位置的写操作重排序，但不与其之前的写相同位置的写操作重排序。</li><li>读和写操作不与I/O指令，带锁的指令或序列化指令重排序。</li><li>读操作不能重排序到LFENCE和MFENCE之前。</li><li>写操作不能重排序到LFENCE、SFENCE和MFENCE之前。</li><li>LFENCE不能重排序到读操作之前。</li><li>SFENCE不能重排序到写之前。</li><li>MFENCE不能重排序到读或写操作之前。</li></ul><p>在多处理器系统中</p><ul><li>各自处理器内部遵循单处理器的重排序规则。</li><li>单处理器的写操作对所有处理器可见是同时的。</li><li>各自处理器的写操作不会重排序。</li><li>内存重排序遵守因果性(causality)（内存重排序遵守传递可见性）。</li><li>任何写操作对于执行这些写操作的处理器之外的处理器来看都是一致的。</li><li>s带锁指令是顺序执行的。</li></ul><p>值得注意的是，对于Java编译器而言，Intel 64/IA-32架构下处理器不需要LoadLoad、LoadStore、StoreStore屏障，因为不会发生需要这三种屏障的重排序。</p><h2 id="一例Intel-64-IA-32架构下的代码性能优化"><a href="#一例Intel-64-IA-32架构下的代码性能优化" class="headerlink" title="一例Intel 64/IA-32架构下的代码性能优化"></a>一例Intel 64/IA-32架构下的代码性能优化</h2><p>现在有这样一个场景，一个容器可以放一个东西，容器支持create方法来创建一个新的东西并放到容器里，支持get方法取到这个容器里的东西。我们可以较容易地写出下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程场景下，这段代码执行起来是没有问题的。但是在多线程并发场景下，由不同的线程create和get东西，这段代码是有问题的。问题的原因与普通的双重检查锁定单例模式(Double Checked Locking, DCL)10类似，即SomeThing的构建与将指向构建中的SomeThing引用赋值到object变量这两者可能会发生重排序。导致get中返回一个正被构建中的不完整的SomeThing对象实例。为了解决这一问题，通常的办法是使用volatile修饰object字段。这种方法避免了重排序，保证了内存可见性，摒弃比使用同步块导致的性能损失更小。但是，假如使用场景对object的内存可见性并不敏感的话（不要求一个线程写入了object，object的新值立即对下一个读取的线程可见），在Intel 64/IA-32环境下，有更好的解决方案。</p><p>根据上一章的内容，我们知道Intel 64/IA-32下写操作之间不会发生重排序，即在处理器中，构建SomeThing对象与赋值到object这两个操作之间的顺序性是可以保证的。这样看起来，仅仅使用volatile来避免重排序是多此一举的。但是，Java编译器却可能生成重排序后的指令。但令人高兴的是，Oracle的JDK中提供了Unsafe. putOrderedObject，Unsafe. putOrderedInt，Unsafe. putOrderedLong这三个方法，JDK会在执行这三个方法时插入StoreStore内存屏障，避免发生写操作重排序。而在Intel 64/IA-32架构下，StoreStore屏障并不需要，Java编译器会将StoreStore屏障去除。比起写入volatile变量之后执行StoreLoad屏障的巨大开销，采用这种方法除了避免重排序而带来的性能损失以外，不会带来其它的性能开销。</p><p>我们将做一个小实验来比较二者的性能差异。一种是使用volatile修饰object成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile  SomeThing object;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        object = new SomeThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield(); //不加这句话可能会在此出现无限循环</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是利用Unsafe. putOrderedObject在避免在适当的位置发生重排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Container &#123;</span><br><span class="line">    public static class SomeThing &#123;</span><br><span class="line">        private int status;</span><br><span class="line"></span><br><span class="line">        public SomeThing() &#123;</span><br><span class="line">            status = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SomeThing object;</span><br><span class="line"></span><br><span class="line">    private Object value;</span><br><span class="line">    private static final Unsafe unsafe = getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(Container.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void create() &#123;</span><br><span class="line">        SomeThing temp = new SomeThing();</span><br><span class="line">        unsafe.putOrderedObject(this, valueOffset, null);    //将value赋null值只是一项无用操作，实际利用的是这条语句的内存屏障</span><br><span class="line">        object = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SomeThing get() &#123;</span><br><span class="line">        while (object == null) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            return (Unsafe)f.get(null);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接调用Unsafe.getUnsafe()需要配置JRE获取较高权限，我们利用反射获取Unsafe中的theUnsafe来取得Unsafe的可用实例。<br>unsafe.putOrderedObject(this, valueOffset, null)<br>这句仅仅是为了借用这句话功能的防止写重排序，除此之外无其它作用。</p><p>利用下面的代码分别测试两种方案的实际运行时间。在运行时开启-server和 -XX:CompileThreshold=1以模拟生产环境下长时间运行后的JIT优化效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    final int THREADS_COUNT = 20;</span><br><span class="line">    final int LOOP_COUNT = 100000;</span><br><span class="line"></span><br><span class="line">    long sum = 0;</span><br><span class="line">    long min = Integer.MAX_VALUE;</span><br><span class="line">    long max = 0;</span><br><span class="line">    for(int n = 0;n &lt;= 100;n++) &#123;</span><br><span class="line">        final Container basket = new Container();</span><br><span class="line">        List&lt;Thread&gt; putThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        List&lt;Thread&gt; takeThreads = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            putThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.create();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            takeThreads.add(new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; LOOP_COUNT; j++) &#123;</span><br><span class="line">                        basket.get().getStatus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).start();</span><br><span class="line">            putThreads.get(i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            takeThreads.get(i).join();</span><br><span class="line">            putThreads.get(i).join();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line">        long period = end - start;</span><br><span class="line">        if(n == 0) &#123;</span><br><span class="line">            continue;    //由于JIT的编译，第一次执行需要更多时间，将此时间不计入统计</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (period);</span><br><span class="line">        System.out.println(period);</span><br><span class="line">        if(period &lt; min) &#123;</span><br><span class="line">            min = period;</span><br><span class="line">        &#125;</span><br><span class="line">        if(period &gt; max) &#123;</span><br><span class="line">            max = period;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Average : &quot; + sum / 100);</span><br><span class="line">    System.out.println(&quot;Max : &quot; + max);</span><br><span class="line">    System.out.println(&quot;Min : &quot; + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的计算机上运行测试，采用volatile方案的运行结果如下<br>Average : 62535770<br>Max : 82515000<br>Min : 45161000</p><p>采用unsafe.putOrderedObject方案的运行结果如下<br>Average : 50746230<br>Max : 68999000<br>Min : 38038000</p><p>从结果看出，unsafe.putOrderedObject方案比volatile方案平均耗时减少18.9%，最大耗时减少16.4%，最小耗时减少15.8%.另外，即使在其它会发生写写重排序的处理器中，由于StoreStore屏障的性能损耗小于StoreLoad屏障，采用这一方法也是一种可行的方案。但值得再次注意的是，这一方案不是对volatile语义的等价替换，而是在特定场景下做的特殊优化，它仅避免了写写重排序，但不保证内存可见性。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;美团技术博客上的一篇文章，讲的很好，就是到了后面有些看不太懂，只能怪自己太菜了。&lt;a href=&quot;https://tech.meituan.com/java-memory-reordering.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>HashMap中的扩容</title>
    <link href="https://hsb786.github.io/2018/04/21/HashMap%E4%B8%AD%E7%9A%84%E6%89%A9%E5%AE%B9/"/>
    <id>https://hsb786.github.io/2018/04/21/HashMap中的扩容/</id>
    <published>2018-04-21T12:10:50.000Z</published>
    <updated>2018-04-25T07:17:39.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞<br><a id="more"></a><br>术语：</p><ul><li>高位运算：不太了解，网上也找不到解释。让高位参加运算?</li><li>取模运算：例如对于整数a，b来说，取模或者求余主要分为以下两步<ul><li><ol><li>求整数商: c=a/b     </li></ol></li><li><ol start="2"><li>计算模或者余数：r=a-c*b   </li></ol></li><li>取模运算是r向负无穷方向舍弃小数位</li><li>求余运算时r向正无穷方向舍弃小数位</li></ul></li></ul></blockquote><p><em>针对java8</em></p><h2 id="根据key获取哈希桶数组索引位置"><a href="#根据key获取哈希桶数组索引位置" class="headerlink" title="根据key获取哈希桶数组索引位置"></a>根据key获取哈希桶数组索引位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //1. h=key.hashCode()    取hashCode值</span><br><span class="line">    //2. h^(H&gt;&gt;&gt;16)     高位参与运算</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // 3. (n-1)&amp;hash    取模运算</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong></p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用取模运算来计算该对象应该保存在table数组的哪个索引处。</p><p>通过(table.length -1)&amp;h来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。<strong>当length总是2的n次方时，(length-1)&amp; h运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。<br><em>补充一下：为什么求得的hash值是32位的？这是因为int类型4字节，4X8=32</em></p><p><img src="/images/HashMap21.png" alt=""></p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p><strong>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="/images/HashMap22.png" alt=""></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/images/HashMap23.png" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/images/HashMap24.png" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。</p><p><code>final Node&lt;K,V&gt;[] resize()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        //// 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; // 链表优化重hash的代码块</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                         // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一点搞不懂，<code>if ((e.hash &amp; oldCap) == 0) {</code>这里为什么这么判断就能确定新增的1bit就是0呢😱😱😱。被二进制搞的头昏脑胀😖😞😟。<br>现在好像明白了，oldCap=01 0000，key1= 00 0101 , key2= 01 0101    key1&amp;oldCap=0，新增的1bit为0。应该是这样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>(n - 1) &amp; hash，当n是2次幂的时候，hash%n等于(n-1)&amp;hash，&amp;比%具有更高的效率</li><li>由于长度是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以前只知道HashMap会扩容为原来的两倍，但不知道为什么会是两倍。自从看了美团技术博客后才稍微懂了一点。二进制真是烦人😞😞😞&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
      <category term="集合" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Metaspace</title>
    <link href="https://hsb786.github.io/2018/04/21/Metaspace/"/>
    <id>https://hsb786.github.io/2018/04/21/Metaspace/</id>
    <published>2018-04-21T04:21:05.000Z</published>
    <updated>2018-04-21T07:35:08.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish</p></blockquote><p>Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap</p><blockquote><p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.<br>JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。<br><a id="more"></a></p></blockquote><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>避免了OutOfMemoryError的问题。类的元数据分配只受本地内存大小的限制。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><ul><li>-XX:MetaspaceSize 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li><li>-XX:MaxMetaspaceSize 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</li><li>-XX:MinMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li><li>-XX:MaxMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">深入探究JVM | 探秘 Metaspace </a></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p><p><a href="https://stackoverflow.com/questions/20563047/jdk-8-memory-layout-and-garbage-collection" target="_blank" rel="noopener">JDK 8 Memory Layout and garbage collection</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;现在java 10 都出来了，再看看自己，连java 8 都没搞定。Stay Hungry, Stay Foolish&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 8 彻底将永久代(PermGen)从HotSpot JVM移除。方法区移至Metaspace，字符串常量移至Java Heap&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.&lt;br&gt;JDK 8 开始把类的元数据存放到本地堆内存（native heap）中，这一块区域就叫Metaspace。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>jvm-GC</title>
    <link href="https://hsb786.github.io/2018/04/21/jvm-GC/"/>
    <id>https://hsb786.github.io/2018/04/21/jvm-GC/</id>
    <published>2018-04-21T03:10:31.000Z</published>
    <updated>2018-04-24T06:06:39.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字约定"><a href="#关键字约定" class="headerlink" title="关键字约定"></a>关键字约定</h2><ul><li>Young generation –&gt;新生代</li><li>Tenured / Old Generation –&gt;老年代</li><li>Perm Area –&gt;永久代</li></ul><p><img src="/images/JVM21.png" alt=""><br><a id="more"></a></p><h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><p>新生代是所有新对象产生的地方。当新生代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。新生代分为Enden、Survivor1、Survivor2。</p><ul><li>大多数新建的对象都位于Eden区。</li><li>当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。</li><li>Minor GC同样会检查存活下来的对象，如果需要会把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。</li><li>经过多次GC周期后，仍然存活下来的对象会被转移到老年代内存空间。通常这是在新生代有资格提升到老年代前通过设定年龄阈值(<em>默认15</em>)来完成的。</li></ul><h2 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h2><p>一些大对象(<em>长字符串或数组</em>)可能会直接存放到老年代。老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC。 Major GC会花费更多的时间。</p><h2 id="永久代（Perm-Area）"><a href="#永久代（Perm-Area）" class="headerlink" title="永久代（Perm Area）"></a>永久代（Perm Area）</h2><p>永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。</p><blockquote><p>java8中移除了永久代，取而代之的是Metaspace(元空间)</p></blockquote><h2 id="重要的东东"><a href="#重要的东东" class="headerlink" title="重要的东东"></a>重要的东东</h2><ul><li>在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。</li><li>GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。</li><li>GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。</li><li>在Java中，GC是由一个被称为垃圾回收器的守护线程执行的。</li><li>在从内存回收一个对象之前会调用对象的finalize()方法。</li><li>作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。</li><li>System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。</li><li>如果堆没有内存创建新的对象了，会抛出<code>OutOfMemoryError</code>。</li></ul><h2 id="GC针对什么对象？"><a href="#GC针对什么对象？" class="headerlink" title="GC针对什么对象？"></a>GC针对什么对象？</h2><p>了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(<em>比如：静态属性引用的常量</em>)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。</p><p><img src="/images/GC-Object.png" alt="GC回收对象"></p><h2 id="引用记数法"><a href="#引用记数法" class="headerlink" title="引用记数法"></a>引用记数法</h2><ul><li>思想：给对象设置引用计数器，每引用该对象一次，计数器就+1，引用失效时，计数器就-1，当任意时候引用计数器的值都为0时，则该对象可被回收</li><li>Java不适用原因：无法解决对象互相循环引用的问题</li></ul><h2 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h2><p>可达性分析法, 当一个对象通过一系列根对象(Root)都不可达时就会被回收。</p><p>可作为GC Root的对象有:</p><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（Native方法）引用的对象</li></ul><p>在可达性分析过程中，对象引用类型会对对象的生命周期产生影响，JAVA中有这几种类型的引用：</p><ul><li>强引用：只要该引用还有效，GC就不会回收</li><li>软引用：内存空间足够时不进行回收，在内存溢出发生前进行回收、用SoftReference类实现</li><li>弱引用：弱引用关联的对象只能存活到下一次Gc收集、用WeakReference类实现</li><li>虚引用：无法通过虚引用获得对象实例，也不会对对象的生存时间产生影响、唯一目的：当该对象被Gc收集时，收到一个系统通知。用PhantomReference类实现</li></ul><p>一个对象真正不可用，要经历两次标记过程：</p><ul><li>首先进行可达性分析，筛选出与GC Root没用引用链的对象，进行第一次标记</li><li>第一次标记后，再进行一次筛选，筛选条件是是否有必要执行finalize()方法。若对象有没有重写finalize()方法，或者finalize()是否已被jvm调用过，则没必要执行，GC会回收该对象</li><li>若有必要执行，则该对象会被放入F-Queue中，由jvm开启一个低优先级的线程去执行它（但不一定等待finalize执行完毕）。</li><li>finalize()是对象最后一次自救的机会，若对象在finalize()中重新加入到引用链中，则它会被移出要回收的对象的集合。其他对象则会被第二次标记，进行回收</li></ul><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><ol><li>标记清除算法<br> 分为标记和清除两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="/images/sweep.jpg" alt="标记清除"></li><li>复制算法<br> <strong>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中</strong>。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。<br><img src="/images/copy.jpg" alt="复制"></li><li><p>标记整理算法<br> <strong>标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都向一端移动，然后清理</strong>。优点是不会造成内存碎片。<br><img src="/images/compact.jpg" alt="标记整理"></p></li><li><p>分代收集算法</p></li></ol><ul><li>把堆分为新生代和老年代</li><li>新生代使用复制算法</li><li>将新生代内存分为一块大的Eden区和两块小的Survivor；每次使用Eden和一个Survivor，回收时将Eden和Survivor存活的对象复制到另一个Survivor（HotSpot的比例Eden：Survivor = 8：1）</li><li>老年代使用标记-清理或者标记-整理</li></ul><p><img src="/images/java虚拟机2.png" alt=""></p><h2 id="内存分配规则"><a href="#内存分配规则" class="headerlink" title="内存分配规则"></a>内存分配规则</h2><ul><li>对象优先在Eden分配<ul><li>当Eden区没有足够的空间时就会发起一次Minor GC</li></ul></li><li>大对象直接进入老年代<ul><li>典型的大对象是很长的字符串和数组</li></ul></li><li>长期存活的对象进入老年代<ul><li>每个对象有年龄计数器，每经过一次GC，计数器值加一，当到达一定程度时（默认15），就会进入老年代</li><li>年龄的阈值可通过参数 -XX:MaxTenuringThreshold设置</li></ul></li><li>对象年龄的判定<ul><li>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</li></ul></li><li>空间分配担保<ul><li>发生Minor GC前，jvm会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，若大于，则Minor GC是安全的</li><li>若不大于，jvm会查看HandlePromotionFailure是否允许担保失败，若不允许，则改为一次Full GC</li><li>若允许担保失败，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试进行Minor GC；若小于，则要改为Full GC</li></ul></li></ul><h2 id="Java中垃圾回收器的类型"><a href="#Java中垃圾回收器的类型" class="headerlink" title="Java中垃圾回收器的类型"></a>Java中垃圾回收器的类型</h2><p>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p><ul><li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li><li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li><li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li><li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li><li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li><li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li></ul><h2 id="与GC有关的JVM参数"><a href="#与GC有关的JVM参数" class="headerlink" title="与GC有关的JVM参数"></a>与GC有关的JVM参数</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>设置JVM启动时堆的初始化大小。</td></tr><tr><td>-Xmx</td><td>设置堆最大值。</td></tr><tr><td>-Xmn</td><td>设置新生代的空间大小，剩下的为老年代的空间大小。</td></tr><tr><td>-XX:SurvivorRatio</td><td>提供Eden区和survivor区的空间比例。比如，如果新生代的大小为10m并且VM开关是-XX:SurvivorRatio=2，那么将会保留5m内存给Eden区和每个Survivor区分配2.5m内存。默认比例是8。</td></tr><tr><td>-XX:NewRatio</td><td>提供老年代和新生代的比例大小。默认值是2。</td></tr><tr><td>-XX:MetaspaceSize</td><td>分配给类元数据空间的初始大小</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>分配给类元数据空间的最大值</td></tr><tr><td>-XX:MinMetaspaceFreeRatio</td><td>一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</td></tr><tr><td>-XX:MaxMetaspaceFreeRatio</td><td>一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</td></tr></tbody></table><h2 id="GC监控"><a href="#GC监控" class="headerlink" title="GC监控"></a>GC监控</h2><p>可以使用JDK自带的VisualVM进行监控</p><p><img src="/images/JVM22.png" alt="Java2D"></p><p><img src="/images/JVM23.png" alt="监视器"></p><p><img src="/images/JVM24.png" alt="线程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。java8开始永久代已移出</li><li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li><li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li><li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li><li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2016/05/13/jvm-GC/" target="_blank" rel="noopener">【译】Java中的垃圾回收机制 </a></p><p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">Java HotSpot VM Options</a></p><p><a href="http://www.importnew.com/14086.html" target="_blank" rel="noopener">Java内存与垃圾回收调优</a></p><p><a href="http://colobu.com/2015/04/14/Java-GC-memo/" target="_blank" rel="noopener">Java GC 中的一些概念</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关键字约定&quot;&gt;&lt;a href=&quot;#关键字约定&quot; class=&quot;headerlink&quot; title=&quot;关键字约定&quot;&gt;&lt;/a&gt;关键字约定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Young generation –&amp;gt;新生代&lt;/li&gt;
&lt;li&gt;Tenured / Old Generation –&amp;gt;老年代&lt;/li&gt;
&lt;li&gt;Perm Area –&amp;gt;永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/JVM21.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Unsafe</title>
    <link href="https://hsb786.github.io/2018/04/20/Unsafe/"/>
    <id>https://hsb786.github.io/2018/04/20/Unsafe/</id>
    <published>2018-04-20T10:48:25.000Z</published>
    <updated>2018-04-20T13:19:46.046Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作</p></blockquote><p>Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line"></span><br><span class="line">    private static native void registerNatives();</span><br><span class="line">    static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, &quot;getUnsafe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //饿汉式单例</span><br><span class="line">    private Unsafe() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line"></span><br><span class="line">    @CallerSensitive</span><br><span class="line">    public static Unsafe getUnsafe() &#123;</span><br><span class="line">        //获取调用该方法的调用者信息</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        //判断类加载器是否是系统类加载器</span><br><span class="line">        if (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">    .............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//VM.class</span><br><span class="line"> public static boolean isSystemDomainLoader(ClassLoader loader) &#123;</span><br><span class="line">        return loader == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Unsafe.getUnsafe()只能被boostrap classloader加载的类使用，所以可以利用java反射来获取Unsafe的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取Unsafe类中的theUnsafe字段</span><br><span class="line">Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">//由于theUnsafe被private修饰，所以要跳过安全检查</span><br><span class="line">f.setAccessible(true);</span><br><span class="line">//获取当前f的值，也就是Unsafe的实例</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(null);</span><br></pre></td></tr></table></figure><p><code>public native long objectFieldOffset(Field f)</code>和<code>public native long staticFieldOffset(Field f)</code>：用于返回类定义中某个属性在主内存中设定的偏移量。相当于CAS中的V。</p><p><code>public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);</code>：对属性进行比较并替换（CAS过程——Compare And Swap）。offect：V，expected：A，x：B </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//java8</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        //自旋，一直循环直到compareAndSwapInt执行成功</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int     getIntVolatile(Object o, long offset);</span><br></pre></td></tr></table></figure><p><code>getAndAddInt()</code>采用的是基于Unsafe的”乐观锁”进行实现的，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。适合并发量不高的情况。</p><hr><h2 id="CallerSensitive"><a href="#CallerSensitive" class="headerlink" title="@CallerSensitive"></a>@CallerSensitive</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//sun.reflect.CallerSensitive</span><br><span class="line">/**</span><br><span class="line"> * A method annotated @CallerSensitive is sensitive to its calling class,</span><br><span class="line"> * via &#123;@link sun.reflect.Reflection#getCallerClass Reflection.getCallerClass&#125;,</span><br><span class="line"> * or via some equivalent.</span><br><span class="line"> *</span><br><span class="line"> * @author John R. Rose</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;METHOD&#125;)</span><br><span class="line">public @interface CallerSensitive &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//sun.reflect.Reflection</span><br><span class="line">/** Returns the class of the caller of the method calling this method,</span><br><span class="line">    ignoring frames associated with java.lang.reflect.Method.invoke()</span><br><span class="line">    and its implementation. */</span><br><span class="line">@CallerSensitive</span><br><span class="line">public static native Class&lt;?&gt; getCallerClass();</span><br></pre></td></tr></table></figure><blockquote><p>用@CallerSensitive注解修饰的方法从一开始就知道具体调用它的对象，这样就不用再经过一系列的检查才能确定具体调用它的对象了。它实际上是调用sun.reflect.Reflection.getCallerClass方法。</p></blockquote><p>Reflection类位于调用栈中的0帧位置，sun.reflect.Reflection.getCallerClass()方法返回调用栈中从0帧开始的第x帧中的类实例。该方法提供的机制可用于确定调用者类，从而实现“感知调用者（Caller Sensitive）”的行为，即允许应用程序根据调用类或调用栈中的其它类来改变其自身的行为。</p><p><em>感觉不太懂，做个标记，以后再来看吧</em></p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/yinwenjie/article/details/72909981" target="_blank" rel="noopener">线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） </a></p><p><a href="https://juejin.im/post/5921927c44d904006cca9720" target="_blank" rel="noopener">跟我一起剖析 Java 并发源码之 Unsafe</a></p><p><a href="https://blog.csdn.net/aguda_king/article/details/72355807" target="_blank" rel="noopener">JDK8的@CallerSensitive</a></p><p><a href="https://blog.csdn.net/HEL_WOR/article/details/50199797" target="_blank" rel="noopener">JVM注解@CallSensitive</a></p><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-2/" target="_blank" rel="noopener">深入解析Java反射（2） - invoke方法 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;sun.misc.Unsafe类提供的原子操作是基于操作系统直接对CPU进行操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unsafe类包装了很多低级别的非安全性操作，可以直接操作任意的内存。虽然该类的大部分方法都是public的，但是它只能被受信任的代码使用（jdk中的代码）&lt;br&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础2</title>
    <link href="https://hsb786.github.io/2018/04/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%802/"/>
    <id>https://hsb786.github.io/2018/04/20/多线程基础2/</id>
    <published>2018-04-20T05:28:33.000Z</published>
    <updated>2018-04-24T06:20:42.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。</p></blockquote><a id="more"></a><p>根据操作系统的不同（Windows/Unix/Linux/其他），他们所支持的线程底层实现和操作效果也是不尽相同的。不过一个操作系统支持的线程至少会有四种状态：就绪、运行、阻塞和终止。<strong>线程在四种状态下进行切换，都是要消耗不少的CPU计算能力的。</strong></p><p>根据操作系统使用线程的进程的不一样，线程还分为用户线程和操作系统线程。操作系统线程（内核线程），是指操作系统内核为了完成硬件接口层操作，<strong>由操作系统内核创建的线程</strong>：例如I/O操作的内核线程，这些线程应用程序是不能干预的；用户线程，是指用户安装/管理的应用程序，为执行某一种操作，而<strong>由这个应用程序创建的线程</strong>。</p><p><img src="/images/Thread01.jpg" alt=""></p><p>黄色钥匙代表对象锁</p><h2 id="thread-interrupt-，Thread-interrupted-，thread-isInterrupted"><a href="#thread-interrupt-，Thread-interrupted-，thread-isInterrupted" class="headerlink" title="thread.interrupt()，Thread.interrupted()，thread.isInterrupted()"></a>thread.interrupt()，Thread.interrupted()，thread.isInterrupted()</h2><p><img src="/images/Thread02.png" alt=""></p><p><img src="/images/Thread03.png" alt=""></p><p>当Thread收到interrupt信号是，可能的两种结果:</p><ol><li>线程处于运行状态时，线程对象的isInterrupt属性被置为true</li><li>处于阻塞状态是，抛出InterruptedException异常，其isInterrupt不会被置为true。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Tests whether the current thread has been interrupted.  The</span><br><span class="line">     * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span><br><span class="line">     * other words, if this method were to be called twice in succession, the</span><br><span class="line">     * second call would return false (unless the current thread were</span><br><span class="line">     * interrupted again, after the first call had cleared its interrupted</span><br><span class="line">     * status and before the second call had examined it).</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see #isInterrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><br><span class="line">     * status&lt;/i&gt; of the thread is unaffected by this method.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see     #interrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line">     * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line">     * passed.</span><br><span class="line">     */</span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure><p>可以看出interrupted和isInterrupted区别在于传给ClearInterrupted的参数是true还是false。</p><p><strong>ClearInterrupted参数向操作系统指明是否在获取状态后将当前线程的interrupted状态重置为false。</strong></p><p>这就意味着当某个线程的isInterrupt属性成功被置为true后，如果您使用对象方法thread.isInterrupted()获取值，无论您获取多少次得到的返回值都是true；但是如果您使用静态方法Thread.interrupted()获取值，那么只有第一次获取的结果是true，随后线程的isInterrupt属性将被恢复成false，后续无论使用Thread.interrupted()调用还是使用thread.isInterrupted()调用，获取的结果都是false。</p><p>wait和sleep都是让<strong>当前线程</strong>进入阻塞状态，yield是让主线程等待调用yield的线程执行完。</p><p>sleep和yield都是public static native void方法</p><hr><p>Java语言为我们提供了两种基础线程池的选择：ScheduledThreadPoolExecutor和ThreadPoolExecutor。它们都实现了ExecutorService接口（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）。</p><h2 id="JAVA主要线程池的继承结构"><a href="#JAVA主要线程池的继承结构" class="headerlink" title="JAVA主要线程池的继承结构"></a>JAVA主要线程池的继承结构</h2><p><img src="/images/Thread04.png" alt=""></p><ul><li>ThreadPoolExecutor：对于任务的执行是立即的、一次性的。</li><li>ScheduledThreadPoolExecutor：一个用来执行延迟任务、定时任务或者周期性任务的线程池。一般情况下，我们用它可以处理定时计算、周期性统计一类的任务。</li><li>ForkJoinPool：ScheduledThreadPoolExecutor和ThreadPoolExecutor都是在JDK1.5版本中提供的。在JDK1.7中，JAVA为我们提供了一种新的线程池ForkJoinPool以及配套的任务定义ForkJoinTask。除了可以执行实现了Runnable接口或者Callable接口的任务以外，ForkJoinPool还可以执行集成了ForkJoinTask定义的任务。ForkJoinPool的执行原理和ThreadPoolExecutor的执行原理是不一样的</li></ul><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在ThreadPoolExecutor线程池中，创建线程的工作交给ThreadFactory来完成。要使用线程池，就必须要指定ThreadFactory。</p><p>如果我们使用的构造函数时并没有指定使用的ThreadFactory，这个时候ThreadPoolExecutor会使用一个默认的ThreadFactory：DefaultThreadFactory。（这个类在Executors工具类中）</p><p><strong>Executors工具类和ThreadPoolExecutor类存在循环依赖：ThreadPoolExecutor中使用了Executors工具类中定义的DefaultThreadFactory；而在Executors工具类中却又在创建ThreadPoolExecutor的对象实例。</strong></p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/column/details/yinwenjiethread.html" target="_blank" rel="noopener">多线程基础</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://hsb786.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://hsb786.github.io/2018/04/19/CAS/"/>
    <id>https://hsb786.github.io/2018/04/19/CAS/</id>
    <published>2018-04-19T09:41:51.000Z</published>
    <updated>2018-04-24T06:25:08.055Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CAS（Compare And Swap），翻译过来就是比较和替换。</strong></p><p><strong>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</strong></p><p><strong>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。</strong></p><a id="more"></a><p>举个栗子🎂</p><ol><li>在内存地址V当中，存储着值为10的变量。</li></ol><p><img src="/images/CAS01.png" alt=""></p><ol start="2"><li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</li></ol><p><img src="/images/CAS02.png" alt=""></p><ol start="3"><li>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11</li></ol><p><img src="/images/CAS03.png" alt=""></p><ol start="4"><li>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</li></ol><p><img src="/images/CAS04.png" alt=""></p><ol start="5"><li>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</li></ol><p><img src="/images/CAS05.png" alt=""></p><ol start="6"><li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</li></ol><p><img src="/images/CAS06.png" alt=""></p><ol start="7"><li>线程1进行SWAP，把地址V的值替换为B，也就是12。</li></ol><p><img src="/images/CAS07.png" alt=""></p><hr><h2 id="synchronized与CAS"><a href="#synchronized与CAS" class="headerlink" title="synchronized与CAS"></a>synchronized与CAS</h2><p><strong>synchronized关键字会让没有得到线程锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的切换，代价比较高。</strong></p><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>指的是<code>java.util.concurrent.atomic</code>包下，一系列以Atomic开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int value;</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unsafe</strong>：Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。<strong>unsafe为我们提供了硬件级别的原子操作。</strong></p><p><strong>valueOffset</strong>：至于valueOffset对象，是通过unsafe.objectFieldOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单地把valueOffset理解为value变量的内存地址。</p><p>getAndIncrement 相当于i++，先返回值再加1</p><p>在java7中是这样实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getAndIncrement方法内部会不停的循环，直到unsafe.comparAndSwapInt方法执行成功。<br>valueOffset相当于前面讲的V，expect：旧的预期值A，update：新的预期值B</p><hr><p>java8中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这时需要查看Unsafe的源码，可以下载openjdk，openjdk中有关于<code>sun.misc</code>包中的源码</em>。需要注意的是，由于版本不一致，导致跟代码的时候会不准确。而且我发现同样是java8，代码还有些不一样，可能是java8的版本不一致导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int     getIntVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                  int expected,</span><br><span class="line">                                                  int x);</span><br></pre></td></tr></table></figure><p>感觉跟jdk7差不多，只是把自旋部分的代码从AtomicInteger移动到了Unsafe中。</p><p>Java语言CAS底层就是利用unsafe提供的原子性操作方法来实现的。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>1. CPU开销较大</strong></p><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p><strong>2. 不能保证代码块的原子性</strong></p><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p><p><strong>3. ABA问题</strong></p><p>当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。利用版本号比较可以有效解决ABA问题。</p><hr><p><em>参考</em></p><blockquote><p><a href="http://mp.weixin.qq.com/s/f9PYMnpAgS1gAQYPDuCq-w" target="_blank" rel="noopener">漫画：什么是CAS机制？</a></p><p><a href="http://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg" target="_blank" rel="noopener">漫画：什么是CAS机制？（进阶篇）</a></p><p><a href="https://blog.csdn.net/yinwenjie/article/details/72909981" target="_blank" rel="noopener">线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CAS（Compare And Swap），翻译过来就是比较和替换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="爪哇" scheme="https://hsb786.github.io/categories/%E7%88%AA%E5%93%87/"/>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>RESTful</title>
    <link href="https://hsb786.github.io/2018/04/18/RESTful/"/>
    <id>https://hsb786.github.io/2018/04/18/RESTful/</id>
    <published>2018-04-18T05:37:06.000Z</published>
    <updated>2018-04-24T06:26:40.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他在论文中提到：</p><blockquote><p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”<br><a id="more"></a></p></blockquote><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer（表现层状态转化）的缩写。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><h2 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息</strong>。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）</strong>。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="HTTP协议，是一个无状态协议，无状态是什么意思"><a href="#HTTP协议，是一个无状态协议，无状态是什么意思" class="headerlink" title="HTTP协议，是一个无状态协议，无状态是什么意思"></a>HTTP协议，是一个无状态协议，无状态是什么意思</h3><h4 id="回答1"><a href="#回答1" class="headerlink" title="回答1"></a>回答1</h4><p>有状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：还不错，挺好吃的。  </p><p>无状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：？？？啊？啥？啥味道怎么样？</p><p>所以需要cookie这种东西：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：你今天中午吃的大盘鸡味道怎么样呀？<br>B：还不错，挺好吃的。</p><h4 id="回答2"><a href="#回答2" class="headerlink" title="回答2"></a>回答2</h4><ul><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见</li></ul><p>【状态】的含义就是：客户端和服务器在某次会话中产生的数据，从而【无状态】就意味着，这些数据不会被保留</p><p>但是：</p><ul><li>通过增加cookie和session机制，现在的网络请求其实是有状态的</li><li>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p><strong>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</strong></p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>例子</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p><p><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP是一个无状态的协议。这句话里的无状态是什么意思？</a></p><p><a href="http://www.cnblogs.com/bellkosmos/p/5237146.html" target="_blank" rel="noopener">http协议无状态中的 “状态” 到底指的是什么？！</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api" target="_blank" rel="noopener">RESTful API 设计指南</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。&lt;/p&gt;
&lt;p&gt;他在论文中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://hsb786.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="https://hsb786.github.io/2018/04/18/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/18/基本排序算法/</id>
    <published>2018-04-18T04:27:50.000Z</published>
    <updated>2018-04-20T13:21:43.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：<strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void quickSort(int[] array) &#123;</span><br><span class="line">    quickSort(array, 0, array.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = partion(array, left, right);</span><br><span class="line">    quickSort(array, left, mid - 1);</span><br><span class="line">    quickSort(array, mid + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int partion(int[] array, int left, int right) &#123;</span><br><span class="line">    // 取第一个数为基准元素</span><br><span class="line">    int tmp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; array[right] &gt;= tmp) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素小的移动到低端</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= tmp) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素大的移动到高端</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入基准元素</span><br><span class="line">    array[left] = tmp;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：<strong>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列</strong></p><p><img src="/images/sort-merge.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void mergeSort(int[] arr) &#123;</span><br><span class="line">int[] temp = new int[arr.length];</span><br><span class="line">mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序</span><br><span class="line">mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序</span><br><span class="line">merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">int i = left;// 左序列指针</span><br><span class="line">int j = mid + 1;// 右序列指针</span><br><span class="line">int t = 0;// 临时数组指针</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">if (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (i &lt;= mid) &#123;// 将左边剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;= right) &#123;// 将右序列剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">t = 0;</span><br><span class="line">// 将temp中的元素全部拷贝到原数组中</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">arr[left++] = temp[t++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;基本思想：&lt;strong&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hsb786.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/代理模式/</id>
    <published>2018-04-17T10:21:28.000Z</published>
    <updated>2018-04-20T13:20:26.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为其他对象提供一种代理以控制对这个对象的访问<br><a id="more"></a><br><img src="/images/design-pattern-proxy.png" alt=""></p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>代理对象可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能，符合开闭原则</p></li><li><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p></li></ul><h2 id="代理类分类"><a href="#代理类分类" class="headerlink" title="代理类分类"></a>代理类分类</h2><ul><li><p>静态代理:静态定义代理类，我们自己静态定义的代理类。</p></li><li><p>动态代理:通过程序动态生成代理类，该代理类不是我们自己定义的，而是由程序自动生成，常用的动态代理技术有JDK自带的动态代理和CGLIB动态代理。</p></li></ul><hr><p>*参考</p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/30/代理模式/" target="_blank" rel="noopener">代理模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/策略模式/</id>
    <published>2018-04-17T10:07:27.000Z</published>
    <updated>2018-04-20T13:20:07.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p></blockquote><p>根据条件的不同选择不同的策略<br><a id="more"></a></p><p><img src="/images/design-pattern-strategy01.png" alt=""></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用享元模式在一定程度上减少对象的数量。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1691" target="_blank" rel="noopener">设计模式（十二）——策略模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据条件的不同选择不同的策略&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="https://hsb786.github.io/2018/04/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://hsb786.github.io/2018/04/17/抽象工厂/</id>
    <published>2018-04-17T09:17:08.000Z</published>
    <updated>2018-04-20T13:20:15.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。<br><a id="more"></a><br><img src="/images/design-pattern-factory02.png" alt=""></p><hr><h2 id="产品等级结构和产品族"><a href="#产品等级结构和产品族" class="headerlink" title="产品等级结构和产品族"></a>产品等级结构和产品族</h2><p>产品等级结构： <strong>产品等级结构即产品的继承结构，同一类产品</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p>产品族：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，同一个品牌产品</strong>，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><h2 id="抽象工厂与工厂方法"><a href="#抽象工厂与工厂方法" class="headerlink" title="抽象工厂与工厂方法"></a>抽象工厂与工厂方法</h2><p>抽象工厂和工厂方法最大的区别在于，工厂方法针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p><p>工厂方法：用来生产同一等级结构中的固定产品（支持增加任意产品，新增产品是不需要更改已有的工程，需要增加该产品对应的工程。符合单一职责原则、符合开闭原则。但是引入了复杂性）</p><p>抽象工厂：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开闭原则，降低了复杂性）</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>每次可以通过具体工厂类创建一个产品族的多个对象，增加新的具体工厂和产品族很方便。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/13/工厂模式-下/" target="_blank" rel="noopener">工厂模式-下</a></p><p><a href="http://www.hollischuang.com/archives/1430" target="_blank" rel="noopener">设计模式（八）——工厂模式总结</a><br><a href="http://www.hollischuang.com/archives/1420" target="_blank" rel="noopener">设计模式（七）——抽象工厂模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://hsb786.github.io/2018/04/17/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/17/工厂方法/</id>
    <published>2018-04-17T09:05:30.000Z</published>
    <updated>2018-04-20T13:21:25.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义了一个用于创建对象的接口，让子类决定实例化哪一个类。</p></blockquote><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br><a id="more"></a><br><img src="/images/design-pattern-factory01.png" alt=""></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/08/工厂模式/" target="_blank" rel="noopener">工厂模式(上)</a></p><p><a href="http://www.cnblogs.com/xiaoxi/p/7641358.html" target="_blank" rel="noopener">设计模式：工厂方法模式</a></p><p><a href="http://www.hollischuang.com/archives/1401" target="_blank" rel="noopener">设计模式（五）——工厂方法模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义了一个用于创建对象的接口，让子类决定实例化哪一个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hsb786.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://hsb786.github.io/2018/04/16/ClassLoader/"/>
    <id>https://hsb786.github.io/2018/04/16/ClassLoader/</id>
    <published>2018-04-16T12:21:34.000Z</published>
    <updated>2018-04-24T06:31:55.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。</p></blockquote><a id="more"></a><pre><code>public abstract class ClassLoader</code></pre><blockquote><p>class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // First, check if the class has already been loaded</span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // ClassNotFoundException thrown if class not found</span><br><span class="line">                   // from the non-null parent class loader</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;</span><br><span class="line">                   // If still not found, then invoke findClass in order</span><br><span class="line">                   // to find the class.</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   // this is the defining class loader; record the stats</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用指定的二进制名称来加载类，这个方法的默认实现按照以下顺序查找类： 调用findLoadedClass(String)方法检查这个类是否被加载过 使用父加载器调用loadClass(String)方法，如果父加载器为Null，类加载器装载虚拟机内置的加载器调用findClass(String)方法装载类， 如果，按照以上的步骤成功的找到对应的类，并且该方法接收的resolve参数的值为true,那么就调用resolveClass(Class)方法来处理类。</p></blockquote><hr><p>java中的类大致分为三种:</p><ol><li>系统类</li><li>扩展类</li><li>由程序员自定义的类</li></ol><p>类装载方式，有两种：</p><ol><li>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。</li><li>显式装载， 通过class.forName()等方法，显式加载需要的类</li></ol><p>类加载的动态性体现：</p><blockquote><p>一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现</p></blockquote><h2 id="java类装载器"><a href="#java类装载器" class="headerlink" title="java类装载器"></a>java类装载器</h2><p>Java中的类装载器实质上也是类，功能是把类载入jvm中，jvm的类装载器有三个，层次结构如下：</p><p><img src="/images/ClassLoader01.png" alt=""></p><h2 id="类加载器之间是如何协调工作的"><a href="#类加载器之间是如何协调工作的" class="headerlink" title="类加载器之间是如何协调工作的"></a>类加载器之间是如何协调工作的</h2><p>java是如何区分一个类该由哪个类加载器来完成呢。 在这里java采用了委托模型机制，这个机制简单来讲，就是“<strong>类装载器有载入类的需求时，会先请示其Parent使用其搜索路径帮忙载入，如果Parent 找不到,那么才由自己依照自己的搜索路径搜索类</strong>”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Public class Test&#123;</span><br><span class="line">    Public static void main(String[] arg)&#123;</span><br><span class="line">        ClassLoader c  = Test.class.getClassLoader();  //获取Test类的类加载器</span><br><span class="line">        System.out.println(c); </span><br><span class="line">        ClassLoader c1 = c.getParent();  //获取c这个类加载器的父类加载器</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        ClassLoader c2 = c1.getParent();//获取c1这个类加载器的父类加载器</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output</span><br><span class="line">AppClassLoader</span><br><span class="line">ExtClassLoader</span><br><span class="line">Null</span><br></pre></td></tr></table></figure><p>可以看出Test是由<strong>AppClassLoader</strong>加载器加载的，<strong>AppClassLoader</strong>的<code>Parent</code> 加载器是 <strong>ExtClassLoader</strong>,但是<strong>ExtClassLoader</strong>的<code>Parent</code>为 <code>null</code> 是怎么回事。<strong>Bootstrap Loader</strong>是用C++语言写的，依java的观点来看，逻辑上并不存在<strong>Bootstrap Loader</strong>的类实体，所以在java程序代码里试图打印出其内容时，我们就会看到输出为<code>null</code>。</p><p>java类加载器基于三个机制：委托，可见，单一。</p><ul><li>委托机制：指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载他。</li><li>可见性机制：指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。</li><li>单一性机制：指的是一个类只能被同一种加载器加载一次。</li></ul><hr><h2 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h2><p>类装载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤：</p><ul><li>装载：查找和导入Class文件</li><li>链接：<ul><li>验证：检查载入的class文件数据的正确性</li><li>准备： 给类的静态变量分配存储空间</li><li>解析： 将符号引用转成直接引用</li></ul></li><li>初始化：对静态变量，静态代码块执行初始化工作</li></ul><p>类装载工作由<code>ClassLoder</code>和其子类负责。JVM在运行时会产生三个ClassLoader：<strong>根装载器</strong>，<code>ExtClassLoader</code>(<strong>扩展类装载器</strong>)和<code>AppClassLoader</code>，其中根装载器不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库，如JRE目录下的rt.jar,charsets.jar等。<code>ExtClassLoader</code>是<code>ClassLoder</code>的子类，负责装载JRE扩展目录ext下的jar类包；<code>AppClassLoader</code><strong>负责装载classpath路径下的类包，这三个类装载器存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下使用AppClassLoader装载应用程序的类</strong></p><p>Java装载类使用“<strong>全盘负责委托机制</strong>”。“<strong>全盘负责</strong>”是指当一个<code>ClassLoder</code>装载一个类时，除非显示的使用另外一个<code>ClassLoder</code>，该类所依赖及引用的类也由这个<code>ClassLoder载入</code>；“<strong>委托机制</strong>”是指先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全方面考虑的，试想如果一个人写了一个恶意的基础类（如<code>java.lang.String</code>）并加载到<code>JVM</code>将会引起严重的后果，但有了全盘负责制，<code>java.lang.String</code>永远是由根装载器来装载，避免以上情况发生 除了JVM默认的三个<code>ClassLoder</code>以外，第三方可以编写自己的类装载器，以实现一些特殊的需求。类文件被装载解析后，在<code>JVM</code>中都有一个对应的<code>java.lang.Class</code>对象，提供了类结构信息的描述。数组，枚举及基本数据类型，甚至<code>void</code>都拥有对应的<code>Class</code>对象。</p><hr><p>装载过程有两个比较重要的特征：<strong>层次组织结构</strong>和<strong>代理模式</strong>。<strong>层次组织结构</strong>指的是每个类加载器都有一个父类加载器，通过getParent()方法可以获取到。类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。<strong>代理模式</strong>则指的是一个类加载器既可以自己完成Java类的定义工作，也可以代理给其它的类加载器来完成。由于代理模式的存在，启动一个类的加载过程的类加载器和最终定义这个类的类加载器可能并不是一个。ClassLoader的加载类过程主要使用loadClass方法，该方法中封装了中加载机制：<strong>双亲委派模式</strong>。</p><blockquote><p>一般来说，父类优先的策略就足够好了。在某些情况下，可能需要采取相反的策略，即先尝试自己加载，找不到的时候再代理给父类加载器。这种做法在Java的Web容器中比较常见，也是<code>Servlet</code>规范推荐的做法。比如，<code>Apache Tomcat</code>为每个<code>Web</code>应用都提供一个独立的类加载器，使用的就是自己优先加载的策略。</p><p>类加载器的一个重要用途是在<code>JVM</code>中为相同名称的Java类创建隔离空间。在<code>JVM</code>中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加载器。只有两者完全一样，才认为两个类的是相同的。因此，即便是同样的<code>Java</code>字节代码，被两个不同的类加载器定义之后，所得到的<code>Java</code>类也是不同的。如果试图在两个类的对象之间进行赋值操作，会抛出<code>java.lang.ClassCastException</code>。这个特性为同样名称的<code>Java</code>类在<code>JVM</code>中共存创造了条件。在实际的应用中，可能会要求同一名称的<code>Java</code>类的不同版本在<code>JVM</code>中可以同时存在。通过类加载器就可以满足这种需求。</p></blockquote><h2 id="Java类的链接"><a href="#Java类的链接" class="headerlink" title="Java类的链接"></a>Java类的链接</h2><p>Java类的链接指的是将Java类的二进制代码合并到JVM的运行状态之中的过程。在链接之前，这个类必须被成功加载。<br>链接的过程比加载过程要复杂很多，这是实现java的动态性的重要一步！分为三部分：<code>verification</code> （验证）， <code>preparation</code>（准备） 和 <code>resolution</code>（解析）</p><p><strong>1. verification（验证）：</strong><br>验证是用来确保Java类的二进制表示在结构上是完全正确的。要验证比如class文件格式规范、这个类是否继承了final类、不能把一个父类对象赋值给子类数据类型等等。如果验证过程出现错误的话，会抛出java.lang.VerifyError错误。</p><p><strong>2.preparation（准备）：</strong></p><p>准备阶段为方法区中的静态变量分配内存空间。并将其赋值为初始值，所有原始类型的值都为0。如float为0f、 int为0、boolean为0、引用类型为null。</p><p><strong>3.resolution（解析）：</strong></p><p>解析的过程就是确保这些被引用的类能被正确的找到。解析的过程可能会导致其它的Java类被加载。</p><p>为类、接口、方法、成员变量的符号引用定位直接引用。</p><p>符号引用是一个字符串，它唯一标识一个类、一个字段、一个方法等目标。</p><p>而直接引用对于类变量、类方法指的是指向方法区的指针，然后对于实例方法、实例对象来说就是偏移量，比如一个实例方法，子类中方法表中的偏移量和父类是一致的，这个偏移量可以确定某个方法的位置。</p><h2 id="Java类的初始化"><a href="#Java类的初始化" class="headerlink" title="Java类的初始化"></a>Java类的初始化</h2><p>类的初始化是延迟的，直到类第一次被主动使用(active use)，JVM 才会初始化类。<br>当一个Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。初始化过程的主要操作是执行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的顺序依次执行静态代码块和初始化静态域。</p><p>初始化过程会被触发的条件汇总：</p><ol><li>使用new关键字实例化对象、访问一个类的静态字段、静态方法的时候。</li><li>对类进行反射调用的时候。</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则进行父类的初始化。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/199" target="_blank" rel="noopener">深度分析Java的ClassLoader机制（源码级别）</a></p><p><a href="http://www.hollischuang.com/archives/201" target="_blank" rel="noopener">Java类的加载、链接和初始化</a></p><p><a href="http://brianway.github.io/2016/02/03/javase-learn-note-3-ClassLoader/" target="_blank" rel="noopener">java基础巩固笔记(3)-类加载器</a></p><p><a href="https://blog.csdn.net/seu_calvin/article/details/52301541" target="_blank" rel="noopener">JVM——Java类加载机制总结 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://hsb786.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP</title>
    <link href="https://hsb786.github.io/2018/04/16/TCP-IP/"/>
    <id>https://hsb786.github.io/2018/04/16/TCP-IP/</id>
    <published>2018-04-16T10:43:52.000Z</published>
    <updated>2018-04-25T06:57:56.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？</p><p>还能怎么办，学啊。</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>百度百科上的解释</p><blockquote><p>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。<br><a id="more"></a></p></blockquote><p>TCP/IP协议族就采用了分层的思想，自上而下分成了四层： 应用层，传输层，网络层，链路层，每一层的协议只约定了特定的功能，HTTP就位于应用层。利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。一次HTTP请求的典型过程如下图所示</p><p><img src="/images/HTTP01.jpg" alt=""></p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><blockquote><p>URI是Uniform Resource Identifier的缩写，是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。</p></blockquote><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://</span><br><span class="line">ftp://</span><br></pre></td></tr></table></figure></p><p>我们比较熟悉的URL（<code>Uniform Resource Locator</code>，统一资源定位符）表示资源在互联网上的地址，它其实是URI的一个子集，因为URI仅仅表示「标识」， 标识的类型有很多，比如ISBN号码，电话号码，邮箱，网页链接地址等，而URL则把概念缩小到了「地址」。 由于URI在绝大多数场景下都是以URL的形式存在，大家一般都说URL居多，这也没什么问题，但是在心里要清楚URI和URL还是有所区别的。</p><h2 id="HTTP协议内容"><a href="#HTTP协议内容" class="headerlink" title="HTTP协议内容"></a>HTTP协议内容</h2><p>接下来的内容基于HTTP 1.1版本。</p><h3 id="请求-amp-响应报文结构"><a href="#请求-amp-响应报文结构" class="headerlink" title="请求 &amp; 响应报文结构"></a>请求 &amp; 响应报文结构</h3><blockquote><p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出， 最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p></blockquote><p><img src="/images/HTTP02.jpg" alt=""></p><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 如下是一个HTTP请求和响应报文的实例</p><p><img src="/images/HTTP03.jpg" alt=""></p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><blockquote><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 数字中的第一位指定了响应类别，后两位无分类。</p></blockquote><p>状态码主要类型一览：</p><p><img src="/images/HTTP04.jpg" alt=""></p><h3 id="首部-amp-实体"><a href="#首部-amp-实体" class="headerlink" title="首部 &amp; 实体"></a>首部 &amp; 实体</h3><blockquote><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p></blockquote><p>HTTP首部字段由首部字段名和字段值构成的，中间用冒号“:”分隔。比如：<code>Content-Type: text/html</code>。 HTTP实体是HTTP请求和响应传输的主体内容，根据场景不同可能是表单参数，HTML文本，JSON文本，二进制流等。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>HTTP是一种不保存状态，即无状态（stateless）协议。<strong>HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。<strong>协议本身并不保留之前一切的请求或响应报文的信息</strong>。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。</p></blockquote><blockquote><p><strong>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息</strong>。</p></blockquote><p><img src="/images/HTTP05.png" alt=""></p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p><strong>GET和POST最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</strong></p><p>W3school的解答</p><table><thead><tr><th>方法</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><p>这个对比只是给出了一些现象上的区别</p><hr><p>GET和POST是什么？<strong>HTTP协议中的两种发送请求的方法。</strong></p><p>HTTP是什么？<strong>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议</strong></p><p><strong>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的</strong>。 </p><p><strong>如果你用GET服务，在request body中存了数据，不同服务器的处理方式是不同的，有些服务器会读出数据，有些服务器直接忽略。所以，虽然GET可以带request body，但不能保证一定能被接受到</strong>。</p><h2 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h2><blockquote><p>征求意见稿（英语：Request For Comments，缩写为RFC），是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件，以编号排定。目前RFC文件是由互联网协会（ISOC）赞助发行。</p></blockquote><p>简单理解RFC就是互联网的规范，我们通常所说的「协议」就是以RFC的形式存在，而现行的HTTP/1.1规范的RFC有如下几个： RFC7230， RFC7231， RFC7232， RFC7233， RFC7234， RFC7235。 其中RFC7231里的Section 4. Request Methods涉及到了几个HTTP方法，接下来仔细阅读这一章节。</p><blockquote><p>The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.</p></blockquote><p>semantic[语义]，语法与语义的区别：</p><blockquote><p>一种语言是合法句子的集合。什么样的句子是合法的呢？可以从两方面来判断：语法和语义。语法是和文法结构有关，然而语义是和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。</p></blockquote><p>对于HTTP请求来说，语法是指请求响应的格式，比如请求第一行必须是 方法名 URI 协议/版本 这样的格式。</p><p>语义则定义了这一类型的请求具有什么样的性质。比如GET的语义就是「获取资源」，POST的语义是「处理资源」，那么在具体实现这两个方法时，就必须考虑其语义，做出符合其语义的行为。</p><p><strong>当然在符合语法的前提下实现违背语义的行为也是可以做到的，比如使用GET方法修改用户信息，POST获取资源列表，这样就只能说这个请求是「合法」的，但不是「符合语义」的</strong>。 </p><p>RFC7231里紧接着定义了HTTP方法的几个特性：</p><blockquote><p>Safe - 安全<br>这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此RFC定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。<br>但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用GET修改用户信息的情况。<br>引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。</p><p>Idempotent - 幂等<br>幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。<br>引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。</p><p>Cacheable - 可缓存性<br>顾名思义就是一个方法是否可以被缓存，此RFC里GET，HEAD和某些情况下的POST都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持GET和HEAD。</p></blockquote><p><strong>在这三个特性里一直在强调同一个事情，那就是协议不等于实现：协议规定安全在实现里不一定安全，协议规定幂等在实现里不一定幂等，协议规定可缓存在实现里不一定可缓存。</strong></p><h3 id="语义之争"><a href="#语义之争" class="headerlink" title="语义之争"></a>语义之争</h3><p>GET的语义是请求获取指定的资源。<strong>GET方法是安全、幂等、可缓存的</strong>（除非有 Cache-Control Header的约束）,GET方法的报文主体没有任何语义。</p><p>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。<strong>POST不安全，不幂等，（大部分实现）不可缓存</strong>。</p><hr><h2 id="TCP为什么是三次握手"><a href="#TCP为什么是三次握手" class="headerlink" title="TCP为什么是三次握手"></a>TCP为什么是三次握手</h2><p><img src="/images/三次握手.png" alt=""></p><p>TCP作为一种可靠传输控制协议,其核心思想:<strong>既要保证数据可靠传输,又要提高传输的效率</strong></p><p><strong>三次是保证双方互相明确对方能收能发的最低值</strong></p><hr><p><em>参考</em></p><blockquote><p><a href="https://baike.baidu.com/item/TCP%2FIP协议/212915?fr=aladdin&amp;fromid=214077&amp;fromtitle=tcp%2Fip" target="_blank" rel="noopener">TCP/IP协议 百度百科</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别 </a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/01/26/图解HTTP-读书笔记/" target="_blank" rel="noopener">图解HTTP-读书笔记</a></p><p><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a></p><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？&lt;/p&gt;
&lt;p&gt;还能怎么办，学啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;百度百科上的解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://hsb786.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
</feed>
