<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuShengBin’s blog</title>
  
  <subtitle>码渣的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hsb786.github.io/"/>
  <updated>2018-04-20T07:03:00.792Z</updated>
  <id>https://hsb786.github.io/</id>
  
  <author>
    <name>HuShengBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程基础2</title>
    <link href="https://hsb786.github.io/2018/04/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%802/"/>
    <id>https://hsb786.github.io/2018/04/20/多线程基础2/</id>
    <published>2018-04-20T05:28:33.000Z</published>
    <updated>2018-04-20T07:03:00.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。</p></blockquote><a id="more"></a><p>根据操作系统的不同（Windows/Unix/Linux/其他），他们所支持的线程底层实现和操作效果也是不尽相同的。不过一个操作系统支持的线程至少会有四种状态：就绪、执行、阻塞和终结。<strong>线程在四种状态下进行切换，都是要消耗不少的CPU计算能力的。</strong></p><p>根据操作系统使用线程的进程的不一样，线程还分为用户线程和操作系统线程。操作系统线程（内核线程），是指操作系统内核为了完成硬件接口层操作，<strong>由操作系统内核创建的线程</strong>：例如I/O操作的内核线程，这些线程应用程序是不能干预的；用户线程，是指用户安装/管理的应用程序，为执行某一种操作，而<strong>由这个应用程序创建的线程</strong>。</p><p><img src="/images/Thread01.jpg" alt=""></p><p>黄色钥匙代表对象锁</p><h2 id="Thread-interrupted-与thread-isInterrupted"><a href="#Thread-interrupted-与thread-isInterrupted" class="headerlink" title="Thread.interrupted()与thread.isInterrupted()"></a>Thread.interrupted()与thread.isInterrupted()</h2><p><img src="/images/Thread02.png" alt=""></p><p><img src="/images/Thread03.png" alt=""></p><p>当Thread收到interrupt信号是，可能的两种结果:</p><ol><li>线程处于运行状态时，线程对象的isInterrupt属性被置为true</li><li>处于阻塞状态是，抛出InterruptedException异常，其isInterrupt不会被置为true。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Tests whether the current thread has been interrupted.  The</span><br><span class="line">     * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span><br><span class="line">     * other words, if this method were to be called twice in succession, the</span><br><span class="line">     * second call would return false (unless the current thread were</span><br><span class="line">     * interrupted again, after the first call had cleared its interrupted</span><br><span class="line">     * status and before the second call had examined it).</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see #isInterrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public static boolean interrupted() &#123;</span><br><span class="line">        return currentThread().isInterrupted(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><br><span class="line">     * status&lt;/i&gt; of the thread is unaffected by this method.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><br><span class="line">     * at the time of the interrupt will be reflected by this method</span><br><span class="line">     * returning false.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><br><span class="line">     *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><br><span class="line">     * @see     #interrupted()</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     */</span><br><span class="line">    public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line">     * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line">     * passed.</span><br><span class="line">     */</span><br><span class="line">    private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure><p>可以看出interrupted和isInterrupted区别在于传给ClearInterrupted的参数是true还是false。</p><p><strong>ClearInterrupted参数向操作系统指明是否在获取状态后将当前线程的interrupted状态重置为false。</strong></p><p>这就意味着当某个线程的isInterrupt属性成功被置为true后，如果您使用对象方法thread.isInterrupted()获取值，无论您获取多少次得到的返回值都是true；但是如果您使用静态方法Thread.interrupted()获取值，那么只有第一次获取的结果是true，随后线程的isInterrupt属性将被恢复成false，后续无论使用Thread.interrupted()调用还是使用thread.isInterrupted()调用，获取的结果都是false。</p><p>wait和sleep都是让<strong>当前线程</strong>进入阻塞状态，yield是让主线程等待调用yield的线程执行完。</p><p>sleep是static方法</p><hr><p>Java语言为我们提供了两种基础线程池的选择：ScheduledThreadPoolExecutor和ThreadPoolExecutor。它们都实现了ExecutorService接口（注意，ExecutorService接口本身和“线程池”并没有直接关系，它的定义更接近“执行器”，而“使用线程管理的方式进行实现”只是其中的一种实现方式）。</p><h2 id="JAVA主要线程池的继承结构"><a href="#JAVA主要线程池的继承结构" class="headerlink" title="JAVA主要线程池的继承结构"></a>JAVA主要线程池的继承结构</h2><p><img src="/images/Thread04.png" alt=""></p><ul><li>ThreadPoolExecutor：对于任务的执行是立即的、一次性的。</li><li>ScheduledThreadPoolExecutor：一个用来执行延迟任务、定时任务或者周期性任务的线程池。一般情况下，我们用它可以处理定时计算、周期性统计一类的任务。</li><li>ForkJoinPool：ScheduledThreadPoolExecutor和ThreadPoolExecutor都是在JDK1.5版本中提供的。在JDK1.7中，JAVA为我们提供了一种新的线程池ForkJoinPool以及配套的任务定义ForkJoinTask。除了可以执行实现了Runnable接口或者Callable接口的任务以外，ForkJoinPool还可以执行集成了ForkJoinTask定义的任务。ForkJoinPool的执行原理和ThreadPoolExecutor的执行原理是不一样的</li></ul><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>线程池最主要的一项工作，就是在满足某些条件的情况下创建线程。而在ThreadPoolExecutor线程池中，创建线程的工作交给ThreadFactory来完成。要使用线程池，就必须要指定ThreadFactory。</p><p>如果我们使用的构造函数时并没有指定使用的ThreadFactory，这个时候ThreadPoolExecutor会使用一个默认的ThreadFactory：DefaultThreadFactory。（这个类在Executors工具类中）</p><p>Executors工具类和ThreadPoolExecutor类存在循环依赖：ThreadPoolExecutor中使用了Executors工具类中定义的DefaultThreadFactory；而在Executors工具类中却又在创建ThreadPoolExecutor的对象实例。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://blog.csdn.net/column/details/yinwenjiethread.html" target="_blank" rel="noopener">多线程基础</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://hsb786.github.io/2018/04/19/CAS/"/>
    <id>https://hsb786.github.io/2018/04/19/CAS/</id>
    <published>2018-04-19T09:41:51.000Z</published>
    <updated>2018-04-19T12:14:24.574Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CAS（Compare And Swap），翻译过来就是比较和替换。</strong></p><p><strong>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</strong></p><p><strong>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。</strong></p><a id="more"></a><p>举个例子</p><ol><li>在内存地址V当中，存储着值为10的变量。</li></ol><p><img src="/images/CAS01.png" alt=""></p><ol start="2"><li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</li></ol><p><img src="/images/CAS02.png" alt=""></p><ol start="3"><li>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11</li></ol><p><img src="/images/CAS03.png" alt=""></p><ol start="4"><li>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</li></ol><p><img src="/images/CAS04.png" alt=""></p><ol start="5"><li>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</li></ol><p><img src="/images/CAS05.png" alt=""></p><ol start="6"><li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</li></ol><p><img src="/images/CAS06.png" alt=""></p><ol start="7"><li>线程1进行SWAP，把地址V的值替换为B，也就是12。</li></ol><p><img src="/images/CAS07.png" alt=""></p><hr><h2 id="synchronized与CAS"><a href="#synchronized与CAS" class="headerlink" title="synchronized与CAS"></a>synchronized与CAS</h2><p>synchronized关键字会让没有得到线程锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的切换，代价比较高。</p><p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>指的是<code>java.util.concurrent.atomic</code>包下，一系列以Atomic开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private volatile int value;</span><br><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unsafe</strong>：Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。unsafe为我们提供了硬件级别的原子操作。</p><p><strong>valueOffset</strong>：至于valueOffset对象，是通过unsafe.objectFieldOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单地把valueOffset理解为value变量的内存地址。</p><p>getAndIncrement 相当于i++，先返回值再加1</p><p>在java7中是这样实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getAndIncrement方法内部会不停的循环，直到unsafe.comparAndSwapInt方法执行成功。<br>valueOffset相当于前面讲的V，expect：旧的预期值A，update：新的预期值B</p><hr><p>java8中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//AtomicInteger.class</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这时需要查看Unsafe的源码，可以下载openjdk，openjdk中有关于<code>sun.misc</code>包中的源码</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Unsafe.class</span><br><span class="line">public final int getAndAddInt(Object o, long offset, int delta) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    do &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public native int     getIntVolatile(Object o, long offset);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                  int expected,</span><br><span class="line">                                                  int x);</span><br></pre></td></tr></table></figure><p>感觉跟jdk7差不多，只是把具体的实现从AtomicInteger移动到了Unsafe中。为了重用？这只是我的个人理解，错了欢迎指正。</p><p>Java语言CAS底层就是利用unsafe提供的原子性操作方法来实现的。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>1. CPU开销较大</strong></p><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p><strong>2. 不能保证代码块的原子性</strong></p><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p><p><strong>3. ABA问题</strong></p><p>当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。利用版本号比较可以有效解决ABA问题。</p><hr><p><em>参考</em></p><blockquote><p><a href="http://mp.weixin.qq.com/s/f9PYMnpAgS1gAQYPDuCq-w" target="_blank" rel="noopener">漫画：什么是CAS机制？</a></p><p><a href="http://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg" target="_blank" rel="noopener">漫画：什么是CAS机制？（进阶篇）</a></p><p><a href="https://blog.csdn.net/yinwenjie/article/details/72909981" target="_blank" rel="noopener">线程进阶：多任务处理（17）——Java中的锁（Unsafe基础） </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CAS（Compare And Swap），翻译过来就是比较和替换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>RESTful</title>
    <link href="https://hsb786.github.io/2018/04/18/RESTful/"/>
    <id>https://hsb786.github.io/2018/04/18/RESTful/</id>
    <published>2018-04-18T05:37:06.000Z</published>
    <updated>2018-04-18T06:03:55.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他在论文中提到：</p><blockquote><p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”<br><a id="more"></a></p></blockquote><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer（表现层状态转化）的缩写。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><h2 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h2><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息</strong>。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）</strong>。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="HTTP协议，是一个无状态协议，无状态是什么意思"><a href="#HTTP协议，是一个无状态协议，无状态是什么意思" class="headerlink" title="HTTP协议，是一个无状态协议，无状态是什么意思"></a>HTTP协议，是一个无状态协议，无状态是什么意思</h3><h4 id="回答1"><a href="#回答1" class="headerlink" title="回答1"></a>回答1</h4><p>有状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：还不错，挺好吃的。  </p><p>无状态：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：味道怎么样呀？<br>B：？？？啊？啥？啥味道怎么样？</p><p>所以需要cookie这种东西：<br>A：你今天中午吃的啥？<br>B：吃的大盘鸡。<br>A：你今天中午吃的大盘鸡味道怎么样呀？<br>B：还不错，挺好吃的。</p><h4 id="回答2"><a href="#回答2" class="headerlink" title="回答2"></a>回答2</h4><ul><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见</li></ul><p>【状态】的含义就是：客户端和服务器在某次会话中产生的数据，从而【无状态】就意味着，这些数据不会被保留</p><p>但是：</p><ul><li>通过增加cookie和session机制，现在的网络请求其实是有状态的</li><li>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h2 id="路径（Endpoint）"><a href="#路径（Endpoint）" class="headerlink" title="路径（Endpoint）"></a>路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>例子</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><h2 id="过滤信息（Filtering）"><a href="#过滤信息（Filtering）" class="headerlink" title="过滤信息（Filtering）"></a>过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><h2 id="状态码（Status-Codes）"><a href="#状态码（Status-Codes）" class="headerlink" title="状态码（Status Codes）"></a>状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><hr><p><em>参考</em></p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></p><p><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP是一个无状态的协议。这句话里的无状态是什么意思？</a></p><p><a href="http://www.cnblogs.com/bellkosmos/p/5237146.html" target="_blank" rel="noopener">http协议无状态中的 “状态” 到底指的是什么？！</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api" target="_blank" rel="noopener">RESTful API 设计指南</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。&lt;/p&gt;
&lt;p&gt;他在论文中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法</title>
    <link href="https://hsb786.github.io/2018/04/18/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/18/基本排序算法/</id>
    <published>2018-04-18T04:27:50.000Z</published>
    <updated>2018-04-18T10:27:23.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：<strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void quickSort(int[] array) &#123;</span><br><span class="line">    quickSort(array, 0, array.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line">    if (left &gt;= right) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = partion(array, left, right);</span><br><span class="line">    quickSort(array, left, mid - 1);</span><br><span class="line">    quickSort(array, mid + 1, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int partion(int[] array, int left, int right) &#123;</span><br><span class="line">    // 取第一个数为基准元素</span><br><span class="line">    int tmp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; array[right] &gt;= tmp) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素小的移动到低端</span><br><span class="line">        array[left] = array[right];</span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= tmp) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 比基准元素大的移动到高端</span><br><span class="line">        array[right] = array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    // 插入基准元素</span><br><span class="line">    array[left] = tmp;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想：<strong>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列</strong></p><p><img src="/images/sort-merge.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void mergeSort(int[] arr) &#123;</span><br><span class="line">int[] temp = new int[arr.length];</span><br><span class="line">mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">if (left &lt; right) &#123;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序</span><br><span class="line">mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序</span><br><span class="line">merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">int i = left;// 左序列指针</span><br><span class="line">int j = mid + 1;// 右序列指针</span><br><span class="line">int t = 0;// 临时数组指针</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">if (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (i &lt;= mid) &#123;// 将左边剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;= right) &#123;// 将右序列剩余元素填充进temp中</span><br><span class="line">temp[t++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">t = 0;</span><br><span class="line">// 将temp中的元素全部拷贝到原数组中</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">arr[left++] = temp[t++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;基本思想：&lt;strong&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://hsb786.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/代理模式/</id>
    <published>2018-04-17T10:21:28.000Z</published>
    <updated>2018-04-17T10:40:01.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为其他对象提供一种代理以控制对这个对象的访问<br><a id="more"></a><br><img src="/images/design-pattern-proxy.png" alt=""></p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>代理对象可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能，符合开闭原则</p></li><li><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p></li></ul><h2 id="代理类分类"><a href="#代理类分类" class="headerlink" title="代理类分类"></a>代理类分类</h2><ul><li><p>静态代理:静态定义代理类，我们自己静态定义的代理类。</p></li><li><p>动态代理:通过程序动态生成代理类，该代理类不是我们自己定义的，而是由程序自动生成，常用的动态代理技术有JDK自带的动态代理和CGLIB动态代理。</p></li></ul><hr><p>*参考</p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/30/代理模式/" target="_blank" rel="noopener">代理模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://hsb786.github.io/2018/04/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/17/策略模式/</id>
    <published>2018-04-17T10:07:27.000Z</published>
    <updated>2018-04-17T10:39:27.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p></blockquote><p>根据条件的不同选择不同的策略<br><a id="more"></a></p><p><img src="/images/design-pattern-strategy01.png" alt=""></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用享元模式在一定程度上减少对象的数量。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1691" target="_blank" rel="noopener">设计模式（十二）——策略模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据条件的不同选择不同的策略&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="https://hsb786.github.io/2018/04/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://hsb786.github.io/2018/04/17/抽象工厂/</id>
    <published>2018-04-17T09:17:08.000Z</published>
    <updated>2018-04-17T10:39:47.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></blockquote><p>将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。<br><a id="more"></a><br><img src="/images/design-pattern-factory02.png" alt=""></p><hr><h2 id="产品等级结构和产品族"><a href="#产品等级结构和产品族" class="headerlink" title="产品等级结构和产品族"></a>产品等级结构和产品族</h2><p>产品等级结构： <strong>产品等级结构即产品的继承结构，同一类产品</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p>产品族：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，同一个品牌产品</strong>，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><h2 id="抽象工厂与工厂方法"><a href="#抽象工厂与工厂方法" class="headerlink" title="抽象工厂与工厂方法"></a>抽象工厂与工厂方法</h2><p>抽象工厂和工厂方法最大的区别在于，工厂方法针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p><p>工厂方法：用来生产同一等级结构中的固定产品（支持增加任意产品，新增产品是不需要更改已有的工程，需要增加该产品对应的工程。符合单一职责原则、符合开闭原则。但是引入了复杂性）</p><p>抽象工厂：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开闭原则，降低了复杂性）</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>每次可以通过具体工厂类创建一个产品族的多个对象，增加新的具体工厂和产品族很方便。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/13/工厂模式-下/" target="_blank" rel="noopener">工厂模式-下</a></p><p><a href="http://www.hollischuang.com/archives/1430" target="_blank" rel="noopener">设计模式（八）——工厂模式总结</a><br><a href="http://www.hollischuang.com/archives/1420" target="_blank" rel="noopener">设计模式（七）——抽象工厂模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将同一产品族的单独的工厂封装起来。通过创建抽象工厂的具体实现，然后使用抽象工厂做为接口来创建这一产品族的具体对象。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://hsb786.github.io/2018/04/17/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://hsb786.github.io/2018/04/17/工厂方法/</id>
    <published>2018-04-17T09:05:30.000Z</published>
    <updated>2018-04-17T10:31:24.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>定义了一个用于创建对象的接口，让子类决定实例化哪一个类。</p></blockquote><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。<br><a id="more"></a><br><img src="/images/design-pattern-factory01.png" alt=""></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/08/工厂模式/" target="_blank" rel="noopener">工厂模式(上)</a></p><p><a href="http://www.cnblogs.com/xiaoxi/p/7641358.html" target="_blank" rel="noopener">设计模式：工厂方法模式</a></p><p><a href="http://www.hollischuang.com/archives/1401" target="_blank" rel="noopener">设计模式（五）——工厂方法模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;定义了一个用于创建对象的接口，让子类决定实例化哪一个类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="https://hsb786.github.io/2018/04/16/ClassLoader/"/>
    <id>https://hsb786.github.io/2018/04/16/ClassLoader/</id>
    <published>2018-04-16T12:21:34.000Z</published>
    <updated>2018-04-16T13:38:14.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。</p></blockquote><a id="more"></a><pre><code>public abstract class ClassLoader</code></pre><blockquote><p>class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // First, check if the class has already been loaded</span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // ClassNotFoundException thrown if class not found</span><br><span class="line">                   // from the non-null parent class loader</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;</span><br><span class="line">                   // If still not found, then invoke findClass in order</span><br><span class="line">                   // to find the class.</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   // this is the defining class loader; record the stats</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用指定的二进制名称来加载类，这个方法的默认实现按照以下顺序查找类： 调用findLoadedClass(String)方法检查这个类是否被加载过 使用父加载器调用loadClass(String)方法，如果父加载器为Null，类加载器装载虚拟机内置的加载器调用findClass(String)方法装载类， 如果，按照以上的步骤成功的找到对应的类，并且该方法接收的resolve参数的值为true,那么就调用resolveClass(Class)方法来处理类。</p></blockquote><hr><p>java中的类大致分为三种:</p><ol><li>系统类</li><li>扩展类</li><li>由程序员自定义的类</li></ol><p>类装载方式，有两种：</p><ol><li>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。</li><li>显式装载， 通过class.forName()等方法，显式加载需要的类</li></ol><p>类加载的动态性体现：</p><blockquote><p>一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现</p></blockquote><h2 id="java类装载器"><a href="#java类装载器" class="headerlink" title="java类装载器"></a>java类装载器</h2><p>Java中的类装载器实质上也是类，功能是把类载入jvm中，jvm的类装载器有三个，层次结构如下：</p><p><img src="/images/ClassLoader01.png" alt=""></p><h2 id="类加载器之间是如何协调工作的"><a href="#类加载器之间是如何协调工作的" class="headerlink" title="类加载器之间是如何协调工作的"></a>类加载器之间是如何协调工作的</h2><p>java是如何区分一个类该由哪个类加载器来完成呢。 在这里java采用了委托模型机制，这个机制简单来讲，就是“类装载器有载入类的需求时，会先请示其Parent使用其搜索路径帮忙载入，如果Parent 找不到,那么才由自己依照自己的搜索路径搜索类”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Public class Test&#123;</span><br><span class="line">    Public static void main(String[] arg)&#123;</span><br><span class="line">        ClassLoader c  = Test.class.getClassLoader();  //获取Test类的类加载器</span><br><span class="line">        System.out.println(c); </span><br><span class="line">        ClassLoader c1 = c.getParent();  //获取c这个类加载器的父类加载器</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        ClassLoader c2 = c1.getParent();//获取c1这个类加载器的父类加载器</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output</span><br><span class="line">AppClassLoader</span><br><span class="line">ExtClassLoader</span><br><span class="line">Null</span><br></pre></td></tr></table></figure><p>可以看出Test是由<strong>AppClassLoader</strong>加载器加载的，<strong>AppClassLoader</strong>的<code>Parent</code> 加载器是 <strong>ExtClassLoader</strong>,但是<strong>ExtClassLoader</strong>的<code>Parent</code>为 <code>null</code> 是怎么回事。<strong>Bootstrap Loader</strong>是用C++语言写的，依java的观点来看，逻辑上并不存在<strong>Bootstrap Loader</strong>的类实体，所以在java程序代码里试图打印出其内容时，我们就会看到输出为<code>null</code>。</p><p>java类加载器基于三个机制：委托，可见，单一。</p><ul><li>委托机制：指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载他。</li><li>可见性机制：指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。</li><li>单一性机制：指的是一个类只能被同一种加载器加载一次。</li></ul><hr><h2 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h2><p>类装载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤：</p><ul><li>装载：查找和导入Class文件</li><li>链接：<ul><li>验证：检查载入的class文件数据的正确性</li><li>准备： 给类的静态变量分配存储空间</li><li>解析： 将符号引用转成直接引用</li></ul></li><li>初始化：对静态变量，静态代码块执行初始化工作</li></ul><p>类装载工作由<code>ClassLoder</code>和其子类负责。JVM在运行时会产生三个ClassLoader：<strong>根装载器</strong>，<code>ExtClassLoader</code>(<strong>扩展类装载器</strong>)和<code>AppClassLoader</code>，其中根装载器不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库，如JRE目录下的rt.jar,charsets.jar等。<code>ExtClassLoader</code>是<code>ClassLoder</code>的子类，负责装载JRE扩展目录ext下的jar类包；<code>AppClassLoader</code><strong>负责装载classpath路径下的类包，这三个类装载器存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下使用AppClassLoader装载应用程序的类</strong></p><p>Java装载类使用“<strong>全盘负责委托机制</strong>”。“<strong>全盘负责</strong>”是指当一个<code>ClassLoder</code>装载一个类时，除非显示的使用另外一个<code>ClassLoder</code>，该类所依赖及引用的类也由这个<code>ClassLoder载入</code>；“<strong>委托机制</strong>”是指先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全方面考虑的，试想如果一个人写了一个恶意的基础类（如<code>java.lang.String</code>）并加载到<code>JVM</code>将会引起严重的后果，但有了全盘负责制，<code>java.lang.String</code>永远是由根装载器来装载，避免以上情况发生 除了JVM默认的三个<code>ClassLoder</code>以外，第三方可以编写自己的类装载器，以实现一些特殊的需求。类文件被装载解析后，在<code>JVM</code>中都有一个对应的<code>java.lang.Class</code>对象，提供了类结构信息的描述。数组，枚举及基本数据类型，甚至<code>void</code>都拥有对应的<code>Class</code>对象。</p><hr><p>装载过程有两个比较重要的特征：<strong>层次组织结构</strong>和<strong>代理模式</strong>。<strong>层次组织结构</strong>指的是每个类加载器都有一个父类加载器，通过getParent()方法可以获取到。类加载器通过这种父亲-后代的方式组织在一起，形成树状层次结构。<strong>代理模式</strong>则指的是一个类加载器既可以自己完成Java类的定义工作，也可以代理给其它的类加载器来完成。由于代理模式的存在，启动一个类的加载过程的类加载器和最终定义这个类的类加载器可能并不是一个。ClassLoader的加载类过程主要使用loadClass方法，该方法中封装了中加载机制：<strong>双亲委派模式</strong>。</p><blockquote><p>一般来说，父类优先的策略就足够好了。在某些情况下，可能需要采取相反的策略，即先尝试自己加载，找不到的时候再代理给父类加载器。这种做法在Java的Web容器中比较常见，也是<code>Servlet</code>规范推荐的做法。比如，<code>Apache Tomcat</code>为每个<code>Web</code>应用都提供一个独立的类加载器，使用的就是自己优先加载的策略。</p><p>类加载器的一个重要用途是在<code>JVM</code>中为相同名称的Java类创建隔离空间。在<code>JVM</code>中，判断两个类是否相同，不仅是根据该类的二进制名称，还需要根据两个类的定义类加载器。只有两者完全一样，才认为两个类的是相同的。因此，即便是同样的<code>Java</code>字节代码，被两个不同的类加载器定义之后，所得到的<code>Java</code>类也是不同的。如果试图在两个类的对象之间进行赋值操作，会抛出<code>java.lang.ClassCastException</code>。这个特性为同样名称的<code>Java</code>类在<code>JVM</code>中共存创造了条件。在实际的应用中，可能会要求同一名称的<code>Java</code>类的不同版本在<code>JVM</code>中可以同时存在。通过类加载器就可以满足这种需求。</p></blockquote><h2 id="Java类的链接"><a href="#Java类的链接" class="headerlink" title="Java类的链接"></a>Java类的链接</h2><p>Java类的链接指的是将Java类的二进制代码合并到JVM的运行状态之中的过程。在链接之前，这个类必须被成功加载。<br>链接的过程比加载过程要复杂很多，这是实现java的动态性的重要一步！分为三部分：<code>verification</code> （验证）， <code>preparation</code>（准备） 和 <code>resolution</code>（解析）</p><p><strong>1. verification（验证）：</strong><br>验证是用来确保Java类的二进制表示在结构上是完全正确的。要验证比如class文件格式规范、这个类是否继承了final类、不能把一个父类对象赋值给子类数据类型等等。如果验证过程出现错误的话，会抛出java.lang.VerifyError错误。</p><p><strong>2.preparation（准备）：</strong></p><p>准备阶段为方法区中的静态变量分配内存空间。并将其赋值为初始值，所有原始类型的值都为0。如float为0f、 int为0、boolean为0、引用类型为null。</p><p><strong>3.resolution（解析）：</strong></p><p>解析的过程就是确保这些被引用的类能被正确的找到。解析的过程可能会导致其它的Java类被加载。</p><p>为类、接口、方法、成员变量的符号引用定位直接引用。</p><p>符号引用是一个字符串，它唯一标识一个类、一个字段、一个方法等目标。</p><p>而直接引用对于类变量、类方法指的是指向方法区的指针，然后对于实例方法、实例对象来说就是偏移量，比如一个实例方法，子类中方法表中的偏移量和父类是一致的，这个偏移量可以确定某个方法的位置。</p><h2 id="Java类的初始化"><a href="#Java类的初始化" class="headerlink" title="Java类的初始化"></a>Java类的初始化</h2><p>类的初始化是延迟的，直到类第一次被主动使用(active use)，JVM 才会初始化类。<br>当一个Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。初始化过程的主要操作是执行静态代码块和初始化静态域。在一个类被初始化之前，它的直接父类也需要被初始化。但是，一个接口的初始化，不会引起其父接口的初始化。在初始化的时候，会按照源代码中从上到下的顺序依次执行静态代码块和初始化静态域。</p><p>初始化过程会被触发的条件汇总：</p><ol><li>使用new关键字实例化对象、访问一个类的静态字段、静态方法的时候。</li><li>对类进行反射调用的时候。</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则进行父类的初始化。</li></ol><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/199" target="_blank" rel="noopener">深度分析Java的ClassLoader机制（源码级别）</a></p><p><a href="http://www.hollischuang.com/archives/201" target="_blank" rel="noopener">Java类的加载、链接和初始化</a></p><p><a href="http://brianway.github.io/2016/02/03/javase-learn-note-3-ClassLoader/" target="_blank" rel="noopener">java基础巩固笔记(3)-类加载器</a></p><p><a href="https://blog.csdn.net/seu_calvin/article/details/52301541" target="_blank" rel="noopener">JVM——Java类加载机制总结 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的，loadClass使用双亲委派模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
      <category term="JVM" scheme="https://hsb786.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://hsb786.github.io/2018/04/16/HTTP/"/>
    <id>https://hsb786.github.io/2018/04/16/HTTP/</id>
    <published>2018-04-16T10:43:52.000Z</published>
    <updated>2018-04-16T11:53:59.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？</p><p>还能怎么办，学啊。</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>百度百科上的解释</p><blockquote><p>Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。<br><a id="more"></a></p></blockquote><p>TCP/IP协议族就采用了分层的思想，自上而下分成了四层： 应用层，传输层，网络层，链路层，每一层的协议只约定了特定的功能，HTTP就位于应用层。利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。一次HTTP请求的典型过程如下图所示</p><p><img src="/images/HTTP01.jpg" alt=""></p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><blockquote><p>URI是Uniform Resource Identifier的缩写，是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。</p></blockquote><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://</span><br><span class="line">ftp://</span><br></pre></td></tr></table></figure></p><p>我们比较熟悉的URL（<code>Uniform Resource Locator</code>，统一资源定位符）表示资源在互联网上的地址，它其实是URI的一个子集，因为URI仅仅表示「标识」， 标识的类型有很多，比如ISBN号码，电话号码，邮箱，网页链接地址等，而URL则把概念缩小到了「地址」。 由于URI在绝大多数场景下都是以URL的形式存在，大家一般都说URL居多，这也没什么问题，但是在心里要清楚URI和URL还是有所区别的。</p><h2 id="HTTP协议内容"><a href="#HTTP协议内容" class="headerlink" title="HTTP协议内容"></a>HTTP协议内容</h2><p>接下来的内容基于HTTP 1.1版本。</p><h3 id="请求-amp-响应报文结构"><a href="#请求-amp-响应报文结构" class="headerlink" title="请求 &amp; 响应报文结构"></a>请求 &amp; 响应报文结构</h3><blockquote><p>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。HTTP协议规定，请求从客户端发出， 最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p></blockquote><p><img src="/images/HTTP02.jpg" alt=""></p><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 如下是一个HTTP请求和响应报文的实例</p><p><img src="/images/HTTP03.jpg" alt=""></p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><blockquote><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 数字中的第一位指定了响应类别，后两位无分类。</p></blockquote><p>状态码主要类型一览：</p><p><img src="/images/HTTP04.jpg" alt=""></p><h3 id="首部-amp-实体"><a href="#首部-amp-实体" class="headerlink" title="首部 &amp; 实体"></a>首部 &amp; 实体</h3><blockquote><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p></blockquote><p>HTTP首部字段由首部字段名和字段值构成的，中间用冒号“:”分隔。比如：<code>Content-Type: text/html</code>。 HTTP实体是HTTP请求和响应传输的主体内容，根据场景不同可能是表单参数，HTML文本，JSON文本，二进制流等。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。</p></blockquote><blockquote><p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p></blockquote><p><img src="/images/HTTP05.png" alt=""></p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>GET和POST最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数</p><p>W3school的解答</p><table><thead><tr><th>方法</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><p>这个对比只是给出了一些现象上的区别</p><hr><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 </p><p>如果你用GET服务，在request body中存了数据，不同服务器的处理方式是不同的，有些服务器会读出数据，有些服务器直接忽略。所以，虽然GET可以带request body，但不能保证一定能被接受到。</p><h2 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h2><blockquote><p>征求意见稿（英语：Request For Comments，缩写为RFC），是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件，以编号排定。目前RFC文件是由互联网协会（ISOC）赞助发行。</p></blockquote><p>简单理解RFC就是互联网的规范，我们通常所说的「协议」就是以RFC的形式存在，而现行的HTTP/1.1规范的RFC有如下几个： RFC7230， RFC7231， RFC7232， RFC7233， RFC7234， RFC7235。 其中RFC7231里的Section 4. Request Methods涉及到了几个HTTP方法，接下来仔细阅读这一章节。</p><blockquote><p>The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.</p></blockquote><p>semantic[语义]，语法与语义的区别：</p><blockquote><p>一种语言是合法句子的集合。什么样的句子是合法的呢？可以从两方面来判断：语法和语义。语法是和文法结构有关，然而语义是和按照这个结构所组合的单词符号的意义有关。合理的语法结构并不表明语义是合法的。例如我们常说：我上大学，这个句子是符合语法规则的，也符合语义规则。但是大学上我，虽然符合语法规则，但没有什么意义，所以说是不符合语义的。</p></blockquote><p>对于HTTP请求来说，语法是指请求响应的格式，比如请求第一行必须是 方法名 URI 协议/版本 这样的格式。</p><p>语义则定义了这一类型的请求具有什么样的性质。比如GET的语义就是「获取资源」，POST的语义是「处理资源」，那么在具体实现这两个方法时，就必须考虑其语义，做出符合其语义的行为。</p><p>当然在符合语法的前提下实现违背语义的行为也是可以做到的，比如使用GET方法修改用户信息，POST获取资源列表，这样就只能说这个请求是「合法」的，但不是「符合语义」的。 </p><p>RFC7231里紧接着定义了HTTP方法的几个特性：</p><blockquote><p>Safe - 安全<br>这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此RFC定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。<br>但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用GET修改用户信息的情况。<br>引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。</p><p>Idempotent - 幂等<br>幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照RFC规范，PUT，DELETE和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。<br>引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。</p><p>Cacheable - 可缓存性<br>顾名思义就是一个方法是否可以被缓存，此RFC里GET，HEAD和某些情况下的POST都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持GET和HEAD。</p></blockquote><p>在这三个特性里一直在强调同一个事情，那就是协议不等于实现：协议规定安全在实现里不一定安全，协议规定幂等在实现里不一定幂等，协议规定可缓存在实现里不一定可缓存。</p><h3 id="语义之争"><a href="#语义之争" class="headerlink" title="语义之争"></a>语义之争</h3><p>GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-Control Header的约束）,GET方法的报文主体没有任何语义。</p><p>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://baike.baidu.com/item/TCP%2FIP协议/212915?fr=aladdin&amp;fromid=214077&amp;fromtitle=tcp%2Fip" target="_blank" rel="noopener">TCP/IP协议 百度百科</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别 </a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/01/26/图解HTTP-读书笔记/" target="_blank" rel="noopener">图解HTTP-读书笔记</a></p><p><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">HTTP 方法：GET 对比 POST</a></p><p><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;感觉计算机网络课上学的东西忘得差不多了，怎么办？怎么办？&lt;/p&gt;
&lt;p&gt;还能怎么办，学啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP&quot;&gt;&lt;/a&gt;TCP/IP&lt;/h2&gt;&lt;p&gt;百度百科上的解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://hsb786.github.io/2018/04/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hsb786.github.io/2018/04/16/单例模式/</id>
    <published>2018-04-16T05:35:59.000Z</published>
    <updated>2018-04-16T10:24:50.310Z</updated>
    
    <content type="html"><![CDATA[<p>定义：单例对象的类必须保证只有一个实例存在<br>场景：希望在整个系统中只能出现某个类的一个实例</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>懒汉式：指全局的单例实例在第一次被使用时构建</li><li>饿汉式：指全局的单例实例在类装载时构建</li></ul><p>日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。<br><a id="more"></a></p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Single &#123;</span><br><span class="line">    private static volatile Single instance;</span><br><span class="line">    private Single() &#123;&#125;</span><br><span class="line">    public static Single getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Single.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instance = new Single()；这个语句在JVM中，实际执行的原子语句包括：</p><ol><li>给Single分配内存</li><li>调用Single的构造函数完成初始化，返回类实例</li><li>将instance指向之前分配的完成初始化的内存</li></ol><p>编译器在不改变单线程程序语义的前提下，可以对指令重排序。1-2-3可能会变成1-3-2</p><p>导致的结果可能就是，线程B执行到1- 3 , 已经将instance引用指向了分配的内存，但是并没有执行初始化操作，所以这个时候instance并不等于null，但是没有被初始化。然后，线程B让出CPU，线程A开始执行，判断if(instance==null)，由于instance不等于null，于是线程A就直接返回这个instance，但是这个对象是线程B没有初始化的对象。</p><p>so，加上volatile修饰后，就可以禁止指令重排，遵循happens-before原则。保证B线程对instance的修改happens-before于A线程对instance的读。</p><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">         return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static final Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前一种方法只要Single类被加载了，那么instance就会被实例化。而这种方式是Singleton类被加载了，instance不一定被实例化。因为SingletonHoler类没有被主动使用，只在外部类的Singleton的getInstance()中被调用时才加载，从而实例化Instance，这样就可以启动延迟加载。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://lujunqiu.github.io/2017/11/15/单例模式/" target="_blank" rel="noopener">单例模式</a></p><p><a href="http://www.hollischuang.com/archives/1373" target="_blank" rel="noopener">设计模式（二）——单例模式</a></p><p><a href="http://www.hollischuang.com/archives/205" target="_blank" rel="noopener">[转+注]单例模式的七种写法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：单例对象的类必须保证只有一个实例存在&lt;br&gt;场景：希望在整个系统中只能出现某个类的一个实例&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;懒汉式：指全局的单例实例在第一次被使用时构建&lt;/li&gt;
&lt;li&gt;饿汉式：指全局的单例实例在类装载时构建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日常我们使用的较多的应该是懒汉式的单例，因为按需加载才能做到资源的最大化利用。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hsb786.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Integer</title>
    <link href="https://hsb786.github.io/2018/04/16/Integer/"/>
    <id>https://hsb786.github.io/2018/04/16/Integer/</id>
    <published>2018-04-16T05:09:49.000Z</published>
    <updated>2018-04-16T05:24:55.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre><code>public final class Integer extends Number implements Comparable&lt;Integer&gt;</code></pre><ol><li>Integer不能被继承</li><li>Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较</li><li>Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值</li></ol><a id="more"></a><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code>private final int value;</code></pre><p>value属性就是Integer对象中保存的int值</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i=new Integer(1);</span><br><span class="line">i=2;</span><br></pre></td></tr></table></figure><p>反编译之后的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(1);</span><br><span class="line">i = Integer.valueOf(2);</span><br></pre></td></tr></table></figure><p>编译器会把<code>i=2</code>转换成<code>i=Integer.valueOf(2)</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，IntegerCache.low=-128，IntegerCache.high=127（除非显示声明java.lang.Integer.IntegerCache.high的值），Integer中有一段静态代码块，该部分内容会在Integer类被加载的时候就执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line">    * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line">    *</span><br><span class="line">    * The cache is initialized on first usage.  The size of the cache</span><br><span class="line">    * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="line">    * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line">    * may be set and saved in the private system properties in the</span><br><span class="line">    * sun.misc.VM class.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，当Integer被加载时，就新建了-128到127的所有数字并存放在Integer数组cache中。</p><p>再回到valueOf代码，可以得出结论。当调用valueOf方法时，如果参数的值在-127到128之间，则直接从缓存中返回一个已经存在的对象。如果参数的值不在这个范围内，则new一个Integer对象返回。</p><p>所以，当把一个int变量转成Integer的时候（或者新建一个Integer的时候），建议使用valueOf方法来代替构造函数。或者直接使用Integer i = 100;编译器会转成Integer s = Integer.valueOf(100);</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1058" target="_blank" rel="noopener">Java 源码学习系列（三）——Integer</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; title=&quot;类定义&quot;&gt;&lt;/a&gt;类定义&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public final class Integer extends Number implements Comparable&amp;lt;Integer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;Integer不能被继承&lt;/li&gt;
&lt;li&gt;Integer实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较&lt;/li&gt;
&lt;li&gt;Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="https://hsb786.github.io/2018/04/16/String/"/>
    <id>https://hsb786.github.io/2018/04/16/String/</id>
    <published>2018-04-16T04:35:57.000Z</published>
    <updated>2018-04-16T05:10:19.587Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过<code>StringBuilder</code>的<code>append()</code>方法来实现的，字符串的转换通过<code>toString</code>方法实现。<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence{}</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code>private final char value[];</code></pre><p>这是一个字符数组，并且是final类型，它用于存储字符串内容，从final这个关键字中我们可以看出，String的内容一旦被初始化了是不能被改变的。</p><pre><code>private int hash;</code></pre><p>缓存字符串的hashCode，默认值为0</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="1-使用字符数组、字符串构造一个String"><a href="#1-使用字符数组、字符串构造一个String" class="headerlink" title="1. 使用字符数组、字符串构造一个String"></a>1. 使用字符数组、字符串构造一个String</h3><p>但我们使用字符数组创建String的时候，会用到<code>Arrays.copyOf</code>方法和<code>Arrays.copyOfRange</code>方法。这两个方法是将原有的字符数组中的内容逐一复制到String中的字符数组中。同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将<code>源String</code>中的<code>value</code>和<code>hash</code>两个属性直接赋值给<code>目标String</code>。因为String是不可变的，所以不用担心改变<code>源String</code>的值会影响到<code>目标String</code>的值</p><h3 id="2-使用字节数组构造一个String"><a href="#2-使用字节数组构造一个String" class="headerlink" title="2.使用字节数组构造一个String"></a>2.使用字节数组构造一个String</h3><p>在Java中，String实例中保存有一个<code>char[]</code>字符数组，<code>char[]</code>字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。<code>String(byte[] bytes, Charset charset)</code>是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，构造成新的String。</p><h3 id="3-使用StringBuffer和StringBuider构造一个String"><a href="#3-使用StringBuffer和StringBuider构造一个String" class="headerlink" title="3.使用StringBuffer和StringBuider构造一个String"></a>3.使用StringBuffer和StringBuider构造一个String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String(StringBuffer buffer) &#123;</span><br><span class="line">    synchronized(buffer) &#123;</span><br><span class="line">        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String(StringBuilder builder) &#123;</span><br><span class="line">    this.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很少用到，当我们有了StringBuffer或者StringBuilfer对象之后可以直接使用他们的toString方法来得到String。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    // Create a copy, don&apos;t share the array</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br></pre></td></tr></table></figure><h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><p>java7以后，常量池被放入到堆空间中。导致intern()函数的功能不同。intern()检查常量池是否存在该字符串，存在的话就直接返回；否则返回首次在堆中声明的相同字符串的引用</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/99" target="_blank" rel="noopener">Java 7 源码学习系列（一）——String</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言提供了对字符串连接元素符的特别支持（+），该符号也可用于将其他类型转换成字符串。字符串的连接实际上是通过&lt;code&gt;StringBuilder&lt;/code&gt;的&lt;code&gt;append()&lt;/code&gt;方法来实现的，字符串的转换通过&lt;code&gt;toString&lt;/code&gt;方法实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>enum</title>
    <link href="https://hsb786.github.io/2018/04/16/enum/"/>
    <id>https://hsb786.github.io/2018/04/16/enum/</id>
    <published>2018-04-16T03:47:49.000Z</published>
    <updated>2018-04-16T04:32:59.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类</p></blockquote><a id="more"></a><pre><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable</code></pre><p><img src="/images/enum01.png" alt=""></p><p><strong>Enum类无法被继承</strong></p><p>定义一个Color枚举</p><pre><code>enum Color {RED, GREEN, YELLOW}</code></pre><p>反编译后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class EnumTest.Color extends java.lang.Enum&lt;EnumTest.Color&gt; &#123;</span><br><span class="line">  public static final EnumTest.Color RED;</span><br><span class="line">  public static final EnumTest.Color GREEN;</span><br><span class="line">  public static final EnumTest.Color YELLOW;</span><br><span class="line">  private static final EnumTest.Color[] ENUM$VALUES;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">  private EnumTest.Color(java.lang.String, int);</span><br><span class="line">  public static EnumTest.Color[] values();</span><br><span class="line">  public static EnumTest.Color valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从反编译之后的代码中，我们发现，编译器不让我们继承Enum，但是当我们使用enum关键字定义一个枚举的时候，他会帮我们在编译后默认继承java.lang.Enum类，而不像其他的类一样默认继承Object类。且采用enum声明后，该类会被编译器加上final声明，故该类是无法继承的。</p><hr><p>Enum实现了Serializable和Comparable接口，进行比较时只有同类型的enum才能进行比较，要想实现不同类型的enum之间的比较，只能重写compareTo方法</p><p><strong>Enum&lt;E extends Enum&lt;E>></strong></p><p>一个Enum只接受一个Enum或者他的子类作为参数</p><p><strong>compartTo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int compareTo(E o) &#123;</span><br><span class="line">        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">        Enum&lt;E&gt; self = this;</span><br><span class="line">        if (self.getClass() != other.getClass() &amp;&amp; // optimization</span><br><span class="line">            self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">            throw new ClassCastException();</span><br><span class="line">        return self.ordinal - other.ordinal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Java使用Enum&lt;E extends Enum<e>&gt;声明Enum，并且在compareTo的中使用E作为参数。这两个条件限制Color.RED只能和Color定义出来的枚举进行比较</e></p><p><strong>成员变量</strong><br>在Enum中，有两个成员变量，一个是名字(name)，一个是序号(ordinal)。序号是一个枚举常量，表示在枚举中的位置，从0开始，依次递增。</p><p><strong>构造函数</strong><br>Enum是一个抽象类，不能被实例化，但是他也有构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Enum(String name，int ordinal)&#123;</span><br><span class="line">      this.name=name;</span><br><span class="line">      this.ordinal=ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/92" target="_blank" rel="noopener">Java 7 源码学习系列（二）——Enum</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Enum类是java.lang包中的一个类，他是Java语言中所有枚举类型的公共基类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>javap</title>
    <link href="https://hsb786.github.io/2018/04/15/javap/"/>
    <id>https://hsb786.github.io/2018/04/15/javap/</id>
    <published>2018-04-15T11:11:13.000Z</published>
    <updated>2018-04-15T11:48:20.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class T01 &#123;</span><br><span class="line">private volatile int n;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sub() &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap T01 输出T01的public域及方法</p><p><img src="/images/javap01.png" alt=""></p><p>javap -c T01 列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用</p><p><img src="/images/javap02.png" alt=""></p><p>javap -p T01 输出所有类和成员</p><p><img src="/images/javap03.png" alt=""></p><p>javap -v T01 输出栈大小，方法参数的个数</p><p><img src="/images/javap04.png" alt=""></p><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-help 帮助</span><br><span class="line">-l 输出行和变量的表</span><br><span class="line">-public 只输出public方法和域</span><br><span class="line">-protected 只输出public和protected类和成员</span><br><span class="line">-package 只输出包，public和protected类和成员，这是默认的</span><br><span class="line">-p -private 输出所有类和成员</span><br><span class="line">-s 输出内部类型签名</span><br><span class="line">-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，</span><br><span class="line">-verbose 输出栈大小，方法参数的个数</span><br><span class="line">-constants 输出静态final常量</span><br></pre></td></tr></table></figure><h3 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h3><table><thead><tr><th>major version</th><th>java版本</th></tr></thead><tbody><tr><td>46</td><td>2</td></tr><tr><td>47</td><td>3</td></tr><tr><td>48</td><td>4</td></tr><tr><td>49</td><td>5</td></tr><tr><td>50</td><td>6</td></tr><tr><td>51</td><td>7</td></tr><tr><td>52</td><td>8</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码文件&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://hsb786.github.io/2018/04/14/Proxy/"/>
    <id>https://hsb786.github.io/2018/04/14/Proxy/</id>
    <published>2018-04-14T08:14:06.000Z</published>
    <updated>2018-04-14T11:25:27.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>通过<code>java.lang.reflect.Proxy</code>类以及<code>java.lang.reflect.InvocationHandler</code>接口来实现动态代理</p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h2><p>InvocationHandler接口的唯一方法：</p><p><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code></p><ul><li>proxy:    代理类实例</li><li>method:   方法</li><li>args:     方法入参</li></ul><a id="more"></a><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>public static Object newProxyInstance Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p><ul><li>loader： ClassLoader，定义由哪个ClassLoader对象类对生成的代理对象进行加载</li><li>interfaces：该实现类的所有接口</li><li>h：调用处理程序，表示当这个动态代理对象在调用方法时，会关联到哪一个InvocationHandler对象上</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hello &#123;</span><br><span class="line">void say(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义被代理的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl implements Hello &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void say(String name) &#123;</span><br><span class="line">System.out.println(&quot;Hello &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在最终生成的代理类中包含一个InvocationHandler实现类的成员变量(该成员变量继承自Proxy类)。</span><br><span class="line"> * 在代理类实例调用代理的方法时，将对方法调用进行编码(Method变量)并将其指派到它的调用处理程序的invoke方法。</span><br><span class="line"> * 所以对被代理方法的调用都是通过InvocationHadler的invoke来实现的。</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    //目标对象，被代理接口的实现类</span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">public DynamicProxy(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * @param proxy 代理类实例</span><br><span class="line"> * @param method 方法</span><br><span class="line"> * @param args 方法入参</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description: 获取代理对象</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy() &#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClientProxy &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new HelloImpl();</span><br><span class="line">DynamicProxy dynamicProxy = new DynamicProxy(hello);</span><br><span class="line">Hello helloProxy = dynamicProxy.getProxy();</span><br><span class="line">helloProxy.say(&quot;hh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output:</span><br><span class="line">        Before</span><br><span class="line">        Hello hh</span><br><span class="line">        After</span><br></pre></td></tr></table></figure></p><p>用DynamicProxy类去包装HelloImpl实例，然后再调用Proxy类的工厂方法newProxyInstance()去动态地创建一个Hello接口的代理类，调用这个代理类的say()方法。</p><p>被代理方法的调用都是通过InvocationHadler的invoke来实现的。</p><p>Proxy.newProxyInstance这个方法的第二个参数，我们给这个代理对象提供了一组什么接口，那么这个代理对象就会实现了这组接口，这个时候我们可以将这个代理对象强制转化为这组接口中的任意一个。</p><p>Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p><p>动态代理，接口变了，这个动态代理类不用动。而静态代理就不一样了，接口变了，代理类也要变。但我也发现动态代理并不是“万灵丹”，它也有搞不定的时候，比如说，我要代理一个没有任何接口的类，它就没有用武之地了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；在实现的过程中，通过传入目标对象（被代理的对象）来辅助完成invoke()方法，同时可以在invoke方法中织入增强逻辑。</li><li>通过Proxy.newProxyInstance来动态创建代理类</li><li>通过代理对象调用目标方法，实际上是通过InvocationHandler实现类的invoke()方法调用</li></ol><p>能否代理没有接口的类?</p><p>CGLib 这个类库。虽然它看起来不太起眼，但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。</p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>Cglib包的底层是通过使用一个小而快的字节码处理框架ASM来转换字节码并生成新的类。对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CGLibProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123;</span><br><span class="line">return (T) Enhancer.create(cls, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">before();</span><br><span class="line">Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">after();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void before() &#123;</span><br><span class="line">System.out.println(&quot;Before&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void after() &#123;</span><br><span class="line">System.out.println(&quot;After&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，值得注意！CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截（这不就是传说中的“方法拦截器”吗？）。</p><p>与 DynamicProxy 类似，我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法，便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGLibProxy cgLibProxy = new CGLibProxy();</span><br><span class="line">HelloImpl helloProxy2 = cgLibProxy.getProxy(HelloImpl.class);</span><br><span class="line">helloProxy2.say(&quot;cg&quot;);</span><br></pre></td></tr></table></figure><p>与 JDK 动态代理不同的是，这里不需要任何的接口信息，对谁都可以生成动态代理对象</p><h2 id="JDK动态代理和CGLIB代理生成的区别"><a href="#JDK动态代理和CGLIB代理生成的区别" class="headerlink" title="JDK动态代理和CGLIB代理生成的区别"></a>JDK动态代理和CGLIB代理生成的区别</h2><ol><li>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</li><li>CGLIB动态代理是利用ASM开源包，将目标对象类的class文件加载进来，通过修改其字节码生成子类来处理。CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。</li><li>JDK动态代理是面向接口的，在创建代理实现类时比CGLIB要快，创建代理速度快。CGLIB动态代理是通过字节码底层继承要代理类的目标类来实现，创建速度没有JDK动态代理快，但是运行速度比JDK动态代理快。</li></ol><p>在Spring AOP中，两种代理技术都有使用，如果目标对象是接口实现类，那么Spring采用JDK动态代理来完成，如果目标对象不是接口实现类，Spring会使用CGLIB来实现动态代理。当然，也可以通过配置文件强制使用CGLIB动态代理。因为在Spring容器中，大多数bean是单例的，所以只创建一次，所以推荐使用CGLIB来代理。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159788" target="_blank" rel="noopener">Proxy 那点事儿 </a></p><p><a href="https://lujunqiu.github.io/2017/12/07/动态代理/" target="_blank" rel="noopener">动态代理</a></p><p><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">java的动态代理机制详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt;类以及&lt;code&gt;java.lang.reflect.InvocationHandler&lt;/code&gt;接口来实现动态代理&lt;/p&gt;
&lt;h2 id=&quot;InvocationHandler&quot;&gt;&lt;a href=&quot;#InvocationHandler&quot; class=&quot;headerlink&quot; title=&quot;InvocationHandler&quot;&gt;&lt;/a&gt;InvocationHandler&lt;/h2&gt;&lt;p&gt;InvocationHandler接口的唯一方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy:    代理类实例&lt;/li&gt;
&lt;li&gt;method:   方法&lt;/li&gt;
&lt;li&gt;args:     方法入参&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://hsb786.github.io/2018/04/14/ThreadLocal/"/>
    <id>https://hsb786.github.io/2018/04/14/ThreadLocal/</id>
    <published>2018-04-14T07:06:57.000Z</published>
    <updated>2018-04-18T11:22:26.009Z</updated>
    
    <content type="html"><![CDATA[<p>早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。</p><a id="more"></a><p>ThreadLocal常用方法：</p><ol><li>public void set(T value)：将值放入线程局部变量中</li><li>public T get()：从线程局部变量中获取值</li><li>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</li><li>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </li></ol><p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要你们来实现的，请给这个线程局部变量一个初始值吧。 </p><h2 id="ThreadLocal简单实现"><a href="#ThreadLocal简单实现" class="headerlink" title="ThreadLocal简单实现"></a>ThreadLocal简单实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;Thread, T&gt; container = Collections.synchronizedMap(new HashMap&lt;Thread, T&gt;());</span><br><span class="line"></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        container.put(Thread.currentThread(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        T value = container.get(thread);</span><br><span class="line">        if (value == null &amp;&amp; !container.containsKey(thread)) &#123;</span><br><span class="line">            value = initialValue();</span><br><span class="line">            container.put(thread, value);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        container.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected T initialValue() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-具体有哪些使用案例呢？"><a href="#ThreadLocal-具体有哪些使用案例呢？" class="headerlink" title="ThreadLocal 具体有哪些使用案例呢？"></a>ThreadLocal 具体有哪些使用案例呢？</h2><p>通过 ThreadLocal 存放 JDBC Connection，以达到事务控制的能力。(每个线程应该拥有自己的连接，而不是共享同一个连接，否则线程1有可能会关闭线程2的连接)</p><p> 注意：当您在一个类中使用了 static 成员变量的时候，一定要多问问自己，这个 static 成员变量需要考虑“线程安全”吗？（也就是说，多个线程需要独享自己的 static 成员变量吗？）如果需要考虑，那就请用 ThreadLocal 吧！ </p><hr><p> <em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/159489" target="_blank" rel="noopener">ThreadLocal 那点事儿</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在 JDK 1.2 的时代，java.lang.ThreadLocal 就诞生了，它是为了解决多线程并发问题而设计的。相当于一个容器，用于存放线程的局部变量，为每一个线程提供了一个独立的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="https://hsb786.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IOC-实现原理（转载）</title>
    <link href="https://hsb786.github.io/2018/04/14/IOC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>https://hsb786.github.io/2018/04/14/IOC-实现原理（转载）/</id>
    <published>2018-04-14T05:22:40.000Z</published>
    <updated>2018-04-14T07:54:10.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部</p></blockquote><p> IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。<br><a id="more"></a><br>从实例出发，先看看以下 Action 代码。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public class ProductAction extends BaseAction &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    private ProductService productService;</span><br><span class="line"></span><br><span class="line">    @Request(&quot;GET:/product/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getProductById(long productId) &#123;</span><br><span class="line">        if (productId == 0) &#123;</span><br><span class="line">            return new Result(ERROR_PARAM);</span><br><span class="line">        &#125;</span><br><span class="line">        Product product = productService.getProduct(productId);</span><br><span class="line">        if (product != null) &#123;</span><br><span class="line">            return new Result(OK, product);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Result(ERROR_DATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上使用了两个自定义注解：@Bean 与 @Inject。<br>在 ProductAction 类上标注了 @Bean 注解，表示该类会交给“容器”处理，以便加入依赖注入框架。</p><p>在 produceService 字段上标注了 @Inject 注解，表示该字段将会被注入进来，而无需 new ProductServiceImpl()，实际上 new 这件事情不是我们做的，而是框架做的，也就是说控制权正好反过来了，所以“依赖注入（DI）”也称作“控制反转（IoC）”。</p><p>那么，应该如何实现依赖注入框架呢？首先还是看看下面的 BeanHelper 类吧。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 遍历 Bean Map</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 获取该接口所有的实现类</span><br><span class="line">                            List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                            if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                // 获取第一个实现类</span><br><span class="line">                                Class&lt;?&gt; implementClass = implementClassList.get(0);</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                beanField.setAccessible(true); // 必须使该字段可访问</span><br><span class="line">                                beanField.set(beanInstance, implementInstance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，依赖注入其实分为两个步骤：1. 通过反射创建实例；2. 获取需要注入的接口实现类并将其赋值给该接口。以上代码中的两个 for 循环就是干这两件事情的。  </p><p>依赖注入框架实现完毕！ </p><p>大家上面看到的 BeanHelper 类，其实兼任了两种职责：1.初始化所有的 Bean 类；2.实现依赖注入。</p><p>这违法了设计模式中的“单一责任原则”，所有有必要将其重构一下，现在的 BeanHelper 类更加苗条了，只是负责初始化 Bean 类而已。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BeanHelper &#123;</span><br><span class="line"></span><br><span class="line">    // Bean 类 =&gt; Bean 实例</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, Object&gt; beanMap = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean（带有 @Bean 注解的类）</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; beanClassList = ClassHelper.getClassListByAnnotation(Bean.class);</span><br><span class="line">            for (Class&lt;?&gt; beanClass : beanClassList) &#123;</span><br><span class="line">                // 创建 Bean 实例</span><br><span class="line">                Object beanInstance = beanClass.newInstance();</span><br><span class="line">                // 将 Bean 实例放入 Bean Map 中（键为 Bean 类，值为 Bean 实例）</span><br><span class="line">                beanMap.put(beanClass, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Map&lt;Class&lt;?&gt;, Object&gt; getBeanMap() &#123;</span><br><span class="line">        return beanMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        return (T) beanMap.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，依赖注入功能放哪里呢？我搞了一个 IOCHelper，用这个类来实现 IOC 功能。代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class IOCHelper &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取并遍历所有的 Bean 类</span><br><span class="line">            Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; beanEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                // 获取 Bean 类与 Bean 实例</span><br><span class="line">                Class&lt;?&gt; beanClass = beanEntry.getKey();</span><br><span class="line">                Object beanInstance = beanEntry.getValue();</span><br><span class="line">                // 获取 Bean 类中所有的字段（不包括父类中的方法）</span><br><span class="line">                Field[] beanFields = beanClass.getDeclaredFields();</span><br><span class="line">                if (ArrayUtil.isNotEmpty(beanFields)) &#123;</span><br><span class="line">                    // 遍历所有的 Bean 字段</span><br><span class="line">                    for (Field beanField : beanFields) &#123;</span><br><span class="line">                        // 判断当前 Bean 字段是否带有 @Inject 注解</span><br><span class="line">                        if (beanField.isAnnotationPresent(Inject.class)) &#123;</span><br><span class="line">                            // 获取 Bean 字段对应的接口</span><br><span class="line">                            Class&lt;?&gt; interfaceClass = beanField.getType();</span><br><span class="line">                            // 判断接口上是否标注了 @Impl 注解</span><br><span class="line">                            Class&lt;?&gt; implementClass = null;</span><br><span class="line">                            if (interfaceClass.isAnnotationPresent(Impl.class)) &#123;</span><br><span class="line">                                // 获取强制指定的实现类</span><br><span class="line">                                implementClass = interfaceClass.getAnnotation(Impl.class).value();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                // 获取该接口所有的实现类</span><br><span class="line">                                List&lt;Class&lt;?&gt;&gt; implementClassList = ClassHelper.getClassListByInterface(interfaceClass);</span><br><span class="line">                                if (CollectionUtil.isNotEmpty(implementClassList)) &#123;</span><br><span class="line">                                    // 获取第一个实现类</span><br><span class="line">                                    implementClass = implementClassList.get(0);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 若存在实现类，则执行以下代码</span><br><span class="line">                            if (implementClass != null) &#123;</span><br><span class="line">                                // 从 Bean Map 中获取该实现类对应的实现类实例</span><br><span class="line">                                Object implementInstance = beanMap.get(implementClass);</span><br><span class="line">                                // 设置该 Bean 字段的值</span><br><span class="line">                                if (implementInstance != null) &#123;</span><br><span class="line">                                    beanField.setAccessible(true); // 取消类型安全检测（可提高反射性能）</span><br><span class="line">                                    beanField.set(beanInstance, implementInstance); // beanInstance 是普通实例，或 CGLib 动态代理实例（不能使 JDK 动态代理实例）</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可见，IOCHelper 是依赖于 BeanHelper 的。这样分离，还有一个好处，就是方便实现 ServiceHelper 与 AOPHelper。也就是说，首先通过 BeanHelper 初始化所有的 Bean 类，然后依次初始化 ServiceHelper、IOCHelper、AOPHelper，这个顺序不能搞错。因为在 ServcieHelper 中，对 Servcie 实现类进行了动态代理，所有保证了 IOC 注入进来的是代理类，而并非目标类。 </p><hr><p><em>参考</em></p><blockquote><p><a href="https://my.oschina.net/huangyong/blog/158992" target="_blank" rel="noopener">IOC 实现原理 </a></p><p><a href="https://my.oschina.net/flashsword/blog/192551" target="_blank" rel="noopener">1000行代码读懂Spring（一）- 实现一个基本的IoC容器 </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来想研究一下Spring源码的，奈何自己太渣，看了一下代码，发现层次太多，感觉无从下手，之后发现了这篇博客，寥寥几行代码就把IOC实现了。链接放在底部，也可以看下 黄亿华分析的，同样在底部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; IOC 也就是“控制反转”了，不过更流行的叫法是“依赖注入”（DI - Dependency Injection）。听起来挺高深，其实实现起来并不复杂。下面就看看如何来实现这个轻量级 IOC 框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://hsb786.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://hsb786.github.io/2018/04/14/Servlet/"/>
    <id>https://hsb786.github.io/2018/04/14/Servlet/</id>
    <published>2018-04-14T04:35:27.000Z</published>
    <updated>2018-04-18T04:19:23.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet概述"><a href="#Servlet概述" class="headerlink" title="Servlet概述"></a>Servlet概述</h2><p>Servlet是在Java中创建web应用程序的J2ee 服务端技术。<code>javax.servlet</code> 和 <code>javax.servlet.http</code>包中提供了编写servlet的接口和类。所有的servlet都要实现<code>javax.servlet.Servlet</code>接口。该接口中定义了一个Servlet生命周期中的所有方法。</p><p>Servlet接口定义了Servlet与Servlet容器之间的契约，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法。在一个应用程序中，每种Servlet类型只有一个实例。</p><p>用户请求指使Servlet容器调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例。<br><a id="more"></a><br>对于每个应用程序，Servlet容器还会创建一个ServletContext实例，封装了上下文（应用程序的环境详情）。每个上下文只有一个ServletContext，每个Servlet实例也都有一个封装Servlet配置的ServletConfig。</p><p>多数情况下，web应用程序都使用http协议，所以，我们多数时候都通过继承<code>HttpServlet</code>类来实现自己的Servlet。</p><h2 id="Servlet-API的层次结构"><a href="#Servlet-API的层次结构" class="headerlink" title="Servlet API的层次结构"></a>Servlet API的层次结构</h2><p><code>javax.servlet.Servlet</code>是Servlet Api的最上层接口。还有一些其他的接口和类是我们在使用servlet的时候需要关注的。</p><p><img src="/images/Servlet-Hierarchy.png" alt="servlet API层次结构"></p><h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p><code>javax.servlet.Servlet</code> 是Servlet Api的最上层接口，Servlet接口定义了一系列servlet的生命周期方法（init、service、destory等）。所有的Servlet类都需要继承这个接口。该接口中定义了以下方法：</p><p><code>public abstract void init(ServletConfig paramServletConfig) throws ServletException</code>  该方法由servlet容器调用，用于初始化servlet以及servlet配置参数。在init()方法执行之前，servlet是无法处理用户请求的。在servlet生命周期中该方法只会被调用一次，他会使servlet类不同区别于普通的java对象。我们可以扩展该方法来初始化资源，如数据库连接、socket连接等。</p><p><code>public abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException</code>  该方法负责处理客户端请求。当servlet容器收到客户端请求时，它会创建一个新线程并执行service()方法，并把request 和 response作为参数传递给该方法。servlet通常运行在多线程环境中，所以开发人员应该使用同步来保证访问共享资源的线程安全性问题。</p><p><code>public abstract void destroy()</code>  该方法在整个servlet生命周期中只会被调用一次来关闭所有资源。有点像Java中的finalize方法。</p><p><code>public abstract ServletConfig getServletConfig()</code>  该方法返回一个servlet配置对象，其中包含servlet中所有初始化参数和启动配置。我们可以用这个方法来获取servlet的初始化参数，这些参数一般被定义在web.xml或servlet 3的注解中。后面会介绍ServletConfig接口。</p><p><code>public abstract String getServletInfo()</code>  该方法返回包含servlet信息的字符串，比如它的作者、版本和版权。返回的字符串应该是纯文本，不能有标记符号。</p><h2 id="ServletConfig-接口"><a href="#ServletConfig-接口" class="headerlink" title="ServletConfig 接口"></a>ServletConfig 接口</h2><p><code>javax.servlet.ServletConfig</code>用于给servlet传递配置信息。每个servlet都有属于它自己的ServletConfig对象，该对象由servlet容器负责实例化。</p><h2 id="ServletContext-接口"><a href="#ServletContext-接口" class="headerlink" title="ServletContext 接口"></a>ServletContext 接口</h2><p><code>javax.servlet.ServletContext</code>接口用于描述应用程序的相关信息。ServletContext是一个独立的对象，可用于web应用程序中所有的servlet。当我们想要一些初始化的参数可用于web应用程序中多个或全部servlet时，我们可以使用ServletContext对象并且在web.xml中使用&lt; context-param&gt;标签定义参数。</p><h2 id="ServletRequest-接口"><a href="#ServletRequest-接口" class="headerlink" title="ServletRequest 接口"></a>ServletRequest 接口</h2><p>ServletRequest接口是用来向servlet提供客户端请求信息。每一个客户端请求到达Servlet容器的时候，他都会创建一个ServletRequest对象，并将其传递对应的servlet的service()方法。</p><p><code>Object getAttribute(String name)</code>  返回指定的参数名对应的属性值。如果对应的参数不存在则返回null。</p><p><code>String getParameter(String name)</code>  以字符串的形式返回请求参数值。</p><blockquote><p>attribute和parameter的区别是什么呢？</p><p>来源不同</p><blockquote><p>   参数（parameter）是从客户端（浏览器）中由用户提供的，若是GET方法是从URL中 提供的，若是POST方法是从请求体（request body）中提供的；</p><p>   属性（attribute）是服务器端的组件（JSP或者Servlet）利用requst.setAttribute（）设置的.</p></blockquote><p>操作不同</p><blockquote><p>   参数（parameter）的值只能读取不能修改，读取可以使用request.getParameter()读取；</p><p>   属性（attribute）的值既可以读取亦可以修改，读取可以使用request.setAttribute(),设置可使用request.getAttribute()</p></blockquote><p>数据类型不同</p><blockquote><p>   参数（parameter）不管前台传来的值语义是什么，在服务器获取时都以String类型看待，并且客户端的参数值只能是简单类型的值，不能是复杂类型，比如一个对象。</p><p>   属性（attribute）的值可以是任意一个Object类型。</p></blockquote></blockquote><h2 id="ServletResponse-接口"><a href="#ServletResponse-接口" class="headerlink" title="ServletResponse 接口"></a>ServletResponse 接口</h2><p>servlet使用ServletResponse向客户端发送响应。和ServletRequest类似，一个客户端请求到达Servlet容器的时候，他都会创建一个ServletResponse对象，并将其传递对应的servlet的service()方法。最终，该response对象用于给客户端生成html响应。</p><h2 id="RequestDispatcher-接口"><a href="#RequestDispatcher-接口" class="headerlink" title="RequestDispatcher 接口"></a>RequestDispatcher 接口</h2><p>RequestDispatcher 接口用于把一个请求转发给同一个servlet上下文中的其他的资源（Html、jsp、servlet）来处理。也可以用它来把另一个资源的内容包含到响应中。此接口用于同一个servlet上下文中的servlet相互沟通。</p><p>RequestDispatcher 接口的主要方法： <code>void forward(ServletRequest request, ServletResponse response)</code>  把一个servlet的请求转发到服务器上的其他资源中（Html、jsp、servlet）。</p><p><code>void include(ServletRequest request, ServletResponse response)</code>  把另一个资源的内容包含到当前响应中。</p><blockquote><p>forward和include的区别：</p><p>如果使用forward跳转，forward语句后面的response输出则不会执行，会跳转到forward指定的servlet中去执行。</p><p>用include来跳转，则include的servlet执行完后，再返回到原来的servlet执行forward语句后面的response的输出。</p></blockquote><p>在servlet中可以使用<code>getRequestDispatcher(String path)</code>来获取一个RequestDispatcher。路径必须以/开头，并且是针对于当前context的根路径的相对地址。</p><h2 id="HTTPSession"><a href="#HTTPSession" class="headerlink" title="HTTPSession"></a>HTTPSession</h2><p>HTTPSession对象在用户第一次访问网站的时候自动创建，可以通过HttpServletRequest的getSession方法获取该对象，一个用户最多只能有一个HttpSession，放入到HttpSession的值，是存储在内存中的，也可以在服务器转储到二级缓存中。放到HttpSession的值不限于String类型，可以是任意实现java.io.Serializale的java对象。</p><p>所有保存在HttpSession的数据不会被发送到客户端，Servlet容器为每个HttpSession生成唯一的标识，并将该标识发送给浏览器，或创建一个名为JSESSIONNID的cookie，或者在URL后面附加一个名为jessionid的参数，在后续的请求中，浏览器只需要将标识id放送给服务器即可。</p><hr><p><em>参考</em></p><blockquote><p><a href="http://www.hollischuang.com/archives/1219" target="_blank" rel="noopener">[译]Java Servlet初级知识</a></p><p><a href="https://lujunqiu.github.io/2017/10/19/Servlet学习笔记/" target="_blank" rel="noopener">Servlet学习笔记</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Servlet概述&quot;&gt;&lt;a href=&quot;#Servlet概述&quot; class=&quot;headerlink&quot; title=&quot;Servlet概述&quot;&gt;&lt;/a&gt;Servlet概述&lt;/h2&gt;&lt;p&gt;Servlet是在Java中创建web应用程序的J2ee 服务端技术。&lt;code&gt;javax.servlet&lt;/code&gt; 和 &lt;code&gt;javax.servlet.http&lt;/code&gt;包中提供了编写servlet的接口和类。所有的servlet都要实现&lt;code&gt;javax.servlet.Servlet&lt;/code&gt;接口。该接口中定义了一个Servlet生命周期中的所有方法。&lt;/p&gt;
&lt;p&gt;Servlet接口定义了Servlet与Servlet容器之间的契约，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法。在一个应用程序中，每种Servlet类型只有一个实例。&lt;/p&gt;
&lt;p&gt;用户请求指使Servlet容器调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例。&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="https://hsb786.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何重置一个ArrayList--clear vs removeAll （转载）</title>
    <link href="https://hsb786.github.io/2018/04/13/%E8%AF%91-%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AE%E4%B8%80%E4%B8%AAArrayList-clear-vs-removeAll/"/>
    <id>https://hsb786.github.io/2018/04/13/译-如何重置一个ArrayList-clear-vs-removeAll/</id>
    <published>2018-04-13T07:55:17.000Z</published>
    <updated>2018-04-13T08:01:13.361Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置<code>clear</code>或<code>removeAll</code>。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现<code>java.lang.OutOfMemoryError: Java Heap Space</code>。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。<br><a id="more"></a></p><h2 id="Clear-vs-RemoveAll-Collection-c"><a href="#Clear-vs-RemoveAll-Collection-c" class="headerlink" title="Clear() vs RemoveAll(Collection c)"></a>Clear() vs RemoveAll(Collection c)</h2><p>为了更好的比较这两个方法，阅读他们源码是很重要的。可以在<code>java.utils.ArrayList</code>类中找到clear()方法，不过为了方便我将它引入到了这里。下面的代码来自JDK 1.7.0_40版本。如果你想要学习更多的有关性能监控和调优的知识，我强烈建议阅读Scott Oaks写的Java Performance the Definitive Guide,它包含了java 7和一点java 8。下面是clear()的代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Removes all of the elements from this list.The list will </span><br><span class="line"> * be empty after this call returns. </span><br><span class="line"> */ </span><br><span class="line"> public void clear() &#123; </span><br><span class="line"> modCount++; // clear to let GC do its work </span><br><span class="line"> for (int i = 0; i &lt; size; i++) </span><br><span class="line"> elementData[i] = null; </span><br><span class="line"> size = 0; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>大家可以看出，clear()在循环遍历ArrayList，并且将每一个元素都置为null，使它们在没有被外部引用的情况下可以被垃圾回收。相似的，我们可以在<code>java.util.AbstractCollection</code>类中查看removeAll(Collention c)的代码，下面是代码片段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">//判断对象是否为null</span><br><span class="line">      Objects.requireNonNull(c);</span><br><span class="line">      boolean modified = false;</span><br><span class="line">      Iterator&lt;?&gt; it = iterator();</span><br><span class="line">      while (it.hasNext()) &#123;</span><br><span class="line">          if (c.contains(it.next())) &#123;</span><br><span class="line">              it.remove();</span><br><span class="line">              modified = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return modified;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  这个方法会检查迭代器顺序返回的每个元素是否包含在特定的集合中。如果存在，调用迭代器的remove方法将它从集合中移除。因为会用到contains方法，removeAll的复杂度是O(n^2)。所以在想要重置一个大的ArrayList时，这种方法是绝对不可取的。下面我们比较一下两者在重置一个包含100K个元素时的性能差异。</p><h2 id="删除一个包含100k个元素的列表中的所有元素"><a href="#删除一个包含100k个元素的列表中的所有元素" class="headerlink" title="删除一个包含100k个元素的列表中的所有元素"></a>删除一个包含100k个元素的列表中的所有元素</h2><p>  我本来想在例子中尝试重置一个包含10M个元素的列表，不过在超过半个小时等待removeAll()结束后，我决定将元素的数量降为100K。在这种情况下，两个方法的差距也是很明显的。removeAll()比clear()多花费了10000倍的时间。事实上，在API中clear()和removeAll(Collection c)这两个方法的目的是不同的。clear()方法是为了通过删除所有元素而重置列表，而removeAll(Collection c)是为了从集合中删除某些存在于另一个提供的集合中的元素，并不是为了从集合中移除所有元素。所以如果你的目的是删除所有元素，用clear(),如果你的目的是删除某些存在于另一集合的元素，那么选择removeAll(Collection c)方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList; </span><br><span class="line">/**</span><br><span class="line"> * Java Program to remove all elements from list in Java and comparing </span><br><span class="line"> * performance of clearn() and removeAll() method. </span><br><span class="line"> * * @author Javin Paul </span><br><span class="line"> */ </span><br><span class="line"> public class ArrayListResetTest &#123; </span><br><span class="line"> </span><br><span class="line"> private static final int SIZE = 100_000; </span><br><span class="line"> public static void main(String args[]) &#123; </span><br><span class="line"> </span><br><span class="line"> // Two ArrayList for clear and removeAll </span><br><span class="line"> ArrayList numbers = new ArrayList(SIZE); </span><br><span class="line"> ArrayList integers = new ArrayList(SIZE); </span><br><span class="line"> // Initialize ArrayList with 10M integers </span><br><span class="line"> for (int i = 0; i &amp;lt; SIZE; i++) &#123; </span><br><span class="line"> numbers.add(new Integer(i)); </span><br><span class="line"> integers.add(new Integer(i)); </span><br><span class="line"> &#125; </span><br><span class="line"> // Empty ArrayList using clear method </span><br><span class="line"> long startTime = System.nanoTime(); </span><br><span class="line"> numbers.clear(); </span><br><span class="line"> long elapsed = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by clear to empty ArrayList of 1M elements (ns): &quot; + elapsed); </span><br><span class="line"> // Reset ArrayList using removeAll method </span><br><span class="line"> startTime = System.nanoTime(); </span><br><span class="line"> integers.removeAll(integers); </span><br><span class="line"> long time = System.nanoTime() - startTime; </span><br><span class="line"> System.out.println(&quot;Time taken by removeAll to reset ArrayList of 1M elements (ns): &quot; + time); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> Output: </span><br><span class="line"> Time taken by clear to empty ArrayList of 100000 elements (ns): 889619 </span><br><span class="line"> Time taken by removeAll to reset ArrayList of 100000 elements (ns): 36633112126</span><br></pre></td></tr></table></figure><p>  由于程序使用了两个arrayList存储Integers，所以在运行时要确保有足够的内存，尤其是你想比较在列表存有1M个元素时，两种方法的性能差异。另外，由于使用了在数字中加入下划线的特性，所以需要java7来运行。如果没有JDK7，也可以移除SIZE常量中的下划线。</p><hr><p><em>参考</em></p><blockquote><p><a href="https://yemengying.com/2015/10/26/译-如何重置一个ArrayList-clear-vs-removeAll/" target="_blank" rel="noopener"> 【译】如何重置一个ArrayList–clear vs removeAll </a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候为了重用我们会想要重置一个ArrayList，这里的重置是指清空列表或移除列表所有的元素。在Java中，有两个方法可以帮助我们实现重置&lt;code&gt;clear&lt;/code&gt;或&lt;code&gt;removeAll&lt;/code&gt;。在列表长度很小的情况下(eg:10或100个元素)，可以放心的使用这两种方法。但如果列表很大(eg:10M个元素)，那么选择clear还是removeAll会对你java应用的性能造成巨大的影响。甚至有时，在列表过大的情况下，重置会耗费许多时间，那么重新创建一个新的列表比将老的列表重置要好。但需要提醒的是，必须要确保老的列表可以被垃圾回收，否则，有很大的风险会出现&lt;code&gt;java.lang.OutOfMemoryError: Java Heap Space&lt;/code&gt;。言归正传，让我们看看clear()和removeAll()两个方法。大家应该常常会选择用clear(),因为他的复杂度是O(n),而相比之下，removeAll(Collection C)的性能要差一些，它的复杂度是O(n^2)。这也是为什么在重置大的列表的时候两个方法会有巨大的差异。如果阅读他们的源码并运行下面的例子程序，差异会更明显。&lt;br&gt;
    
    </summary>
    
    
      <category term="爪哇" scheme="https://hsb786.github.io/tags/%E7%88%AA%E5%93%87/"/>
    
  </entry>
  
</feed>
