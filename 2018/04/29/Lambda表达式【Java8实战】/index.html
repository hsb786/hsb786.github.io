<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>Lambda表达式【Java8实战】 | HuShengBin’s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。">
<meta name="keywords" content="爪哇">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda表达式【Java8实战】">
<meta property="og:url" content="https://hsb786.github.io/2018/04/29/Lambda表达式【Java8实战】/index.html">
<meta property="og:site_name" content="HuShengBin’s blog">
<meta property="og:description" content="Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hsb786.github.io/images/lambda01.png">
<meta property="og:updated_time" content="2018-04-29T07:50:05.467Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lambda表达式【Java8实战】">
<meta name="twitter:description" content="Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。">
<meta name="twitter:image" content="https://hsb786.github.io/images/lambda01.png">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                
                <span class="site-title">HuShengBin’s blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/txx.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/txx.jpg" />
            <h2 id="name">hushengbin</h2>
            <h3 id="title">JavaWeb Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Nanchang, Jiangxi, China</span>
            <a id="follow" target="_blank" href="https://github.com/hsb786">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                71
                <span>文章</span>
            </div>
            <div class="article-info-block">
                14
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/hsb786" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-Lambda表达式【Java8实战】" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Lambda表达式【Java8实战】
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/04/29/Lambda表达式【Java8实战】/">
            <time datetime="2018-04-29T05:53:37.000Z" itemprop="datePublished">2018-04-29</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/爪哇/">爪哇</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/爪哇/Java8实战/">Java8实战</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/爪哇/">爪哇</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>Lambda表达式，简洁地表示一个行为或传递代码。你可以把Lambda表达式看作匿名函数，它基本上就是没有声明名称的方法，但和匿名类一样，它可以作为参数传递给一个方法。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>匿名——它不像普通的方法那样有一个明确的名称</li>
<li>函数——Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表</li>
<li>传递——Lambda表达式可以作为参数传递给方法或存储在变量中</li>
<li>简洁——无需像匿名类那样写很多模块代码</li>
</ul>
<p>Lambda表达式有三个部分：</p>
<ul>
<li>参数列表</li>
<li>箭头</li>
<li>Lambda主体</li>
</ul>
<p>基本语法：</p>
<ul>
<li>(parameters) -&gt;  expression</li>
<li>(parameters) -&gt;   { statements; }</li>
</ul>
<ul>
<li>() -&gt; “Raoul”</li>
<li>() -&gt; { return “Raoul”; }<br>Lambda隐含return，你也可以显式返回语句</li>
</ul>
<p>Lambda实例：</p>
<table>
<thead>
<tr>
<th>使用案例</th>
<th>Lambda实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔表达式</td>
<td>(List<string> list) -&gt; list.isEmpty()</string></td>
</tr>
<tr>
<td>创建对象</td>
<td>() -&gt; new Apple(10)</td>
</tr>
<tr>
<td>消费一个对象</td>
<td>(Apple a) -&gt; {  System.out.println(a.getWeight());  }</td>
</tr>
<tr>
<td>从一个对象中选择/抽取</td>
<td>(String s) -&gt; s.length()</td>
</tr>
<tr>
<td>组合两个值</td>
<td>(int a,int b) -&gt; a*b</td>
</tr>
<tr>
<td>比较两个对象</td>
<td>(Apple a2,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</td>
</tr>
</tbody>
</table>
<p><strong>可以在函数式接口上使用Lambda表达式</strong></p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>函数式接口就是只定义了一个抽象方法的接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//java.util.Comparator</span><br><span class="line">public interface Comparator&lt;T&gt; &#123; </span><br><span class="line">    int compare(T o1, T o2);  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//java.lang.Runnable</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">    void run(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口一个具体实现的实例）</strong>。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后再直接内联将它实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用Lambda</span><br><span class="line">Runnable r1 = () -&gt; System.out.println(&quot;Hello World 1&quot;);</span><br><span class="line"></span><br><span class="line">//使用匿名类</span><br><span class="line">Runnable r2 = new Runnable()&#123;  </span><br><span class="line">    public void run()&#123; </span><br><span class="line">        System.out.println(&quot;Hello World 2&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p><strong>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，我们将这种抽象方法叫做函数描述符。</strong>例如，Runnable接口可以看作一个什么也不接受什么也不返回（void）的函数的签名，因为它只有一个叫作run的抽象方法，这个方法什么也不接受，什么也不返回。</p>
<p><strong>Lambda表达式可以被赋给一个变量，或传递给一个接受函数式接口作为参数的方法</strong></p>
<p>@FunctionalInterface<br>用于表示该接口会设计成一个函数式接口。</p>
<h3 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h3><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>java.util.function.Predicate<t>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; </span><br><span class="line">    List&lt;T&gt; results = new ArrayList&lt;&gt;(); </span><br><span class="line">    for(T s: list)&#123; </span><br><span class="line">        if(p.test(s))&#123; </span><br><span class="line">            results.add(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return results; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty(); </span><br><span class="line">List&lt;String&gt; nonEmpty = filter(listOfStrings,nonEmptyStringPredicate);</span><br></pre></td></tr></table></figure>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>java.util.function.Consumer<t>定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface Consumer&lt;T&gt;&#123; </span><br><span class="line">    void accept(T t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123; </span><br><span class="line">        for(T i: list)&#123; </span><br><span class="line">        c.accept(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">forEach( Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.println(i) );</span><br></pre></td></tr></table></figure>
<h4 id="java-util-function-Function-lt-T-R-gt"><a href="#java-util-function-Function-lt-T-R-gt" class="headerlink" title="java.util.function.Function&lt;T, R&gt;"></a>java.util.function.Function&lt;T, R&gt;</h4><p>接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface Function&lt;T, R&gt;&#123; </span><br><span class="line">    R apply(T t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, </span><br><span class="line">                                 Function&lt;T, R&gt; f) &#123; </span><br><span class="line">    List&lt;R&gt; result = new ArrayList&lt;&gt;(); </span><br><span class="line">    for(T s: list)&#123; </span><br><span class="line">        result.add(f.apply(s)); </span><br><span class="line">    &#125; </span><br><span class="line">    return result; </span><br><span class="line">&#125; </span><br><span class="line">// [7, 2, 6] </span><br><span class="line">List&lt;Integer&gt; l = map( </span><br><span class="line">                       Arrays.asList(&quot;lambdas&quot;,&quot;in&quot;,&quot;action&quot;), </span><br><span class="line">                       (String s) -&gt; s.length() </span><br><span class="line">               );</span><br></pre></td></tr></table></figure>
<p>Lambdas及函数式接口的例子：</p>
<table>
<thead>
<tr>
<th>使用案例</th>
<th>Lambda实例</th>
<th>对应的函数式接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔表达式</td>
<td>(List<string> list) -&gt; list.isEmpty()</string></td>
<td>Predicate&lt;List<string>&gt;</string></td>
</tr>
<tr>
<td>创建对象</td>
<td>() -&gt; new Apple(10)</td>
<td>Supplier<apple></apple></td>
</tr>
<tr>
<td>消费一个对象</td>
<td>(Apple a) -&gt; {  System.out.println(a.getWeight());  }</td>
<td>Consumer<apple></apple></td>
</tr>
<tr>
<td>从一个对象中选择/抽取</td>
<td>(String s) -&gt; s.length()</td>
<td>Function&lt;String,Integer&gt;或ToIntFunction<string></string></td>
</tr>
<tr>
<td>组合两个值</td>
<td>(int a,int b) -&gt; a*b</td>
<td>IntBinaryOperator</td>
</tr>
<tr>
<td>比较两个对象</td>
<td>(Apple a2,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</td>
<td>Comparator<apple>或BiFunction&lt;Apple, Apple, Integer&gt;或ToIntBiFunction&lt;Apple, Apple&gt; </apple></td>
</tr>
</tbody>
</table>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>请注意，任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要Lambda表达式来抛出异常，有两种办法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda包在一个try/catch块中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface BufferedReaderProcessor &#123; </span><br><span class="line">    String process(BufferedReader b) throws IOException; </span><br><span class="line">&#125; </span><br><span class="line">BufferedReaderProcessor p = (BufferedReader br) -&gt; br.readLine();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        return b.readLine(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch(IOException e) &#123; </span><br><span class="line">        throw new RuntimeException(e); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>Lambda表达式本身并不包含它在实现哪个函数式接口的信息。</p>
<p>Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型</p>
<p><img src="/images/lambda01.png" alt=""></p>
<ul>
<li>首先，你要找出filter方法的声明。</li>
<li>第二，要求它是Predicate<apple>（目标类型）对象的第二个正式参数。</apple></li>
<li>第三，Predicate<apple>是一个函数式接口，定义了一个叫作test的抽象方法。</apple></li>
<li>第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean。</li>
<li>最后，filter的任何实际参数都必须匹配这个要求。</li>
</ul>
<h3 id="同样的Lambda，不同的函数式接口"><a href="#同样的Lambda，不同的函数式接口" class="headerlink" title="同样的Lambda，不同的函数式接口"></a>同样的Lambda，不同的函数式接口</h3><p>有了目标类型的概念，同一个Lambda表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。比如，前面提到的Callable和PrivilegedAction，这两个接口都代表着什么也不接受且返回一个泛型T的函数。因此，下面两个赋值是有效的：</p>
<pre><code>Callable&lt;Integer&gt; c = () -&gt; 42; 
PrivilegedAction&lt;Integer&gt; p = () -&gt; 42; 
</code></pre><p>第一个赋值的目标类型是Callable<integer>，第二个赋值的目标类型是PrivilegedAction<integer></integer></integer></p>
<p>菱形运算符<br>Java 7中已经引入了菱形运算符（&lt;&gt;），利用泛型推断从上下文推断类型的思想（这一思想甚至可以追溯到更早的泛型方法）。一个类实例表达式可以出现在两个或更多不同的上下文中，并会像下面这样推断出适当的类型参数：<br>        List<string> listOfStrings = new ArrayList&lt;&gt;();<br>        List<integer> listOfIntegers = new ArrayList&lt;&gt;(); </integer></string></p>
<p>特殊的void兼容规则<br>如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的，尽管List的add方法返回了一个boolean，而不是Consumer上下文（T -&gt; void）所要求的void：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Predicate返回了一个boolean </span><br><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s); </span><br><span class="line">// Consumer返回了一个void  </span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure></p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Java编译器会从上下文（目标类型）推断出用什么函数式接来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。换句话说，Java编译器会像下面这样推断Lambda的参数类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//参数a没有显式类型</span><br><span class="line">List&lt;Apple&gt; greenApples = </span><br><span class="line">     filter(inventory, a -&gt; &quot;green&quot;.equals(a.getColor())); </span><br><span class="line"></span><br><span class="line">//没有类型推断</span><br><span class="line">Comparator&lt;Apple&gt; c = </span><br><span class="line">    (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); </span><br><span class="line"></span><br><span class="line">//有类型推断</span><br><span class="line">Comparator&lt;Apple&gt; c = </span><br><span class="line">    (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><p>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><strong>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。</strong></p>
<p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。<strong>事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。</strong>但是，显式地指明方法的名称，你的代码的可读性会更好。它是如何工作的呢？当你需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。例如，<strong>Apple::getWeight就是引用了Apple类中定义的方法getWeight。请记住，不需要括号，因为你没有实际调用这个方法。</strong>方法引用就是Lambda表达式(Apple a) -&gt; a.getWeight()的快捷写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; str = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;A&quot;,&quot;B&quot;); </span><br><span class="line">str.sort((s1, s2) -&gt; s1.compareToIgnoreCase(s2));</span><br></pre></td></tr></table></figure>
<p>Lambda表达式的签名与Comparator的函数描述符兼容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; str = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;A&quot;,&quot;B&quot;); </span><br><span class="line">str.sort(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h3><p>对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。例如，假设有一个构造函数没有参数。它适合Supplier的签名() -&gt; Apple。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::new; </span><br><span class="line">Apple a1 = c1.get(); </span><br><span class="line">//等价于</span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; new Apple(); </span><br><span class="line">Apple a1 = c1.get();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c2 = Apple::new;</span><br><span class="line">Apple a2 = c2.apply(110);</span><br><span class="line">//等价于</span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = (weight) -&gt; new Apple(weight);</span><br><span class="line">Apple a2 = c2.apply(110);</span><br></pre></td></tr></table></figure>
<p>Comparator具有一个叫作comparing的静态辅助方法，它可以接受一个Function来提取Comparable键值，并生成一个Comparator对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); </span><br><span class="line"></span><br><span class="line">Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a) -&gt; a.getWeight()); </span><br><span class="line"></span><br><span class="line">import static java.util.Comparator.comparing; </span><br><span class="line">inventory.sort(comparing((a) -&gt; a.getWeight()));</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表</li>
<li>Lambda表达式让你可以简洁地传递代码</li>
<li>函数式接口就是仅仅声明了一个抽象方法的接口</li>
<li>只有在接受函数式接口的地方才可以使用Lambda表达式</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实行，并且将整个表达式作为函数式接口的一个实例</li>
<li>Java8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate<t>、Function&lt;T,R&gt;、Supplier<t>、Consumer<t>和BinaryOperator<t></t></t></t></t></li>
<li>为了避免装箱操作，对Predicate<t>和Function&lt;T,R&gt;等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等</t></li>
<li>Lambda表达式所需要代表的类型称为目标类型</li>
<li>方法引用让你重复使用现有的方法实现并直接传递它们</li>
<li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认返回</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://hsb786.github.io/2018/04/29/Lambda表达式【Java8实战】/" data-id="cjgmae6v9001m5gmy3vq4wa2z" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/04/30/流【Java8实战】/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    流【Java8实战】
                
            </div>
        </a>
    
    
        <a href="/2018/04/29/java8实战-行为参数化/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">行为参数化【java8实战】</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
    <div id="valine-thread"></div>
</section>
    

</section>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 HuShengBin<br>
    </div>
</footer>
        
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.6/dist/Valine.min.js"></script>
    <script>
        new Valine({
            el: '#valine-thread' ,
            notify:false,
            verify:false,
            app_id: 'eqjWlM0tCYgxhh8nvvV6DleG-gzGzoHsz',
            app_key: 'CRXn0n9IAsJdOeMDUIxyh1Hb',
            placeholder: '(。・∀・)ノ说一句吧'
        });
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>