<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>java8新特性（转载） | HuShengBin’s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。">
<meta name="keywords" content="爪哇">
<meta property="og:type" content="article">
<meta property="og:title" content="java8新特性（转载）">
<meta property="og:url" content="https://hsb786.github.io/2018/04/12/java8新特性（转载）/index.html">
<meta property="og:site_name" content="HuShengBin’s blog">
<meta property="og:description" content="Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://hsb786.github.io/images/java8.jpg">
<meta property="og:updated_time" content="2018-04-12T11:46:36.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java8新特性（转载）">
<meta name="twitter:description" content="Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。">
<meta name="twitter:image" content="https://hsb786.github.io/images/java8.jpg">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                
                <span class="site-title">HuShengBin’s blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/txx.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/txx.jpg" />
            <h2 id="name">hushengbin</h2>
            <h3 id="title">JavaWeb Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Nanchang, Jiangxi, China</span>
            <a id="follow" target="_blank" href="https://github.com/hsb786">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                40
                <span>文章</span>
            </div>
            <div class="article-info-block">
                10
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/hsb786" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-java8新特性（转载）" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            java8新特性（转载）
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/04/12/java8新特性（转载）/">
            <time datetime="2018-04-12T07:56:55.000Z" itemprop="datePublished">2018-04-12</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/爪哇/">爪哇</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>Java 8带来了很多的新特性，包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。<br><img src="/images/java8.jpg" alt=""><br><a id="more"></a></p>
<h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><p>Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">    double calculate(int a);</span><br><span class="line"></span><br><span class="line">    default double sqrt(int a) &#123;</span><br><span class="line">        return Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt.Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = new Formula() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double calculate(int a) &#123;</span><br><span class="line">        return sqrt(a * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(100);     // 100.0</span><br><span class="line">formula.sqrt(16);           // 4.0</span><br></pre></td></tr></table></figure>
<p>那么这个新特征有啥用呢？</p>
<p>我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类，那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法，那么我们需要去重写每个实现了这个接口的类，而这大大增加了我们的实现需求的负担。</p>
<p>正是为了解决Java接口中只能定义抽象方法的问题。Java8新增加了默认方法的特性。默认方法可以被继承接口重写成抽象方法或者重新定义成默认方法。除了默认方法，接口里还可以声明静态方法，并且可以实现。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private interface DefaulableFactory &#123;</span><br><span class="line">    // Interfaces now allow static methods</span><br><span class="line">    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h2><p>因为一个类可以实现多个接口，所以当一个类实现了多个接口，而这些接口中存在两个或两个以上方法签名相同的默认方法时就会产生冲突，java8定义如下三条原则来解决冲突：</p>
<ol>
<li>类或父类中显式声明的方法，其优先级高于所有的默认方法；</li>
<li>如果1规则失效，则选择与当前类距离最近的具有具体实现的默认方法；</li>
<li>如果2规则也失效，则需要显式指定接口。</li>
</ol>
<hr>
<h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><p>Lambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式，它提供了轻量级的语法</p>
<p>重点留意这四个关键词：匿名、函数、传递、简洁</p>
<p>Lambda的三个部分：</p>
<ul>
<li>参数列表</li>
<li>箭头</li>
<li>Lambda 主体</li>
</ul>
<p>Lambda的基本语法大概就是下面这样子的了：</p>
<ul>
<li>(parameters) -&gt; expression</li>
<li>(parameters) -&gt; { statements; }</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    return b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line">或者是</span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">亦或是</span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Lexiacal-Scope"><a href="#Lexiacal-Scope" class="headerlink" title="Lexiacal Scope"></a>Lexiacal Scope</h2><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>可以直接在Lambda表达式中访问外层的局部变量，但是和匿名对象不同的是，Lambda表达式的局部变量可以不用声明为final，不过局部变量必须不可被后面的代码修改（即隐性的具有final的语义）。</p>
<p>eg：下面代码无法编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = 1; </span><br><span class="line">Converter&lt;Integer, String&gt; s =  </span><br><span class="line">	(param) -&gt; String.valueOf(param + num);  </span><br><span class="line">num = 5;</span><br></pre></td></tr></table></figure></p>
<p>在Lambda表达式中试图修改局部变量是不允许的！</p>
<ol>
<li>在 Lambda 表达式当中被引用的变量的值不可以被更改。</li>
<li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li>
<li>和局部变量不同的是，Lambda内部对于实例的字段（即：成员变量）以及静态变量是即可读又可写。</li>
</ol>
<h3 id="不能访问接口的默认方法"><a href="#不能访问接口的默认方法" class="headerlink" title="不能访问接口的默认方法"></a>不能访问接口的默认方法</h3><p>Lambda表达式中是无法访问到默认方法的。</p>
<p>补充：Lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，在这里增加一个例子以说明这个特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over values</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = new List&lt;&gt;();</span><br><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类的简写？"><a href="#匿名内部类的简写？" class="headerlink" title="匿名内部类的简写？"></a>匿名内部类的简写？</h3><p>Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件</p>
<h3 id="Lambda表达式中的this"><a href="#Lambda表达式中的this" class="headerlink" title="Lambda表达式中的this"></a>Lambda表达式中的this</h3><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。</p>
<hr>
<h2 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h2><p>任意只包含一个抽象方法的接口，我们都可以用来做成Lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(&quot;123&quot;);</span><br><span class="line">System.out.println(converted);    // 123</span><br></pre></td></tr></table></figure>
<p>注意，如果你不写@FunctionalInterface 标注，程序也是正确的。</p>
<p>下面是Java SE 7中已经存在的函数式接口：</p>
<ul>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.security.PrivilegedAction</li>
<li>java.util.Comparator</li>
<li>java.io.FileFilter</li>
<li>java.beans.PropertyChangeListener</li>
</ul>
<p>除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：</p>
<ul>
<li>Predicate<t>——接收T对象并返回boolean</t></li>
<li>Consumer<t>——接收T对象，不返回值</t></li>
<li>Function&lt;T, R&gt;——接收T对象，返回R对象</li>
<li>Supplier<t>——提供T对象（例如工厂），不接收值</t></li>
<li>UnaryOperator<t>——接收T对象，返回T对象</t></li>
<li>BinaryOperator<t>——接收两个T对象，返回T对象</t></li>
</ul>
<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction&lt;T, U, R&gt;，它接收T对象和U对象，返回R对象。</p>
<hr>
<h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>Lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。</p>
<p>方法引用和Lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>
<p>方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。<br>方法引用有很多种，它们的语法如下：</p>
<ul>
<li>静态方法引用：ClassName::methodName</li>
<li>实际上的实例方法引用：instanceReference::methodName</li>
<li>超类上的实例方法引用：super::methodName</li>
<li>类型上的实例方法引用：ClassName::methodName</li>
<li>构造方法引用：Class::new</li>
<li>数组构造方法引用：TypeName[]::new</li>
</ul>
<p>对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。</p>
<p>结合Lambda可以使我们的代码更加简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;);</span><br><span class="line">strings.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt; chars = Arrays.asList(&apos;a&apos;, &apos;b&apos;);	System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;)));</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>NullPointException可以说是所有Java程序员都遇到过的一个异常，虽然Java从设计之初就力图让程序员脱离指针的苦海，但是指针确实是实际存在的，而java设计者也只能是让指针在Java语言中变得更加简单、易用，而不能完全的将其剔除，所以才有了我们日常所见到的关键字null。</p>
<p>空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。当异常真的发生的时候，处理策略也很简单，在存在异常的地方添加一个if语句判定即可，但是这样的应对策略会让我们的程序出现越来越多的null判定，我们知道一个良好的程序设计，应该让代码中尽量少出现null关键字，而Java8所提供的Optional类则在减少NullPointException的同时，也提升了代码的美观度。但首先我们需要明确的是，它并 不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现，从而避免NullPointException。</p>
<p>java.util.Optional<t> 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。</t></p>
<p>创建 Optional 对象,三个静态工厂方法：</p>
<ul>
<li>Optional.empty：创建空的 Optional 对象</li>
<li>Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE</li>
<li>Optianal.ofNullable：创建 Optional 对象，允许传空值</li>
</ul>
<p>Optional API：</p>
<ul>
<li>isPresent(): 变量存在返回true</li>
<li>get(): 返回封装的变量值，或者抛出 NoSuchElementException</li>
<li>orElse(T other): 提供默认值</li>
<li>orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版</li>
<li>orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型</li>
<li>ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法</li>
<li>filter(Predicate&lt;? super T&gt; predicate): 过滤</li>
<li>map(Function&lt;? super T, ? extends U&gt; mapper): 转换</li>
<li>flatMap(Function&lt;? super T, Optional&lt;U>>mapper): 转换成Optional</li>
</ul>
<p>值得注意的是：Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题</p>
<p>Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法，没有考虑将它作为类的字段使用…</p>
<p>另外，在Java9中对Optional添加了三个新的方法：</p>
<ol>
<li><p>public Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)<br>or 方法的作用是，如果一个 Optional 包含值，则返回自己；否则返回由参数 supplier 获得的 Optional</t></p>
</li>
<li><p>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)<br>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()</p>
</li>
<li>public Stream<t> stream()<br>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream；否则返回一个空的 Stream（Stream.empty()）</t></li>
</ol>
<p>举个例子，在 Java8，我们会写下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 此处 getUserById 返回的是 Optional&lt;User&gt;</span><br><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">       return userIds.stream()</span><br><span class="line">            .map(this::getUserById)     // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .filter(Optional::isPresent)// 去掉不包含值的 Optional</span><br><span class="line">            .map(Optional::get)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有了 Optional.stream()，我们就可以将其简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">    return userIds.stream()</span><br><span class="line">            .map(this::getUserById)    // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><img src="/images/Java_stream_Interfaces.png" alt=""></p>
<h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;).stream()</span><br><span class="line">                                           .filter(s -&gt; s.startsWith(&quot;c&quot;))</span><br><span class="line">                                           .map(String::toUpperCase)</span><br><span class="line">                                           .sorted()</span><br><span class="line">                                           .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>流是Java SE 8类库中新增的关键抽象，它被定义于java.util.stream（这个包里有若干流类型：Stream<t>代表对象引用流，此外还有一系列特化（specialization）流，比如IntStream代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。流的操作可以被组合成流水线（Pipeline）。</t></p>
<p>引入的原因：</p>
<ul>
<li>声明性方式处理数据集合</li>
<li>透明地并行处理，提高性能</li>
</ul>
<p>流 的定义：从支持数据处理操作的源生成的元素序列</p>
<p>两个重要特点</p>
<ul>
<li>流水线</li>
<li>内部迭代</li>
</ul>
<p>流与集合：</p>
<ul>
<li>集合与流的差异就在于什么时候进行计算 <ul>
<li>集合是内存中的数据结构，包含数据结构中目前所有的值</li>
<li>流的元素则是按需计算/生成</li>
</ul>
</li>
<li>另一个关键区别在于遍历数据的方式 <ul>
<li>集合使用 Collection 接口，需要用户去做迭代，称为外部迭代</li>
<li>流的 Streams 库使用内部迭代</li>
</ul>
</li>
</ul>
<p>流的使用</p>
<ul>
<li>一个数据源（如集合）来执行一个查询；</li>
<li>一个中间操作链，形成一条流的流水线；</li>
<li>一个终端操作，执行流水线，并能生成结果。</li>
</ul>
<p>流的流水线背后的理念类似于构建器模式。常见的中间操作有filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。</p>
<p><img src="/images/stream.png" alt=""></p>
<p>流的操作类型分为两种：</p>
<ul>
<li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><ul>
<li>由值创建流：Stream.of、Stream.empty、IntStream.range</li>
<li>由集合创建流：Collection.stream、Collection.parallelStream</li>
<li>由数组创建流：Arrays.stream(数组变量)</li>
<li>由文件生成流：Files.lines、Files.walk</li>
<li>由BufferedReader创建流：java.io.BufferedReader.lines</li>
<li>由函数生成流：创建无限流， <ul>
<li>迭代： Stream.iterate（接受一个种子值，和一个UnaryOperator）</li>
<li>生成：Stream.generate（接收一个Supplier接口）</li>
</ul>
</li>
</ul>
<h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>Intermediate（中间操作）：</p>
<ul>
<li>筛选<ul>
<li>谓词筛选：filter</li>
<li>筛选互异的元素：distinct</li>
<li>忽略头几个元素：skip</li>
<li>截短至指定长度：limit</li>
<li>排序：sorted</li>
<li>偷瞄（输出）：peek</li>
<li>平行化：parallel</li>
<li>串行化：sequential</li>
</ul>
</li>
<li>映射 <ul>
<li>对流中每个元素应用函数：map</li>
<li>流的扁平化：flatMap</li>
<li>转为原始流：mapToInt、mapToInt、mapToInt</li>
<li>从原始流转为普通流：boxed</li>
</ul>
</li>
<li>数值范围<ul>
<li>range:[起始值，结束值)</li>
<li>rangeClosed:[起始值，结束值]</li>
</ul>
</li>
</ul>
<p>Terminal（终结操作）</p>
<ul>
<li>查找和匹配<ul>
<li>检查谓词是否至少匹配一个元素：anyMatch</li>
<li>检查谓词是否匹配所有元素：allMatch/noneMatch</li>
<li>查找元素：findAny</li>
<li>查找第一个元素：findFirst</li>
</ul>
</li>
<li>归约（折叠）：reduce(初值，结合操作)<ul>
<li>元素求和：count、sum</li>
<li>最大值和最小值：min、 max</li>
</ul>
</li>
<li>遍历<ul>
<li>forEach、 forEachOrdered</li>
</ul>
</li>
</ul>
<p>anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。<br>原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。</p>
<ul>
<li>映射到数值流：mapToInt,mapToDouble,mapToLong</li>
<li>转换回流对象：boxed</li>
<li>默认值：OptionalInt,OptionalDouble,OptionalLong</li>
</ul>
<h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><p>对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。</p>
<p>Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能：</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
<p>归约和汇总(Collectors 类中的工厂方法)：</p>
<ul>
<li>统计个数：Collectors.counting</li>
<li>查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy</li>
<li>汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数</li>
<li>连接字符串：joining</li>
<li>广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。</li>
</ul>
<p>collect vs. reduce，两者都是 Stream 接口的方法，区别在于：</p>
<ul>
<li>语意问题<ul>
<li>reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约；</li>
<li>collect 方法设计就是要改变容器，从而累积要输出的结果</li>
</ul>
</li>
<li>实际问题<ul>
<li>以错误的语义使用 reduce 会导致归约过程不能并行工作</li>
</ul>
</li>
</ul>
<p>分组和分区</p>
<ul>
<li>分组：Collectors.groupingBy<ul>
<li>多级分组</li>
<li>按子数组收集数据: maxBy<ul>
<li>把收集器的结果转换为另一种结果 collectingAndThen</li>
<li>与 groupingBy 联合使用的其他收集器例子：summingInt,mapping</li>
</ul>
</li>
</ul>
</li>
<li>分区：Collectors.partitioningBy是分组的特殊情况，由一个谓词作为分类函数(分区函数)，返回一个Map，只有两个Boolean类型的key。</li>
</ul>
<h3 id="Ex1-使用collect-生成Collection"><a href="#Ex1-使用collect-生成Collection" class="headerlink" title="Ex1:使用collect()生成Collection"></a>Ex1:使用collect()生成Collection</h3><p>前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将Stream转换成List或Set</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span><br><span class="line"></span><br><span class="line">上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用toCollection()指定规约容器的类型</span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)</span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)</span><br></pre></td></tr></table></figure>
<p>上述代码(3)处指定规约结果是ArrayList，而(4)处指定规约结果为HashSet。一切如你所愿。</p>
<h3 id="Ex2-使用collect-生成Map"><a href="#Ex2-使用collect-生成Map" class="headerlink" title="Ex2:使用collect()生成Map"></a>Ex2:使用collect()生成Map</h3><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map：</p>
<ol>
<li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li>
<li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li>
<li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li>
</ol>
<p>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用toMap()统计学生GPA</span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key</span><br><span class="line">                                     student -&gt; computeGPA(student)));// 如何生成value</span><br></pre></td></tr></table></figure>
<p>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Partition students into passing and failing</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>
<p>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Group employees by department</span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure>
<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用下游收集器统计每个部门的人数</span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));// 下游收集器</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,// 下游收集器</span><br><span class="line">                                Collectors.toList())));// 更下游的收集器</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Notice-And-Optimization"><a href="#Notice-And-Optimization" class="headerlink" title="Notice And Optimization"></a>Notice And Optimization</h2><ul>
<li>流不可被复用</li>
<li>一般先filter、limit、skip操作后再进行sorted、peek、map等操作以达到short-circuiting 目的</li>
</ul>
<table>
<thead>
<tr>
<th>Stream操作分类</th>
<th></th>
<th>方法 </th>
</tr>
</thead>
<tbody>
<tr>
<td>中间操作(Intermediate operations)</td>
<td>无状态(Stateless)</td>
<td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>
</tr>
<tr>
<td>有状态(Stateful)</td>
<td>distinct() sorted() sorted() limit() skip()</td>
<td></td>
</tr>
<tr>
<td>结束操作(Terminal operations)</td>
<td>非短路操作</td>
<td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td>
</tr>
<tr>
<td>短路操作(short-circuiting)</td>
<td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>
<td></td>
</tr>
</tbody>
</table>
<p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>
<hr>
<h2 id="Java8-对字符串连接的改进"><a href="#Java8-对字符串连接的改进" class="headerlink" title="Java8 对字符串连接的改进"></a>Java8 对字符串连接的改进</h2><p>有时候，我们会有一种需求就是将若干个字符串用某个链接符衔接起来，例如有一个 List，将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式。</p>
<p>以前我们的一般做法就是使用StringBuilder：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringBuilder result = new StringBuilder();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.append(str).append(delimiter);</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除末尾多余的 delimiter</span><br><span class="line">    result.delete(result.length() - delimiter.length(), result.length()); </span><br><span class="line">    </span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringBuilder：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">使用 StringBuilder：</span><br><span class="line">a,b,c,d,e,f,g</span><br></pre></td></tr></table></figure>
<p>JDK1.8 时，添加了一个新的用于字符串连接的类，专门用于这种需要 分隔符 的场合，它就是 StringJoiner。StringJoiner 在构造时可以指定一个分隔符（delimiter），然后每连接一个元素它便会加上一个 delimiter，使用 StringJoiner 改写 formatList：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用String.join:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    return String.join(delimiter, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String.join 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 List<string> 格式化为 { 元素1, 元素2, 元素3, … 元素N } 呢？（此时前缀为 “{ “，后缀为 “ }”）</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter, prefix, suffix);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner，带前缀和后缀：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，Java8 对于字符串集合的连接操作提供了一个专门的流式 API，即 Collectors.joining 函数</p>
<ul>
<li>无参的 joining() 方法，即不存在连接符（底层实现为 StringBuilder）；</li>
<li>joining(CharSequence delimiter) 方法，即分隔符为 delimiter（底层实现为 StringJoiner）；</li>
<li>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法，即分隔符为 delimiter，前缀为 prefix，后缀为 suffix（底层实现为 StringJoiner）。</li>
</ul>
<p>那怎么使用呢？ 我们直接使用三个参数的 Collectors.joining 方法改写 formatList：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Collectors.joining：&quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Java8-中-Map-接口的新方法"><a href="#Java8-中-Map-接口的新方法" class="headerlink" title="Java8 中 Map 接口的新方法"></a>Java8 中 Map 接口的新方法</h2><p>假如现在我们存在这样的需求：给定一个 List<string>，统计每个元素出现的所有位置。</string></p>
<p>比如，给定 list：[“a”, “b”, “b”, “c”, “c”, “c”, “d”, “d”, “d”, “f”, “f”, “g”] ，那么应该返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a : [0]</span><br><span class="line">b : [1, 2]</span><br><span class="line">c : [3, 4, 5]</span><br><span class="line">d : [6, 7, 8]</span><br><span class="line">f : [9, 10]</span><br><span class="line">g : [11]</span><br></pre></td></tr></table></figure></p>
<p>很明显，我们很适合使用 Map 来完成这件事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        List&lt;Integer&gt; positions = positionsMap.get(str);</span><br><span class="line"></span><br><span class="line">        if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt;</span><br><span class="line">            positions = new ArrayList&lt;&gt;(1);</span><br><span class="line">            positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Java8 之前的 API：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 Java8 之前的 API：</span><br><span class="line">&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125;</span><br></pre></td></tr></table></figure>
<p>computeIfAbsent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 computeIfAbsent：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="当-forEach-需要索引"><a href="#当-forEach-需要索引" class="headerlink" title="当 forEach 需要索引"></a>当 forEach 需要索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是方法里面的for循环似乎让这个方法不太优雅了，Java8中Iterable提供的foreach并不带索引的：</p>
<p>我们可以自己写一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void forEach(</span><br><span class="line">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后改造getElementPositions方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>参考</em></p>
<blockquote>
<p><a href="http://yangbingdong.com/2017/java-8-tutorial/" target="_blank" rel="noopener">Java8 Noob Tutorial</a></p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://hsb786.github.io/2018/04/12/java8新特性（转载）/" data-id="cjfwk3c1i000xrwmyrudhxi6a" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/04/12/Java虚拟机/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    Java虚拟机
                
            </div>
        </a>
    
    
        <a href="/2018/04/12/合并两个排序的链表/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">合并两个排序的链表</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
    <div id="valine-thread"></div>
</section>
    

</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/sql/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/12/sql/" class="title">sql</a></p>
                            <p class="item-date"><time datetime="2018-04-12T12:56:19.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/Java虚拟机/" class="thumbnail">
    
    
        <span style="background-image:url(/images/java虚拟机.png)" alt="Java虚拟机" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/12/Java虚拟机/" class="title">Java虚拟机</a></p>
                            <p class="item-date"><time datetime="2018-04-12T12:01:50.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/java8新特性（转载）/" class="thumbnail">
    
    
        <span style="background-image:url(/images/java8.jpg)" alt="java8新特性（转载）" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/12/java8新特性（转载）/" class="title">java8新特性（转载）</a></p>
                            <p class="item-date"><time datetime="2018-04-12T07:56:55.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/合并两个排序的链表/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/12/合并两个排序的链表/" class="title">合并两个排序的链表</a></p>
                            <p class="item-date"><time datetime="2018-04-12T07:29:59.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/MyBatis/" class="thumbnail">
    
    
        <span style="background-image:url(/images/mybatis-logo.png)" alt="MyBatis" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/12/MyBatis/" class="title">MyBatis</a></p>
                            <p class="item-date"><time datetime="2018-04-12T05:39:35.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">40</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指Offer/">剑指Offer</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爪哇/">爪哇</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">11</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/sql/" style="font-size: 12px;">sql</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/剑指Offer/" style="font-size: 18px;">剑指Offer</a> <a href="/tags/多线程/" style="font-size: 14px;">多线程</a> <a href="/tags/工具/" style="font-size: 16px;">工具</a> <a href="/tags/爪哇/" style="font-size: 20px;">爪哇</a> <a href="/tags/算法/" style="font-size: 18px;">算法</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://www.douban.com/people/122973953/">我的豆瓣</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 HuShengBin<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.6/dist/Valine.min.js"></script>
    <script>
        new Valine({
            el: '#valine-thread' ,
            notify:false,
            verify:false,
            app_id: 'eqjWlM0tCYgxhh8nvvV6DleG-gzGzoHsz',
            app_key: 'CRXn0n9IAsJdOeMDUIxyh1Hb',
            placeholder: '(。・∀・)ノ说一句吧'
        });
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>